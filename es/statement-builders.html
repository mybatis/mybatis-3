<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 02 enero 2017 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Clinton Begin" />
    <meta name="author" content="Eduardo Macarron" />
    <meta name="Date-Revision-yyyymmdd" content="20170102" />
    <meta http-equiv="Content-Language" content="es" />
    <title>MyBatis &#x2013; MyBatis 3 | Statement Builders</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
      <script type="text/javascript" src="./js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarDisabled">
      <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>mybatis</h2>
</div>
</div>
        <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 02 enero 2017<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.4.3-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html" title="Introducción"><span class="none"></span>Introducción</a>  </li>
    <li><a href="getting-started.html" title="Primeros pasos"><span class="none"></span>Primeros pasos</a>  </li>
    <li><a href="configuration.html" title="Configuración"><span class="icon-chevron-right"></span>Configuración</a>  </li>
    <li><a href="sqlmap-xml.html" title="Ficheros XML de mapeo"><span class="icon-chevron-right"></span>Ficheros XML de mapeo</a>  </li>
    <li><a href="dynamic-sql.html" title="SQL dinámico"><span class="none"></span>SQL dinámico</a>  </li>
    <li><a href="java-api.html" title="Java API"><span class="icon-chevron-right"></span>Java API</a>  </li>
    <li class="active"><a href="#"><span class="none"></span>La clase SQL</a>
  </li>
    <li><a href="logging.html" title="Logging"><span class="none"></span>Logging</a>  </li>
          <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html" title="Información del proyecto"><span class="icon-chevron-right"></span>Información del proyecto</a>  </li>
    <li><a href="project-reports.html" title="Informes del proyecto"><span class="icon-chevron-right"></span>Informes del proyecto</a>  </li>
  </ul>
          <hr />
          <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="http://maven.apache.org/" title="Generado por Maven" class="poweredBy"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >


  
  <div class="section">
<h2><a name="The_SQL_Builder_Class"></a>The SQL Builder Class</h2>
  
<div class="section">
<h3><a name="El_Problema"></a>El Problema</h3>
  
<p>Una de las cosas m&#xe1;s tediosas que un programador Java puede llegar a tener que hacer es incluir c&#xf3;digo SQL en c&#xf3;digo Java. Normalmente esto se hace cuando es necesario generar din&#xe1;micamente el SQL &#x2013; de otra forma podr&#xed;as externalizar el c&#xf3;digo en un fichero o un procedimiento almacenado. Como ya has visto, MyBatis tiene una respuesta potente a la generaci&#xf3;n din&#xe1;mica de SQL mediante las capacidades del mapeo XML. Sin embargo, en ocasiones se hace necesario construir una sentencia SQL dentro del c&#xf3;digo Java. En este caso, MyBatis tiene una funcionalidad m&#xe1;s para ayudarte en ello, antes de que comiences con el t&#xed;pico l&#xed;o de signos de suma, comillas, l&#xed;neas nuevas, problemas de formato y condicionales anidados para tratar con las comas extra y las conjunciones AND&#x2026; Realmente, generar c&#xf3;digo din&#xe1;mico en java, puede ser una verdadera pesadilla. Por ejemplo:</p>

<div class="source"><pre class="prettyprint">
String sql = &quot;SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, &quot;
&quot;P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON &quot; +
&quot;FROM PERSON P, ACCOUNT A &quot; +
&quot;INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID &quot; +
&quot;INNER JOIN COMPANY C on D.COMPANY_ID = C.ID &quot; +
&quot;WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) &quot; +
&quot;OR (P.LAST_NAME like ?) &quot; +
&quot;GROUP BY P.ID &quot; +
&quot;HAVING (P.LAST_NAME like ?) &quot; +
&quot;OR (P.FIRST_NAME like ?) &quot; +
&quot;ORDER BY P.ID, P.FULL_NAME&quot;;
</pre></div>
  </div>

  
<div class="section">
<h3><a name="La_Solucin"></a>La Soluci&#xf3;n</h3>
  
<p>MyBatis 3 introduce un concepto un tanto distinto para tratar con el problema.
    Con la clase SQL, puecdes crear una sentencia SQL en un s&#xf3;lo paso invocando a sus m&#xe9;todos.
    El ejemplo anterior tendr&#xed;a este aspecto si se rescribe con la clase SQL:  
  </p>

      
<div class="source"><pre class="prettyprint">
private String selectPersonSql() {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
    SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
    FROM(&quot;PERSON P&quot;);
    FROM(&quot;ACCOUNT A&quot;);
    INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
    INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
    WHERE(&quot;P.ID = A.ID&quot;);
    WHERE(&quot;P.FIRST_NAME like ?&quot;);
    OR();
    WHERE(&quot;P.LAST_NAME like ?&quot;);
    GROUP_BY(&quot;P.ID&quot;);
    HAVING(&quot;P.LAST_NAME like ?&quot;);
    OR();
    HAVING(&quot;P.FIRST_NAME like ?&quot;);
    ORDER_BY(&quot;P.ID&quot;);
    ORDER_BY(&quot;P.FULL_NAME&quot;);
  }}.toString();
}
</pre></div>
    
<p>&#xbf;Qu&#xe9; hay de especial en este ejemplo? 
      Bien, si lo miras detenidamente, ver&#xe1;s que no hay que preocuparse de duplicar &#x201c;AND&#x201d;s, o elegir entre &#x201c;WHERE&#x201d; o &#x201c;AND&#x201d;, o ninguno de ambos!
      La clase SQL se ocupa de colocar el &quot;WHERE&quot; donde debe de ir, si debe usarse &quot;AND&quot; o no y de realizar todas las concatenaciones de Strings.
    </p>
    </div>
      
<div class="section">
<h3><a name="La_clase_SQL"></a>La clase SQL</h3>

        
<p>Aqui van algunos ejemplos:</p>

        
<div class="source"><pre class="prettyprint">
// Anonymous inner class
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

// Builder / Fluent style
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;)
    .VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;)
    .toString();
  return sql;
}

// With conditionals (note the final parameters, required for the anonymous inner class to access them)
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;);
    FROM(&quot;PERSON P&quot;);
    if (id != null) {
      WHERE(&quot;P.ID like #{id}&quot;);
    }
    if (firstName != null) {
      WHERE(&quot;P.FIRST_NAME like #{firstName}&quot;);
    }
    if (lastName != null) {
      WHERE(&quot;P.LAST_NAME like #{lastName}&quot;);
    }
    ORDER_BY(&quot;P.LAST_NAME&quot;);
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO(&quot;PERSON&quot;);
    VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;);
    VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;);
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE(&quot;PERSON&quot;);
    SET(&quot;FIRST_NAME = #{firstName}&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}
</pre></div>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Metodo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
  
<tr class="b">
    
<td>
      
<ul>
        
<li>
          <tt>SELECT(String)</tt>
        </li>
        
<li>
          <tt>SELECT(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>Comienza o a&#xf1;ade a una sentencia SELECT. Se puede invocar m&#xe1;s de una vez y los par&#xe1;metros se ir&#xe1;n a&#xf1;adiendo a la sentencia SELECT. Los par&#xe1;metros son normalmente una lista de columnas o alias separados por comas, pero puede ser cualquier cosa que acepte el driver de base de datos.</td>
  </tr>
  
<tr class="a">
    
<td>
      
<ul>
        
<li>
          <tt>SELECT_DISTINCT(String)</tt>
        </li>
        
<li>
          <tt>SELECT_DISTINCT(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>Comienza o a&#xf1;ade a una sentencia SELECT, tambi&#xe9;n a&#xf1;ade la palabra clave &#x201c;DISTINCT&#x201d; a la sentencia generada. Se puede invocar m&#xe1;s de una vez y los par&#xe1;metros se ir&#xe1;n a&#xf1;adiendo a la sentencia SELECT. Los par&#xe1;metros son normalmente una lista de columnas o alias separados por comas, pero puede ser cualquier cosa que acepte el driver de base de datos.</td>
  </tr>
  
<tr class="b">
    
<td>
      
<ul>
        
<li>
          <tt>FROM(String)</tt>
        </li>
        
<li>
          <tt>FROM(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>Comienza o a&#xf1;ade a una cl&#xe1;usula FROM. Se puede invocar m&#xe1;s de una vez y los par&#xe1;metros se ir&#xe1;n a&#xf1;adiendo a la clausula FROM. Los par&#xe1;metros son normalmente un nombre de tabla o alias o cualquier cosa que acepte el driver de base de datos.</td>
  </tr>
  
<tr class="a">
    
<td>
      
<ul>
        
<li>
          <tt>JOIN(String)</tt>
        </li>
        
<li>
          <tt>JOIN(String...)</tt>
        </li>
        
<li>
          <tt>INNER_JOIN(String)</tt>
        </li>
        
<li>
          <tt>INNER_JOIN(String...)</tt>
        </li>
        
<li>
          <tt>LEFT_OUTER_JOIN(String)</tt>
        </li>
        
<li>
          <tt>LEFT_OUTER_JOIN(String...)</tt>
        </li>
        
<li>
          <tt>RIGHT_OUTER_JOIN(String)</tt>
        </li>
        
<li>
          <tt>RIGHT_OUTER_JOIN(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva clausula JOIN del tipo apropiado, dependiendo al m&#xe9;todo que se haya llamado. El par&#xe1;metro puede incluir un join est&#xe1;ndar que consiste en las columnas y las condiciones sobre las que hacer la join.</td>
  </tr>
  
<tr class="b">
    
<td>
      
<ul>
        
<li>
          <tt>WHERE(String)</tt>
        </li>
        
<li>
          <tt>WHERE(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva condici&#xf3;n a la clausula WHERE concatenada con un AND. Puede llamarse m&#xe1;s de una vez, lo cual har&#xe1; que se a&#xf1;adan m&#xe1;s condiciones todas ellas concatenadas con un AND. O usa OR() para partirlas con un OR().</td>
  </tr>
  
<tr class="a">
    
<td>
      <tt>OR()</tt>
    </td>
    
<td>Parte las condiciones actuales de la WHERE con un OR. Puede llamarse m&#xe1;s de una vez, pero llamarlas m&#xe1;s de una vez en la misma l&#xed;nea puede producir sentencias incorrectas.</td>
  </tr>
  
<tr class="b">
    
<td>
      <tt>AND()</tt>
    </td>
    
<td>Parte las condiciones actuales de la WHERE con un AND. Puede llamarse m&#xe1;s de una vez, pero llamarlas m&#xe1;s de una vez en la misma l&#xed;nea puede producir sentencias incorrectas.  Dado que WHERE y HAVING concatenan autom&#xe1;ticamente el AND, es muy infrecuente que sea necesario invocar a este m&#xe9;todo y se incluye realmente por completitud.</td>
  </tr>
  
<tr class="a">
    
<td>
      
<ul>
        
<li>
          <tt>GROUP_BY(String)</tt>
        </li>
        
<li>
          <tt>GROUP_BY(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva clausula GROUP BY grupo, concatenada con una coma. Se le puede llamar m&#xe1;s de una vez, lo cual har&#xe1; que se concatenen nuevas condiciones separadas tambi&#xe9;n por coma.</td>
  </tr>
  
<tr class="b">
    
<td>
      
<ul>
        
<li>
          <tt>HAVING(String)</tt>
        </li>
        
<li>
          <tt>HAVING(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva clausula HAVING, concatenada con un AND. Se le puede llamar m&#xe1;s de una vez, lo cual har&#xe1; que se concatenen nuevas condiciones separadas tambi&#xe9;n por AND. Usa OR() para dividirlas por OR.</td>
  </tr>
  
<tr class="a">
    
<td>
      
<ul>
        
<li>
          <tt>ORDER_BY(String)</tt>
        </li>
        
<li>
          <tt>ORDER_BY(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade un Nuevo elemento a la clausula ORDER BY concatenado por coma. Se le puede llamar m&#xe1;s de una vez, lo cual har&#xe1; que se concatenen nuevas condiciones separadas tambi&#xe9;n por coma.</td>
  </tr>
  
<tr class="b">
    
<td>
      <tt>DELETE_FROM(String)</tt>
    </td>
    
<td>Comienza una sentencia delete y especifica la tabla donde borrar. Generalmente suele ir seguida de una clausula WHERE!
    </td>
  </tr>
  
<tr class="a">
    
<td>
      <tt>INSERT_INTO(String)</tt>
    </td>
    
<td>Comienza una sentencia insert y especifica al tabla en la que insertar. Suele ir seguida de una o m&#xe1;s llamadas a VALUES() o INTO_COLUMNS() y INTO_VALUES().
    </td>
  </tr>
  
<tr class="b">
    
<td>
      
<ul>
        
<li>
          <tt>SET(String)</tt>
        </li>
        
<li>
          <tt>SET(String...)</tt>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade a la lista &#x201c;set&#x201d; de una update.</td>
  </tr>
  
<tr class="a">
    
<td>
      <tt>UPDATE(String)</tt>
    </td>
    
<td>Comienza una sentencia update y especifica la tabla que modificar Suele ir seguida de una o m&#xe1;s llamadas a SET() y normalmente de una llamada a WHERE().</td>
  </tr>
  
<tr class="b">
    
<td>
      <tt>VALUES(String, String)</tt>
    </td>
    
<td>A&#xf1;ade a una sentencia insert. El primer par&#xe1;metro es el nombre de columna y el Segundo el valor(es).</td>
  </tr>
  
<tr class="a">
    
<td>
      <tt>INTO_COLUMNS(String...)</tt>
    </td>
    
<td>
      Appends columns phrase to an insert statement.
      This should be call INTO_VALUES() with together.
    </td>
  </tr>
  
<tr class="b">
    
<td>
      <tt>INTO_VALUES(String...)</tt>
    </td>
    
<td>
      Appends values phrase to an insert statement.
      This should be call INTO_COLUMNS() with together.
    </td>
  </tr>
          </tbody>
        </table>

        
<p>Since version 3.4.2, you can use variable-length arguments as follows:</p>


<div class="source"><pre class="prettyprint">
public String selectPersonSql() {
  return new SQL()
    .SELECT(&quot;P.ID&quot;, &quot;A.USERNAME&quot;, &quot;A.PASSWORD&quot;, &quot;P.FULL_NAME&quot;, &quot;D.DEPARTMENT_NAME&quot;, &quot;C.COMPANY_NAME&quot;)
    .FROM(&quot;PERSON P&quot;, &quot;ACCOUNT A&quot;)
    .INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;, &quot;COMPANY C on D.COMPANY_ID = C.ID&quot;)
    .WHERE(&quot;P.ID = A.ID&quot;, &quot;P.FULL_NAME like #{name}&quot;)
    .ORDER_BY(&quot;P.ID&quot;, &quot;P.FULL_NAME&quot;)
    .toString();
}

public String insertPersonSql() {
  return new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;)
    .INTO_VALUES(&quot;#{id}&quot;, &quot;#{fullName}&quot;)
    .toString();
}

public String updatePersonSql() {
  return new SQL()
    .UPDATE(&quot;PERSON&quot;)
    .SET(&quot;FULL_NAME = #{fullName}&quot;, &quot;DATE_OF_BIRTH = #{dateOfBirth}&quot;)
    .WHERE(&quot;ID = #{id}&quot;)
    .toString();
}
</pre></div>

      </div>

      
<div class="section">
<h3><a name="SqlBuilder_y_SelectBuilder_DEPRECADAS"></a>SqlBuilder y SelectBuilder (DEPRECADAS)</h3>
        
<p>
          En versiones anteriores a la 3.2 optamos por una soluci&#xf3;n distinta, usando una variable ThreadLocal para 
          resolver algunas limitaciones de las que hacen los DSLs Java algo incomodos. Sin embargo, esta soluci&#xf3;n est&#xe1; ahora
          desprecada porque los frameworks actuales est&#xe1;n mas orientados a usar patrones builder-type y clases an&#xf3;nimas 
          interas para este tipo de cosas. Por lo tanto las clases SelectBuilder y SqlBuilder est&#xe1;n ahora deprecadas.
        </p>
        
<p>
          Los siguientes m&#xe9;todos aplican solo a las clases deprecadas SqlBuilder y SelectBuilder.
        </p>
        
<table border="0" class="table table-striped">
        <thead>
          
<tr class="a">
            
<th>M&#xe9;todo</th>
            
<th>Descripci&#xf3;n</th>
          </tr>
        </thead>
        <tbody>
  
<tr class="b">
    
<td>
      <tt>BEGIN()</tt> / <tt>RESET()</tt>
    </td>
    
<td>Estos m&#xe9;todos limpian estado guardad en el ThreadLocal de la clase SelectBuilder, y la preparan para construir una nueva sentencia. BEGIN() se lee mejor cuando se est&#xe1; creando una sentencia. RESET() se lee mejor cuando se est&#xe1; borrando lo hecho anteriormente en medio de una ejecuci&#xf3;n (quiz&#xe1; porque la l&#xf3;gica necesita una sentencia completamente distinta seg&#xfa;n las condiciones).</td>
  </tr>
  
<tr class="a">
    
<td>
      <tt>SQL()</tt>
    </td>
    
<td>Devuelve la SQL generada y restablece el estado del SelectBuilder (como si se hubiera llamado a un BEGIN() o a un RESET()). Por tanto este m&#xe9;todo solo se puede llamar una vez!</td>
  </tr>
        </tbody>
        </table>

  
<p>La clase SelectBuilder no es m&#xe1;gica, pero es importante que conozcas c&#xf3;mo funcionan. 
  SelectBuilder y SqlBuilder usan una combinaci&#xf3;n de imports est&#xe1;ticos y una variable ThreadLocal para permitir una sintaxis m&#xe1;s limpia m&#xe1;s f&#xe1;cilmente usabe con condicionales. 
  Para usarlas debes importar est&#xe1;ticamente m&#xe9;todos de las siguientes clases (uno u otro, no ambos):</p>

        
<div class="source"><pre class="prettyprint">import static org.apache.ibatis.jdbc.SelectBuilder.*;</pre></div>
        
<div class="source"><pre class="prettyprint">import static org.apache.ibatis.jdbc.SqlBuilder.*;</pre></div>

        
<p>De esta forma podr&#xe1;s crear m&#xe9;todos como estos:</p>

        
<div class="source"><pre class="prettyprint">
/* DEPRECATED */
public String selectBlogsSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT(&quot;*&quot;);
  FROM(&quot;BLOG&quot;);
  return SQL();
}
        </pre></div>

        
<div class="source"><pre class="prettyprint">
/* DEPRECATED */
private String selectPersonSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
  SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
  FROM(&quot;PERSON P&quot;);
  FROM(&quot;ACCOUNT A&quot;);
  INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
  INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
  WHERE(&quot;P.ID = A.ID&quot;);
  WHERE(&quot;P.FIRST_NAME like ?&quot;);
  OR();
  WHERE(&quot;P.LAST_NAME like ?&quot;);
  GROUP_BY(&quot;P.ID&quot;);
  HAVING(&quot;P.LAST_NAME like ?&quot;);
  OR();
  HAVING(&quot;P.FIRST_NAME like ?&quot;);
  ORDER_BY(&quot;P.ID&quot;);
  ORDER_BY(&quot;P.FULL_NAME&quot;);
  return SQL();
}
        </pre></div>

      </div>
  </div>
  


        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2009&#x2013;2017
<a href="http://www.mybatis.org/">MyBatis.org</a>.
All rights reserved.</p>
        </div>
        </div>
    </footer>
    </body>
</html>
