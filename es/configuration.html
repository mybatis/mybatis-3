<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from src/site/es/xdoc/configuration.xml at 02 enero 2025
 | Rendered using Apache Maven Fluido Skin 2.0.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <meta name="author" content="Clinton Begin" />
    <meta name="author" content="Eduardo Macarron" />
    <title>MyBatis 3 | Configuración – mybatis</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.1.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="https://blog.mybatis.org/"><img class="class java.lang.Object" src="../../images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 02 enero 2025<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.5.19</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html">Introducción</a></li>
    <li><a href="getting-started.html">Primeros pasos</a></li>
    <li class="active"><a><span class="icon-chevron-down"></span>Configuración</a>
     <ul class="nav nav-list">
      <li><a href="configuration.html#properties">properties</a></li>
      <li><a href="configuration.html#settings">settings</a></li>
      <li><a href="configuration.html#typeAliases">typeAliases</a></li>
      <li><a href="configuration.html#typeHandlers">typeHandlers</a></li>
      <li><a href="configuration.html#objectFactory">objectFactory</a></li>
      <li><a href="configuration.html#plugins">plugins</a></li>
      <li><a href="configuration.html#environments">environments</a></li>
      <li><a href="configuration.html#databaseIdProvider">databaseIdProvider</a></li>
      <li><a href="configuration.html#mappers">mappers</a></li>
     </ul></li>
    <li><a href="sqlmap-xml.html"><span class="icon-chevron-right"></span>Ficheros XML de mapeo</a></li>
    <li><a href="dynamic-sql.html">SQL dinámico</a></li>
    <li><a href="java-api.html"><span class="icon-chevron-right"></span>Java API</a></li>
    <li><a href="statement-builders.html">La clase SQL</a></li>
    <li><a href="logging.html">Logging</a></li>
   <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Información del proyecto</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Informes del proyecto</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">


  
    <section><a id="Configuraci.C3.B3n"></a>
<h1>Configuraci&#xf3;n</h1>
      
<p>El fichero de configuraci&#xf3;n XML contiene par&#xe1;metros y configuraciones que tienen un efecto crucial en c&#xf3;mo se comporta MyBatis. A alto nivel contiene:</p>

      
<ul>
        
<li>
          configuration
          
<ul>
            
<li><a href="#properties">properties</a></li>
            
<li><a href="#settings">settings</a></li>
            
<li><a href="#typeAliases">typeAliases</a></li>
            
<li><a href="#typeHandlers">typeHandlers</a></li>
            
<li><a href="#objectFactory">objectFactory</a></li>
            
<li><a href="#plugins">plugins</a></li>
            
<li><a href="#environments">environments</a>
              
<ul>
                
<li>
                  environment
                  
<ul>
                    
<li>transactionManager</li>
                    
<li>dataSource</li>
                  </ul>
                </li>
              </ul>
            </li>
            
<li><a href="#databaseIdProvider">databaseIdProvider</a></li>
            
<li><a href="#mappers">mappers</a></li>
          </ul>
        </li>
      </ul>
      <section><a id="properties"></a>
<h2>properties</h2>
        
<p>Contiene propiedades externalizables y sustituibles que se pueden configurar en un t&#xed;pico properties de Java o bien puede definirse su contenido directamente mediante subelementos property. Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;
&lt;/properties&gt;</code></pre>
        
<p>Las propiedades pueden usarse a lo largo del fichero de configuraci&#xf3;n para sustituir valores que deben configurarse din&#xe1;micamente. Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
        
<p>El usuario y password de este ejemplo se reemplazar&#xe1;n por los valores de los elementos de tipo property. El driver y la url se reemplazar&#xe1;n por los valores contenidos en el fichero config.properties.  Esto aumenta mucho las posibilidades de configuraci&#xf3;n.
        </p>
        
<p>Las propiedades tambi&#xe9;n pueden pasarse como par&#xe1;metro al m&#xe9;todo SqlSessionFactoryBuilder.build(). Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);

// ... or ...

SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);
</code></pre>
        
<p>Si una propiedad existe en m&#xe1;s de un lugar, MyBatis la carga en este orden:
        </p>
        
<ul>
          
<li>Primero se leen las propiedades especificadas en el elemento XML properties,
          </li>
          
<li>Posteriormente se cargan las propiedades de recursos de tipo classpath o url del elementos properties, si hubiera una propiedad repetida ser&#xed;a sobrescrita,
          </li>
          
<li>Y finalmente se leen las propiedades pasadas como par&#xe1;metro, que en caso de duplicidad sobrescriben las propiedades que se hayan cargado del elemento properties o de recursos/url.
          </li>
        </ul>
        
<p>Por tanto las properties m&#xe1;s prioritarias son las pasadas como par&#xe1;metro, seguidas de los atributos tipo classpath/url y finalmente las propiedades especificadas en el elemento properties..
        </p>

        
<p>
          Since the MyBatis 3.4.2, your can specify a default value into placeholder as follow:
        </p>
        
<pre class="prettyprint"><code>
&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- If 'username' property not present, username become 'ut_user' --&gt;
&lt;/dataSource&gt;</code></pre>

        
<p>
          This feature is disabled by default. If you specify a default value into placeholder,
          you should be enable this feature by adding a special property as follow:
        </p>

        
<pre class="prettyprint"><code>
&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;
&lt;/properties&gt;</code></pre>

        
<p>
          <span class="label important">NOTE</span> Also If you are used already the <code>&quot;:&quot;</code> as property key(e.g. <code>db:username</code>)
          or you are used already the ternary operator of OGNL expression(e.g. <code>${tableName != null ? tableName : 'global_constants'}</code>) on your sql definition,
          you should be change the character that separate key and default value by adding a special property as follow:
        </p>

        
<pre class="prettyprint"><code>
&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;
&lt;/properties&gt;</code></pre>
        
<pre class="prettyprint"><code>
&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;username&quot; value=&quot;${db:username?:ut_user}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>

      </section>
      <section><a id="settings"></a>
<h2>settings</h2>
        
<p>Son muy importantes para definir c&#xf3;mo se comporta MyBatis en ejecuci&#xf3;n. La siguiente tabla describe las configuraciones (settings), sus significados y sus valores por defecto.</p>
        
<table class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Configuraci&#xf3;n</th>
              
<th>Descripci&#xf3;n</th>
              
<th>Valores admitidos</th>
              
<th>Valor por defecto</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td>
                cacheEnabled
              </td>
              
<td>Habilita o inhabilita globalmente todas las cach&#xe9;s definidas en el mapper
              </td>
              
<td>
                true | false
              </td>
              
<td>
                true
              </td>
            </tr>
            
<tr class="a">
              
<td>
                lazyLoadingEnabled
              </td>
              
<td>
                Habilita o inhabilita globalmente la carga diferida (lazy loading). Cuando est&#xe1; activo, todas las relaciones se cargan en modo diferido.
                Este valor se puede sobrescribir en cada relaci&#xf3;n usando el atributo <code>fetchType</code>.
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false
              </td>
            </tr>
            
<tr class="b">
              
<td>
                aggressiveLazyLoading
              </td>
              
<td>
                When enabled, any method call will load all the lazy properties of the object. Otherwise, each property is loaded on demand (see also <code>lazyLoadTriggerMethods</code>).
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false (true in &#x2264;3.4.1)
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <del>multipleResultSetsEnabled</del>
              </td>
              
<td>Deprecated. This option has no effect.</td>
              
<td>
                true | false
              </td>
              
<td>
                true
              </td>
            </tr>
            
<tr class="b">
              
<td>
                useColumnLabel
              </td>
              
<td>Utiliza la etiqueta de columna (label) en lugar del nombre de conlumna. Algunos drivers se comportan distinto en lo que a esto respecta. Consulta la documentaci&#xf3;n del driver o prueba ambos modos para descubrir c&#xf3;mo funciona tu driver
              </td>
              
<td>
                true | false
              </td>
              
<td>
                true
              </td>
            </tr>
            
<tr class="a">
              
<td>
                useGeneratedKeys
              </td>
              
<td>Habilita el uso del soporte JDBC para claves autogeneradas. Se requiere un driver compatible. Este par&#xe1;metro fuerza el uso de las claves autogeneradas si est&#xe1; habilitado. Algunos drivers indican que no son compatibles aunque funcionan correctamente (ej. Derby)
              </td>
              
<td>
                true | false
              </td>
              
<td>
                False
              </td>
            </tr>
            
<tr class="b">
              
<td>
                autoMappingBehavior
              </td>
              
<td>Especifica c&#xf3;mo deben mapearse de forma autom&#xe1;tica las columnas a los campos/propiedades. NONE desactiva el mapeo autom&#xe1;tico. PARTIAL s&#xf3;lo mapea autom&#xe1;ticamente los resultados que no contienen result maps anidados en su interior. FULL mapea resultados de cualquier complejidad (contengan anidados o no).
              </td>
              
<td>
                NONE, PARTIAL, FULL
              </td>
              
<td>
                PARTIAL
              </td>
            </tr>
            
<tr class="a">
              
<td>
                autoMappingUnknownColumnBehavior
              </td>
              
<td>
                Specify the behavior when detects an unknown column (or unknown property type) of automatic mapping target.
                
<ul>
                  
<li><code>NONE</code>: Do nothing</li>
                  
<li><code>WARNING</code>: Output warning log (The log level of <code>'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'</code> must be set to <code>WARN</code>)</li>
                  
<li><code>FAILING</code>: Fail mapping (Throw <code>SqlSessionException</code>)</li>
                </ul>
                Note that there could be false-positives when `autoMappingBehavior` is set to `FULL`.
              </td>
              
<td>
                NONE, WARNING, FAILING
              </td>
              
<td>
                NONE
              </td>
            </tr>
            
<tr class="b">
              
<td>
                defaultExecutorType
              </td>
              
<td>Configura el ejecutor (executor) por defecto. SIMPLE no hace nada especial. REUSE re&#xfa;sa prepared statements. BATCH re&#xfa;sa statements y ejecuta actualizaciones en batch.</td>
              
<td>
                SIMPLE
                REUSE
                BATCH
              </td>
              
<td>
                SIMPLE
              </td>
            </tr>
            
<tr class="a">
              
<td>
                defaultStatementTimeout
              </td>
              
<td>Establece el n&#xfa;mero de segundos que debe esperar el driver la respuesta de la base de datos.
              </td>
              
<td>
                Cualquier entero positivo
              </td>
              
<td>
                Sin valor (null)
              </td>
            </tr>
            
<tr class="b">
              
<td>
                defaultFetchSize
              </td>
              
<td>
                Sets the driver a hint as to control fetching size for return results.
                This parameter value can be override by a query setting.
              </td>
              
<td>
                Cualquier entero positivo
              </td>
              
<td>
                Sin valor (null)
              </td>
            </tr>
            
<tr class="a">
              
<td>
                defaultResultSetType
              </td>
              
<td>
                Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2)
              </td>
              
<td>
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(same behavior with 'Not Set')
              </td>
              
<td>
                Not Set (null)
              </td>
            </tr>
            
<tr class="b">
              
<td>
                safeRowBoundsEnabled
              </td>
              
<td>Habilita el uso de RowBounds en statements anidados.
                If allow, set the false.
              </td>
              
<td>
                true | false
              </td>
              
<td>
                False
              </td>
            </tr>
            
<tr class="a">
              
<td>
                safeResultHandlerEnabled
              </td>
              
<td>
                Habilita el uso de ResultHandler en statements anidados.
                If allow, set the false.
              </td>
              
<td>
                true | false
              </td>
              
<td>
                True
              </td>
            </tr>
            
<tr class="b">
              
<td>
                mapUnderscoreToCamelCase
              </td>
              
<td>Mapea autom&#xe1;ticamente los nombres cl&#xe1;sicos de columnas de base de datos A_COLUMN a nombres cl&#xe1;sicos de propiedades Java aColumn.
              </td>
              
<td>
                true | false
              </td>
              
<td>
                False
              </td>
            </tr>
            
<tr class="a">
              
<td>
                localCacheScope
              </td>
              
<td>
                MyBatis usa una cache local para evitar dependencias circulares y acelerar ejecuciones repeticas de queries anidadas.
                Por defecto (SESSION) todas las queries ejecutadas en una sesi&#xf3;n se cachean. Si localCacheScope=STATEMENT
                la sesi&#xf3;n local solo se usar&#xe1; durante la ejecuci&#xf3;n de un statement, no se comparten datos entre distintas llamadas
                a SqlSession.
              </td>
              
<td>
                SESSION | STATEMENT
              </td>
              
<td>
                SESSION
              </td>
            </tr>
            
<tr class="b">
              
<td>
                jdbcTypeForNull
              </td>
              
<td>
                Permite especificar el tipo JDBC que
                Especifica el tipo JDBC para valores nulos cuando no se ha especificado un tipo concreto para el par&#xe1;metro.
                Algunos drivers requieren que se indique el tipo JDBC de la columna pero otros permite valores gen&#xe9;ricos como NULL, VARCHAR or OTHER.
              </td>
              
<td>
                JdbcType enumeration. Los m&#xe1;s comunes son: NULL, VARCHAR and OTHER
              </td>
              
<td>
                OTHER
              </td>
            </tr>
            
<tr class="a">
              
<td>
                lazyLoadTriggerMethods
              </td>
              
<td>
                Permite especificar qu&#xe9; m&#xe9;todos de Object disparan la carga diferida
              </td>
              
<td>
                Lista de m&#xe9;todos separados por comas
              </td>
              
<td>
                equals,clone,hashCode,toString
              </td>
            </tr>
            
<tr class="b">
              
<td>
                defaultScriptingLanguage
              </td>
              
<td>
                Permite especificar que lenguaje se usar&#xe1; en el SQL din&#xe1;mico.
              </td>
              
<td>
                Un type alias o una nombre de clase completamente cualificado
              </td>
              
<td>
                org.apache.ibatis.scripting.xmltags.XMLLanguageDriver
              </td>
            </tr>
            
<tr class="a">
              
<td>
                defaultEnumTypeHandler
              </td>
              
<td>
                Specifies the <code>TypeHandler</code> used by default for Enum. (Since: 3.4.5)
              </td>
              
<td>
                A type alias or fully qualified class name.
              </td>
              
<td>
                org.apache.ibatis.type.EnumTypeHandler
              </td>
            </tr>
            
<tr class="b">
              
<td>
                callSettersOnNulls
              </td>
              
<td>
                Permite especificar si se invocar&#xe1;n a los setters y a los m&#xe9;todos put de los mapas si el valor obtenido es null.
                Te en cuenta que si se activa las propiedades que puedan ser informadas con nulos no pueden ser de tipos primitivos.
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false
              </td>
            </tr>
            
<tr class="a">
              
<td>
                returnInstanceForEmptyRow
              </td>
              
<td>
                MyBatis, by default, returns <code>null</code> when all the columns of a returned row are NULL.
                When this setting is enabled, MyBatis returns an empty instance instead.
                Note that it is also applied to nested results (i.e. collection and association). Since: 3.4.2
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false
              </td>
            </tr>
            
<tr class="b">
              
<td>
                logPrefix
              </td>
              
<td>
                Permite especificar el prefijo que MyBatis a&#xf1;adir&#xe1; a los nombres de logger.
              </td>
              
<td>
                Cualquier cadena
              </td>
              
<td>
                No informado
              </td>
            </tr>
            
<tr class="a">
              
<td>
                logImpl
              </td>
              
<td>
                Permite especificar qu&#xe9; implementaci&#xf3;n de logging utilizar. Si no est&#xe1; informado la impelmentaci&#xf3;n se descubrir&#xe1; automaticamente.
              </td>
              
<td>
                SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
              </td>
              
<td>
                No informado
              </td>
            </tr>
            
<tr class="b">
              
<td>
                proxyFactory
              </td>
              
<td>
                Permite especificar qu&#xe9; herramienta de generaci&#xf3;n de proxys se usar&#xe1; para crear los objetos con capacidad de carga lazy.
              </td>
              
<td>
                CGLIB (deprecated since 3.5.10) | JAVASSIST
              </td>
              
<td>
                JAVASSIST (MyBatis 3.3 or above)
              </td>
            </tr>
            
<tr class="a">
              
<td>
                vfsImpl
              </td>
              
<td>
                Specifies VFS implementations
              </td>
              
<td>
                Fully qualified class names of custom VFS implementation separated by commas.
              </td>
              
<td>
                Not set
              </td>
            </tr>
            
<tr class="b">
              
<td>
                useActualParamName
              </td>
              
<td>
                Allow referencing statement parameters by their actual names declared in the method signature.
                To use this feature, your project must be compiled in Java 8 with <code>-parameters</code> option. (Since: 3.4.1)
              </td>
              
<td>
                true | false
              </td>
              
<td>
                true
              </td>
            </tr>
            
<tr class="a">
              
<td>
                configurationFactory
              </td>
              
<td>
                Specifies the class that provides an instance of <code>Configuration</code>.
                The returned Configuration instance is used to load lazy properties of deserialized objects.
                This class must have a method with a signature <code>static Configuration getConfiguration()</code>. (Since: 3.2.3)
              </td>
              
<td>
                A type alias or fully qualified class name.
              </td>
              
<td>
                Not set
              </td>
            </tr>
            
<tr class="b">
              
<td>
                shrinkWhitespacesInSql
              </td>
              
<td>
                Removes extra whitespace characters from the SQL. Note that this also affects literal strings in SQL. (Since 3.5.5)
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false
              </td>
            </tr>
            
<tr class="a">
              
<td>
                defaultSqlProviderType
              </td>
              
<td>
                Specifies an sql provider class that holds provider method (Since 3.5.6).
                This class apply to the <code>type</code>(or <code>value</code>) attribute on sql provider annotation(e.g. <code>@SelectProvider</code>),
                when these attribute was omitted.
              </td>
              
<td>
                A type alias or fully qualified class name
              </td>
              
<td>
                Not set
              </td>
            </tr>
            
<tr class="b">
              
<td>
                nullableOnForEach
              </td>
              
<td>
                Specifies the default value of 'nullable' attribute on 'foreach' tag. (Since 3.5.9)
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false
              </td>
            </tr>
            
<tr class="a">
              
<td>
                argNameBasedConstructorAutoMapping
              </td>
              
<td>
                When applying constructor auto-mapping, argument name is used to search the column to map instead of relying on the column order. (Since 3.5.10)
              </td>
              
<td>
                true | false
              </td>
              
<td>
                false
              </td>
            </tr>
          </tbody>
        </table>
        
<p>
A continuaci&#xf3;n se muestra un ejemplo del elemento settings al completo:
        </p>
        
<pre class="prettyprint"><code>&lt;settings&gt;
  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;safeResultHandlerEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
  &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
  &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;
  &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;org.apache.ibatis.scripting.xmltags.XMLLanguageDriver&quot;/&gt;
  &lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;
  &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;returnInstanceForEmptyRow&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;logPrefix&quot; value=&quot;exampleLogPreFix_&quot;/&gt;
  &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING&quot;/&gt;
  &lt;setting name=&quot;proxyFactory&quot; value=&quot;CGLIB | JAVASSIST&quot;/&gt;
  &lt;setting name=&quot;vfsImpl&quot; value=&quot;org.mybatis.example.YourselfVfsImpl&quot;/&gt;
  &lt;setting name=&quot;useActualParamName&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;configurationFactory&quot; value=&quot;org.mybatis.example.ConfigurationFactory&quot;/&gt;
&lt;/settings&gt;</code></pre>

      </section>
      <section><a id="typeAliases"></a>
<h2>typeAliases</h2>
        
<p>Un type alias es simplemente un alias (un nombre m&#xe1;s corto) para un tipo Java. Solo es importante para la configuraci&#xf3;n XML y existe para reducir la cantidad de texto al teclear nombres de clase cualificados (fully qualified). Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>&lt;typeAliases&gt;
  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;
  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;
  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;
  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;
  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;
  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
        
<p>
        Con esta configuraci&#xf3;n, puede usarse <code>Blog</code> en lugar de <code>domain.blog.Blog</code>
        </p>
        
<p>
        Tambien puedes indicar un paquete para que MyBatis busque beans de tipo alias. Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>&lt;typeAliases&gt;
  &lt;package name=&quot;domain.blog&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
        
<p>
        Cada bean encontrado en <code>domain.blog</code>, en caso de que no contenga ninguna anotaci&#xf3;n,
        se registrar&#xe1; como alias usando su nombre no cualificado en min&#xfa;sculas. Es decir, <code>domain.blog.Author</code>
        se registrar&#xe1; como will be registered as <code>author</code>.
        Si se encuentra la anotaci&#xf3;n <code>@Alias</code> se usar&#xe1; su valor como alias. Mira el ejemplo a continuaci&#xf3;n:
        </p>
        
<pre class="prettyprint"><code>@Alias(&quot;author&quot;)
public class Author {
    ...
}
</code></pre>
        
<p>Hay muchos type aliases pre construidos. No son sensibles a may&#xfa;sculas/min&#xfa;sculas. Observa los nombres especiales de los tipos primitivos dadas las colisiones de nombres.
        </p>
        
<table class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>
                Alias
              </th>
              
<th>
                Tipo mapeado
              </th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td>
                _byte
              </td>
              
<td>
                byte
              </td>
            </tr>
            
<tr class="a">
              
<td>
                _char (since 3.5.10)
              </td>
              
<td>
                char
              </td>
            </tr>
            
<tr class="b">
              
<td>
                _character (since 3.5.10)
              </td>
              
<td>
                char
              </td>
            </tr>
            
<tr class="a">
              
<td>
                _long
              </td>
              
<td>
                long
              </td>
            </tr>
            
<tr class="b">
              
<td>
                _short
              </td>
              
<td>
                short
              </td>
            </tr>
            
<tr class="a">
              
<td>
                _int
              </td>
              
<td>
                int
              </td>
            </tr>
            
<tr class="b">
              
<td>
                _integer
              </td>
              
<td>
                int
              </td>
            </tr>
            
<tr class="a">
              
<td>
                _double
              </td>
              
<td>
                double
              </td>
            </tr>
            
<tr class="b">
              
<td>
                _float
              </td>
              
<td>
                float
              </td>
            </tr>
            
<tr class="a">
              
<td>
                _boolean
              </td>
              
<td>
                boolean
              </td>
            </tr>
            
<tr class="b">
              
<td>
                string
              </td>
              
<td>
                String
              </td>
            </tr>
            
<tr class="a">
              
<td>
                byte
              </td>
              
<td>
                Byte
              </td>
            </tr>
            
<tr class="b">
              
<td>
                char (since 3.5.10)
              </td>
              
<td>
                Character
              </td>
            </tr>
            
<tr class="a">
              
<td>
                character (since 3.5.10)
              </td>
              
<td>
                Character
              </td>
            </tr>
            
<tr class="b">
              
<td>
                long
              </td>
              
<td>
                Long
              </td>
            </tr>
            
<tr class="a">
              
<td>
                short
              </td>
              
<td>
                Short
              </td>
            </tr>
            
<tr class="b">
              
<td>
                int
              </td>
              
<td>
                Integer
              </td>
            </tr>
            
<tr class="a">
              
<td>
                integer
              </td>
              
<td>
                Integer
              </td>
            </tr>
            
<tr class="b">
              
<td>
                double
              </td>
              
<td>
                Double
              </td>
            </tr>
            
<tr class="a">
              
<td>
                float
              </td>
              
<td>
                Float
              </td>
            </tr>
            
<tr class="b">
              
<td>
                boolean
              </td>
              
<td>
                Boolean
              </td>
            </tr>
            
<tr class="a">
              
<td>
                date
              </td>
              
<td>
                Date
              </td>
            </tr>
            
<tr class="b">
              
<td>
                decimal
              </td>
              
<td>
                BigDecimal
              </td>
            </tr>
            
<tr class="a">
              
<td>
                bigdecimal
              </td>
              
<td>
                BigDecimal
              </td>
            </tr>
            
<tr class="b">
              
<td>
                biginteger
              </td>
              
<td>
                BigInteger
              </td>
            </tr>
            
<tr class="a">
              
<td>
                object
              </td>
              
<td>
                Object
              </td>
            </tr>
            
<tr class="b">
              
<td>
                date[]
              </td>
              
<td>
                Date[]
              </td>
            </tr>
            
<tr class="a">
              
<td>
                decimal[]
              </td>
              
<td>
                BigDecimal[]
              </td>
            </tr>
            
<tr class="b">
              
<td>
                bigdecimal[]
              </td>
              
<td>
                BigDecimal[]
              </td>
            </tr>
            
<tr class="a">
              
<td>
                biginteger[]
              </td>
              
<td>
                BigInteger[]
              </td>
            </tr>
            
<tr class="b">
              
<td>
                object[]
              </td>
              
<td>
                Object[]
              </td>
            </tr>
            
<tr class="a">
              
<td>
                map
              </td>
              
<td>
                Map
              </td>
            </tr>
            
<tr class="b">
              
<td>
                hashmap
              </td>
              
<td>
                HashMap
              </td>
            </tr>
            
<tr class="a">
              
<td>
                list
              </td>
              
<td>
                List
              </td>
            </tr>
            
<tr class="b">
              
<td>
                arraylist
              </td>
              
<td>
                ArrayList
              </td>
            </tr>
            
<tr class="a">
              
<td>
                collection
              </td>
              
<td>
                Collection
              </td>
            </tr>
            
<tr class="b">
              
<td>
                iterator
              </td>
              
<td>
                Iterator
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section><a id="typeHandlers"></a>
<h2>typeHandlers</h2>
        
<p>Cuando MyBatis establece el valor de un par&#xe1;metro de un PreparedStatement u obtiene un valor de un ResultSet, se utiliza un TypeHandler para convertir el valor al tipo Java apropiado. La siguiente tabla recoge los TypeHandlers predefinidos.
        </p>
        
<p>
          <span class="label important">NOTE</span>
          Since version 3.4.5, The MyBatis has been supported JSR-310(Date and Time API) by default.
        </p>
        
<table class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>
                Type Handler
              </th>
              
<th>
                Tipos Java
              </th>
              
<th>
                Tipos JDBC
              </th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td>
                <code>BooleanTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Boolean</code>, <code>boolean</code>
              </td>
              
<td>
                Cualquiera compatible con <code>BOOLEAN</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>ByteTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Byte</code>, <code>byte</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>BYTE</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>ShortTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Short</code>, <code>short</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>SMALLINT</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>IntegerTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Integer</code>, <code>int</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>INTEGER</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>LongTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Long</code>, <code>long</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>BIGINT</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>FloatTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Float</code>, <code>float</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>FLOAT</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>DoubleTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.Double</code>, <code>double</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>DOUBLE</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>BigDecimalTypeHandler</code>
              </td>
              
<td>
                <code>java.math.BigDecimal</code>
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>DECIMAL</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>StringTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.String</code>
              </td>
              
<td>
                <code>CHAR</code>, <code>VARCHAR</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>ClobReaderTypeHandler</code>
              </td>
              
<td>
                <code>java.io.Reader</code>
              </td>
              
<td>
                -
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>ClobTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.String</code>
              </td>
              
<td>
                <code>CLOB</code>, <code>LONGVARCHAR</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>NStringTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.String</code>
              </td>
              
<td>
                <code>NVARCHAR</code>, <code>NCHAR</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>NClobTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.String</code>
              </td>
              
<td>
                <code>NCLOB</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>BlobInputStreamTypeHandler</code>
              </td>
              
<td>
                <code>java.io.InputStream</code>
              </td>
              
<td>
                -
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>ByteArrayTypeHandler</code>
              </td>
              
<td>
                <code>byte[]</code>
              </td>
              
<td>
                Cualquiera compatible con byte stream
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>BlobTypeHandler</code>
              </td>
              
<td>
                <code>byte[]</code>
              </td>
              
<td>
                <code>BLOB</code>, <code>LONGVARBINARY</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>DateTypeHandler</code>
              </td>
              
<td>
                <code>java.util.Date</code>
              </td>
              
<td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>DateOnlyTypeHandler</code>
              </td>
              
<td>
                <code>java.util.Date</code>
              </td>
              
<td>
                <code>DATE</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>TimeOnlyTypeHandler</code>
              </td>
              
<td>
                <code>java.util.Date</code>
              </td>
              
<td>
                <code>TIME</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>SqlTimestampTypeHandler</code>
              </td>
              
<td>
                <code>java.sql.Timestamp</code>
              </td>
              
<td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>SqlDateTypeHandler</code>
              </td>
              
<td>
                <code>java.sql.Date</code>
              </td>
              
<td>
                <code>DATE</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>SqlTimeTypeHandler</code>
              </td>
              
<td>
                <code>java.sql.Time</code>
              </td>
              
<td>
                <code>TIME</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>ObjectTypeHandler</code>
              </td>
              
<td>
                Any
              </td>
              
<td>
                <code>OTHER</code>, or unspecified
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>EnumTypeHandler</code>
              </td>
              
<td>
                Enumeration Type
              </td>
              
<td>
                <code>VARCHAR</code> Cualquiera compatible con string porque se guarda el c&#xf3;digo (no el &#xed;ndice).
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>EnumOrdinalTypeHandler</code>
              </td>
              
<td>
                Enumeration Type
              </td>
              
<td>
                Cualquiera compatible con <code>NUMERIC</code> o <code>DOUBLE</code> por que se guarda la posici&#xf3;n (no el c&#xf3;digo).
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>SqlxmlTypeHandler</code>
              </td>
              
<td>
                <code>java.lang.String</code>
              </td>
              
<td>
                <code>SQLXML</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>InstantTypeHandler</code>
              </td>
              
<td>
                <code>java.time.Instant</code>
              </td>
              
<td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>LocalDateTimeTypeHandler</code>
              </td>
              
<td>
                <code>java.time.LocalDateTime</code>
              </td>
              
<td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>LocalDateTypeHandler</code>
              </td>
              
<td>
                <code>java.time.LocalDate</code>
              </td>
              
<td>
                <code>DATE</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>LocalTimeTypeHandler</code>
              </td>
              
<td>
                <code>java.time.LocalTime</code>
              </td>
              
<td>
                <code>TIME</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>OffsetDateTimeTypeHandler</code>
              </td>
              
<td>
                <code>java.time.OffsetDateTime</code>
              </td>
              
<td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>OffsetTimeTypeHandler</code>
              </td>
              
<td>
                <code>java.time.OffsetTime</code>
              </td>
              
<td>
                <code>TIME</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>ZonedDateTimeTypeHandler</code>
              </td>
              
<td>
                <code>java.time.ZonedDateTime</code>
              </td>
              
<td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>YearTypeHandler</code>
              </td>
              
<td>
                <code>java.time.Year</code>
              </td>
              
<td>
                <code>INTEGER</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>MonthTypeHandler</code>
              </td>
              
<td>
                <code>java.time.Month</code>
              </td>
              
<td>
                <code>INTEGER</code>
              </td>
            </tr>
            
<tr class="a">
              
<td>
                <code>YearMonthTypeHandler</code>
              </td>
              
<td>
                <code>java.time.YearMonth</code>
              </td>
              
<td>
                <code>VARCHAR</code> or <code>LONGVARCHAR</code>
              </td>
            </tr>
            
<tr class="b">
              
<td>
                <code>JapaneseDateTypeHandler</code>
              </td>
              
<td>
                <code>java.time.chrono.JapaneseDate</code>
              </td>
              
<td>
                <code>DATE</code>
              </td>
            </tr>
          </tbody>
        </table>
        
<p>
        Es posible sobrescribir los TypeHanders o crear TypeHanders personalizados para tratar tipos no soportados o no est&#xe1;ndares.
        Para ello, debes implementar la interfaz <code>org.apache.ibatis.type.TypeHandler</code> o extender
        la clase de ayuda <code>org.apache.ibatis.type.BaseTypeHandler</code> y opcionalmente mapear el TypeHandler a un tipo JDBC.
        Por ejemplo:
        </p>

        
<pre class="prettyprint"><code>// ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
</code></pre>

        
<pre class="prettyprint"><code>&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>

        
<p>Al usar este TypeHandler se sobrescribe el TypeHandler existente para los tipos String y los par&#xe1;metros y resultados VARCHAR. Observa que MyBatis no introspecciona la base de datos para conocer el tipo as&#xed; que debes especificar que se trata de un VARCHAR en los mapeos de par&#xe1;metros y resultados para que se use el TypeHandler adecuado. Esto se debe a que MyBatis no conoce nada sobre los tipos de datos hasta que la sentencia ha sido ejecutada.</p>
        
<p>
          MyBatis conoce el tipo Java que quieres gestionar introspecionando tipo gen&#xe9;rico del TypeHandler, pero puedes modificar este comportamiento de dos maneras.
        </p>
        
<ul>
          
<li>A&#xf1;adir un atributo <code>javaType</code> al elemento typeHandler (por ejemplo: <code>javaType=&quot;String&quot;</code>)
          </li>
          
<li>A&#xf1;adir una anotaci&#xf3;n <code>@MappedTypes</code> a tu clase TypeHandler especificando la lista de tipos java a la que asociarlo.
          Esta anotaci&#xf3;n ser&#xe1; ignorada si se ha especificado tambi&#xe9;n un atributo <code>javaType</code>.
          </li>
        </ul>


        
<p>El tipo JDBC asociado se puede especificar de dos maneras:</p>
        
<ul>
          
<li>
           A&#xf1;adiendo un atributo <code>jdbcType</code> al lemento typeHandler (por ejemplo: <code>jdbcType=&quot;VARCHAR&quot;</code>).
          </li>
          
<li>A&#xf1;adiendo una anotaci&#xf3;n <code>@MappedJdbcTypes</code> a tu clase TypeHandler especificando la lista de tipos JDBC a la que asociarlo.
          Esta anotaci&#xf3;n ser&#xe1; ignorada si se ha especificado tambi&#xe9;n un atributo <code>jdbcType</code>.
          </li>
        </ul>

        
<p>
          When deciding which TypeHandler to use in a <code>ResultMap</code>, the Java type is known
          (from the result type), but the JDBC type is unknown. MyBatis therefore uses the combination
          <code>javaType=[TheJavaType], jdbcType=null</code> to choose a TypeHandler. This means that
          using a <code>@MappedJdbcTypes</code> annotation <i>restricts</i> the scope of a TypeHandler
          and makes it unavailable for use in <code>ResultMap</code>s unless explicity set. To make a
          TypeHandler available for use in a <code>ResultMap</code>, set <code>includeNullJdbcType=true</code>
          on the <code>@MappedJdbcTypes</code> annotation. Since Mybatis 3.4.0 however, if a <b>single</b>
          TypeHandler is registered to handle a Java type, it will be used by default in <code>ResultMap</code>s
          using this Java type (i.e. even without <code>includeNullJdbcType=true</code>).
        </p>

        
<p>Y finalmente puedes hacer que MyBatis busque tus TypeHandlers:</p>
        
<pre class="prettyprint"><code>&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;package name=&quot;org.mybatis.example&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>

        
<p>
          Observa que cuando usas la funci&#xf3;n de b&#xfa;squeda los tipos JDBC s&#xf3;lo se pueden especificar usando anotaciones.
        </p>

        
<p>
          Puedes crear un TypeHandler gen&#xe9;rico que sea capaz de manejar m&#xe1;s de un tipo de clase. Para ello a&#xf1;ade
          un constructor que recibe una clase como par&#xe1;metro y MyBatis le pasar&#xe1; la clase actual cuando construya
          el TypeHandler.
        </p>

        
<pre class="prettyprint"><code>//GenericTypeHandler.java
public class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; {

  private Class&lt;E&gt; type;

  public GenericTypeHandler(Class&lt;E&gt; type) {
    if (type == null) throw new IllegalArgumentException(&quot;Type argument cannot be null&quot;);
    this.type = type;
  }
  ...
</code></pre>

        
<p><code>EnumTypeHandler</code> y <code>EnumOrdinalTypeHandler</code> son TypeHandlers gen&#xe9;ricos.
        Conoceremos m&#xe1;s sobre ellos en la pr&#xf3;xima secci&#xf3;n.
        </p>

      </section>

      <section><a id="Handling_Enums"></a>
<h2>Handling Enums</h2>
        
<p>
        Si quires mapear un <code>Enum</code>, debes usar bien un
        <code>EnumTypeHandler</code> o un <code>EnumOrdinalTypeHandler</code>.
        </p>

        
<p>Por ejemplo, digamos que quieres guardar el modo de reondeo que debe
        usarse con un n&#xfa;mero determinado que debe redondearse. Por defecto MyBatis
        usa un <code>EnumTypeHandler</code> para comvertir los valores del  <code>Enum</code>
        a sus nombres.
        </p>

        <b>Observa que el <code>EnumTypeHandler</code> es un handler especial en el sentido de que
        no maneja una clase espec&#xed;fica, como los dem&#xe1;s handlers sino cualquier clase que extiende
        de <code>Enum</code></b>

        
<p>
        Sin embargo, puede que no queramos guardar nombres. Nuestro DBA puede insistir en que
        usemos un entero en su lugar. Muy sencillo: a&#xf1;ade un <code>EnumOrdinalTypeHandler</code>
        a las secci&#xf3;n de <code>typeHandlers</code> de tu fichero de configuraci&#xf3;n y ahora todos los
        <code>RoundingMode</code> se mapear&#xe1;n a un entero usando su valor ordinal.
        </p>
       
<pre class="prettyprint"><code>&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;java.math.RoundingMode&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>
    
<p>
      Pero &#xbf;y si quieres mapear el mismo <code>Enum</code> a un string en un sitio pero a un entero en otro?
    </p>
        
<p>
          El mapeo autom&#xe1;tico siempre usar&#xe1; <code>EnumOrdinalTypeHandler</code>,
          as&#xed; que si queremos usar el cl&#xe1;sico <code>EnumTypeHandler</code>,
          debemos indicarlo establiencidolo espl&#xed;citamente su uso en los statements.
        </p>
        
<p>
          Los mappers no se tratar&#xe1;n hasta la secci&#xf3;n siguiente asi que si esta es tu primera lectura de
          la documentaci&#xf3;n quiz&#xe1; prefieras saltarte esta secci&#xf3;n por ahora y volver m&#xe1;s tarde).
        </p>
        
<pre class="prettyprint"><code>&lt;!DOCTYPE mapper
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
    &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;org.apache.ibatis.submitted.rounding.Mapper&quot;&gt;
  &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt;
    &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot;/&gt;
  &lt;/resultMap&gt;

  &lt;select id=&quot;getUser&quot; resultMap=&quot;usermap&quot;&gt;
    select * from users
  &lt;/select&gt;
  &lt;insert id=&quot;insert&quot;&gt;
      insert into users (id, name, funkyNumber, roundingMode) values (
        #{id}, #{name}, #{funkyNumber}, #{roundingMode}
      )
  &lt;/insert&gt;

  &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap2&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt;
    &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;
  &lt;/resultMap&gt;
  &lt;select id=&quot;getUser2&quot; resultMap=&quot;usermap2&quot;&gt;
    select * from users2
  &lt;/select&gt;
  &lt;insert id=&quot;insert2&quot;&gt;
      insert into users2 (id, name, funkyNumber, roundingMode) values (
        #{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler}
      )
  &lt;/insert&gt;

&lt;/mapper&gt;
</code></pre>
    
<p>
      Observa que esto nos fuerza a usar un <code>resultMap</code>
      en lugar de un <code>resultType</code> en nuestros statements tipo select.
    </p>
      </section>

      <section><a id="objectFactory"></a>
<h2>objectFactory</h2>
        
<p>Cada vez que MyBatis crea una nueva instancia de un objeto de resultado usa una instancia de ObjectFactory para hacerlo. El ObjectFactory por defecto no hace mucho m&#xe1;s que instanciar la clase destino usando su constructor por defecto, o el constructor que se ha parametrizado en su caso. Es posible sobrescribir el comportamiento por defecto creando tu propio ObjectFactory. Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  @Override
  public &lt;T&gt; T create(Class&lt;T&gt; type) {
    return super.create(type);
  }

  @Override
  public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }

  @Override
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }

  @Override
  public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) {
    return Collection.class.isAssignableFrom(type);
  }
}</code></pre>

        
<pre class="prettyprint"><code>&lt;!-- mybatis-config.xml --&gt;
&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
  &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;</code></pre>
        
<p>La interfaz ObjectFactory es muy sencilla. Contiene solo dos m&#xe9;todos de creaci&#xf3;n, uno para el constructor por defecto y otro para el constructor parametrizado. Adicionalmente el m&#xe9;todo setProperties sirve para configurar el ObjectFactory. Las propiedades definidas en el cuerpo del elemento objectFactory se pasan al m&#xe9;todo setProperties despu&#xe9;s de que el ObjectFactory haya sido inicializado.
        </p>

      </section>
      <section><a id="plugins"></a>
<h2>plugins</h2>
        
<p>MyBatis permite interceptar las llamadas en ciertos puntos de la ejecuci&#xf3;n de un mapped statement. Por defecto, MyBatis permite incluir plugins que intercepten las llamadas de:
        </p>
        
<ul>
          
<li>
            Executor
            (update, query, flushStatements, commit, rollback,
            getTransaction, close,
            isClosed)
          </li>
          
<li>
            ParameterHandler
            (getParameterObject, setParameters)
          </li>
          
<li>
            ResultSetHandler
            (handleResultSets, handleOutputParameters)
          </li>
          
<li>
            StatementHandler
            (prepare, parameterize, batch, update, query)
          </li>
        </ul>
        
<p>Los detalles de estos m&#xe9;todos se pueden conocer observando sus firmas y el c&#xf3;digo fuente de los mismos que est&#xe1; disponible en el sitio de MyBatis. Es recomendable que comprendas el funcionamiento del m&#xe9;todo que estas sobrescribiendo siempre que vayas a hacer algo m&#xe1;s complejo que monitorizar llamadas. Ten en cuenta que si modificas el comportamiento de alguno de estos m&#xe9;todos existe la posibilidad de que rompas el funcionamiento de MyBatis. Estas clases son de bajo nivel y por tanto debes usar los plugins con cuidado.
        </p>
        
<p>Utilizar un plugin es muy sencillo para la potencia que ofrecen. Simplemente implementa el interfaz Interceptor y aseg&#xfa;rate de especificar las signaturas que quieres interceptar.
        </p>

        
<pre class="prettyprint"><code>// ExamplePlugin.java
@Intercepts({@Signature(
  type= Executor.class,
  method = &quot;update&quot;,
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  private Properties properties = new Properties();

  @Override
  public Object intercept(Invocation invocation) throws Throwable {
    // implement pre processing if need
    Object returnObject = invocation.proceed();
    // implement post processing if need
    return returnObject;
  }

  @Override
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
}</code></pre>

        
<pre class="prettyprint"><code>&lt;!-- mybatis-config.xml --&gt;
&lt;plugins&gt;
  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;</code></pre>
        
<p>El plugin anterior interceptar&#xe1; cualquier llamada al m&#xe9;todo &#x201c;update&#x201d; en la instancia de Executor, que es un objeto interno que se encarga de la ejecuci&#xf3;n a bajo nivel de los mapped statements.
        </p>
        
<p><span class="label important">NOTA</span>
          <strong>Acerca de sobrescribir la clase Configuration
          </strong>
        </p>
        
<p>Adem&#xe1;s de modificar el comportamiento de MyBatis mediante los plugins, tambi&#xe9;n es posible sobrescribir la clase Configuraci&#xf3;n por completo. Extiende la clase, sobrescribe sus m&#xe9;todos y p&#xe1;sala como par&#xe1;metro en la llamada al m&#xe9;todo SqlSessionFactoryBuilder.build(myConfig). Nuevamente, ten cuenta que esto puede afectar seriamente al funcionamiento de MyBatis as&#xed; que &#xfa;salo con cuidado.
        </p>
      </section>
      <section><a id="environments"></a>
<h2>environments</h2>
        
<p>En MyBatis pueden configurarse varios entornos. De esta forma puedes usar tus SQL Maps en distintas bases de datos por muchos motivos. Por ejemplo puede que tengas una configuraci&#xf3;n distinta para tus entornos de desarrollo, pruebas y producci&#xf3;n. O quiz&#xe1; tengas varias bases de datos en producci&#xf3;n que comparten el esquema y quieres usar los mismos SQL maps sobre todas ellas. Como ves, hay muchos casos.
        </p>
        
<p>
          <strong>Debes recordar un asunto importante. Cuando configures varios entornos, solo ser&#xe1; posible usar UNO por cada instancia de SqlSessionFactory.</strong>
        </p>
        
<p>Por lo tanto, si quieres conectar a dos bases de datos, deber&#xe1;s crear dos instancias de SqlSessionFactory, una para cada cual. Para el caso de tres bases de datos necesitar&#xe1;s tres instancias y as&#xed; sucesivamente. Es f&#xe1;cil de recordar:
        </p>
        
<ul>
          
<li>
            <strong>Una instancia de SqlSessionFactory por base de datos</strong>
          </li>
        </ul>
        
<p>Para indicar qu&#xe9; entorno debe utilizarse, debes informar el par&#xe1;metro opcional correspondiente en la llamada al SqlSessionFactoryBuilder. Existen dos m&#xe9;todos que aceptan el entorno:</p>

        
<pre class="prettyprint"><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment,properties);</code></pre>

        
<p>Si se omite el entorno se usar&#xe1; el entorno por defecto:</p>

        
<pre class="prettyprint"><code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader,properties);</code></pre>

        
<p>El elemento environments contiene la configuraci&#xf3;n del entorno:</p>

        
<pre class="prettyprint"><code>&lt;environments default=&quot;development&quot;&gt;
  &lt;environment id=&quot;development&quot;&gt;
    &lt;transactionManager type=&quot;JDBC&quot;&gt;
      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
    &lt;/transactionManager&gt;
    &lt;dataSource type=&quot;POOLED&quot;&gt;
      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
    &lt;/dataSource&gt;
  &lt;/environment&gt;
&lt;/environments&gt;</code></pre>
        
<p>
          Observa que las secciones importantes son:
        </p>
        
<ul>
          
<li>El ID del entorno por defecto (ej. default=&#x201d;development&#x201d;).</li>
          
<li>El ID de de cada entorno definido (ej. id=&#x201d;development&#x201d;).</li>
          
<li>La configuraci&#xf3;n del TransactionManager (ej. type=&#x201d;JDBC&#x201d;)</li>
          
<li>La configuraci&#xf3;n del DataSource (ej. type=&#x201d;POOLED&#x201d;)</li>
        </ul>
        
<p>El ID del entorno por defecto y de los entornos existentes son auto-explicativos. Puedes nombrarlos como m&#xe1;s te guste, tan s&#xf3;lo aseg&#xfa;rate de que el valor por defecto coincide con un entorno existente.
        </p>
        
<p>
          <strong>transactionManager</strong>
        </p>
        
<p>MyBatis incluye dos tipos de TransactionManager (ej. type=&#x201d;[JDBC|MANAGED]&#x201d;):
        </p>
        
<ul>
          
<li>JDBC &#x2013; Este TransactionManager simplemente hace uso del las capacidades de commit y rollback de JDBC.  Utiliza la conexi&#xf3;n obtenida del DataSource para gestionar la transacci&#xf3;n. By default, it enables auto-commit when closing the connection for compatibility with some drivers. However, for some drivers, enabling auto-commit is not only unnecessary, but also is an expensive operation. So, since version 3.5.10, you can skip this step by setting the &quot;skipSetAutoCommitOnClose&quot; property to true. For example:
            
<pre class="prettyprint"><code>&lt;transactionManager type=&quot;JDBC&quot;&gt;
  &lt;property name=&quot;skipSetAutoCommitOnClose&quot; value=&quot;true&quot;/&gt;
&lt;/transactionManager&gt;</code></pre>
          </li>
          
<li>MANAGED  &#x2013; Este TransactionManager no hace nada. No hace commit ni rollback sobre la conexi&#xf3;n. En su lugar, permite que el contenedor gestione el ciclo de vida completo de la transacci&#xf3;n (ej. Spring o un servidor de aplicaciones JEE).  Por defecto cierra la conexi&#xf3;n. Sin embargo, algunos contenedores no esperan que la conexi&#xf3;n se cierre y por tanto, si necesitas cambiar este comportamiento, informa la propiedad closeConnection a false. Por ejemplo:

<pre class="prettyprint"><code>&lt;transactionManager type=&quot;MANAGED&quot;&gt;
  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;
&lt;/transactionManager&gt;</code></pre>
          </li>
        </ul>
        
<p>
          <span class="label important">NOTA</span>
          Si est&#xe1;s pensando en usar MyBatis con Spring no necesitas configurar ning&#xfa;n TransactionManager
          porque el m&#xf3;dulo de Spring configurar&#xe1; el suyo propio sobrescribiendo cualquier otra configuraci&#xf3;n previa.
        </p>
        
<p>Ninguno de estos TransactionManagers necesita ninguna propiedad. Sin embargo ambos son Type Aliases, es decir, en lugar de usarlos puedes informar el nombre totalmente cualificado o el Type Alias de tu propia implementaci&#xf3;n del interfaz TransactionFactory:
        </p>
        
<pre class="prettyprint"><code>public interface TransactionFactory {
  default void setProperties(Properties props) { // Since 3.5.2, change to default method
    // NOP
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}</code></pre>
        
<p>Todas las propiedades que configures en el XML se pasar&#xe1;n al m&#xe9;todo setProperties() tras la instanciaci&#xf3;n de la clase. Tu implementaci&#xf3;n debe crear una implementaci&#xf3;n de Transaction, que a su vez es tambi&#xe9;n un interfaz muy sencillo:
        </p>
        
<pre class="prettyprint"><code>public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}</code></pre>
        
<p>Con estos dos interfaces puedes personalizar por completo la forma en la que MyBatis gestiona las transacciones.</p>
        
<p>
          <strong>dataSource</strong>
        </p>
        
<p>El elemento dataSource sirve para configurar la forma de obtener conexiones JDBC mediante la interfaz DataSource JDBC est&#xe1;ndar.</p>
        
<ul>
          
<li>La mayor&#xed;a de las aplicaciones que usen MyBatis configurar&#xe1;n el dataSource como se muestra en el ejemplo. Sin embargo, esta configuraci&#xf3;n no es obligatoria. Ten en cuenta, aun as&#xed;, que el dataSource es necesario para utilizar Lazy Loading.
          </li>
        </ul>
        
<p>Hay tres tipos de dataSources pre-construidos (ej. type=&#x201d;????&#x201d;):</p>
        
<p>
          <strong>UNPOOLED</strong> &#x2013; Esta implementaci&#xf3;n de DataSource abre y cierra una conexi&#xf3;n JDBC cada vez que se solcita una conexi&#xf3;n. Aunque es un poco lento, es una buena elecci&#xf3;n para aplicaciones que no necesitan la velocidad de tener conexiones abiertas de forma inmediata. Las bases de datos tienen un rendimiento distinto en cuanto al rendimiento que aportan con este tipo de DataSource, para algunas de ellas no es muy importante tener un pool y por tanto esta configuraci&#xf3;n es apropiada. El DataSource UNPOOLED tiene las siguientes opciones de configuraci&#xf3;n:
          </p>
        
<ul>
          
<li><code>driver</code> &#x2013; El nombre completamente cualificado de la clase java del driver JDBC (NO de la clase DataSource en el caso de que tu driver incluya una).</li>
          
<li><code>url</code> &#x2013; La URL de la instancia de base de datos.
          </li>
          
<li><code>username</code> &#x2013; El usuario de conexi&#xf3;n.
          </li>
          
<li><code>password</code> &#x2013; La password de conexi&#xf3;n.
          </li>
          
<li><code>defaultTransactionIsolationLevel</code> &#x2013; El nivel de aislamiento por defecto con el que se crear&#xe1;n las conexiones.
          </li>
          
<li><code>defaultNetworkTimeout</code> &#x2013; The default network timeout value in milliseconds to wait for the database operation to complete. See the API documentation of <code>java.sql.Connection#setNetworkTimeout()</code> for details.
          </li>
        </ul>
        
<p>Opcionalmente, puedes tambi&#xe9;n pasar propiedades al driver de la base de datos. Para ello prefija las propiedades con &#x201c;driver.&#x201d;, por ejemplo:
        </p>
        
<ul>
          
<li><code>driver.encoding=UTF8</code></li>
        </ul>
        
<p>
          Esto pasar&#xed;a la propiedad &#x201c;encoding&#x201d; con el valor &#x201c;UTF8&#x201d; al driver de base datos mediante el m&#xe9;todo DriverManager.getConnection(url, driverProperties).
        </p>
        
<p>
          <strong>POOLED</strong> &#x2013; Esta implementaci&#xf3;n de DataSource hace usa un pool de conexiones para evitar el tiempo necesario en realizar la conexi&#xf3;n y autenticaci&#xf3;n cada vez que se solicita una nueva instancia de conexi&#xf3;n. Este es un enfoque habitual en aplicaciones Web concurrentes para obtener el mejor tiempo de respuesta posible.</p>
        
<p>Adem&#xe1;s de las propiedades de (UNPOOLED) hay otras muchas propiedades que se pueden usar para configurar el DataSource POOLED:
        </p>
        
<ul>
          
<li><code>poolMaximumActiveConnections</code> &#x2013; N&#xfa;mero m&#xe1;ximo de conexi&#xf3;nes activas que pueden existir de forma simult&#xe1;nea. Por defecto:  10
          </li>
          
<li><code>poolMaximumIdleConnections</code> &#x2013; N&#xfa;mero m&#xe1;ximo de conexiones libres que pueden existir de forma simult&#xe1;nea.
          </li>
          
<li><code>poolMaximumCheckoutTime</code> &#x2013; Tiempo m&#xe1;ximo que puede permanecer una conexi&#xf3;n fuera del pool antes de que sea forzosamente devuelta. Por defecto: 20000ms (20 segundos)
          </li>
          
<li><code>poolTimeToWait</code> &#x2013; Este es un par&#xe1;metro de bajo nivel que permite escribir un log y reintentar la adquisici&#xf3;n de una conexi&#xf3;n en caso de que no se haya conseguido la conexi&#xf3;n transcurrido un tiempo razonable (esto evita que se produzcan fallos constantes y silenciosos si el pool est&#xe1; mal configurado). Por defecto:  20000ms (20 segundos)
          </li>
          
<li><code>poolMaximumLocalBadConnectionTolerance</code> &#x2013; This is a low level setting about
            tolerance of bad connections got for any thread. If a thread got a bad connection, it may
            still have another chance to re-attempt to get another connection which is valid. But the
            retrying times should not more than the sum of <code>poolMaximumIdleConnections</code>
            and <code>poolMaximumLocalBadConnectionTolerance</code>.
            Default:
            3 (Since: 3.4.5)
          </li>
          
<li><code>poolPingQuery</code> &#x2013; La query de ping (sondeo) que se env&#xed;a a la base de datos para verificar que la conexi&#xf3;n funciona correctamente y que est&#xe1; lista para aceptar nuevas peticiones de conexi&#xf3;n. El valor por defecto es &quot;NO PING QUERY SET&quot;, que har&#xe1; que la mayor&#xed;a de los drivers de base de datos devuelvan un error con un mensaje de error decente.
          </li>
          
<li><code>poolPingEnabled</code> &#x2013; Habilita o inhabilita la query de ping. Si est&#xe1; habilitada deber&#xed;as informar tambi&#xe9;n la propiedad poolPingQuery con una sentencia SQL (preferentemente una r&#xe1;pida).  Por defecto:  false.
          </li>
          
<li><code>poolPingConnectionsNotUsedFor</code> &#x2013; Configura la frecuencia con la que se ejecutar&#xe1; la sentencia poolPingQuery. Normalmente se iguala al timeout de la conexi&#xf3;n de base de datos para evitar pings innecesarios. Por defecto: 0 (todas las conexiones se testean continuamente &#x2013; solo si se ha habilitado poolPingEnabled).
          </li>
        </ul>
        
<p>
          <strong>JNDI</strong>
          &#x2013; Esta implementaci&#xf3;n de DataSource est&#xe1; pensada para ser usada en contenedores como Spring o los servidores de aplicaciones JEE en los que es posible configurar un DataSource de forma externa y alojarlo en el contexto JNDI. Esta configuraci&#xf3;n de DataSource requiere solo dos propiedades:
        </p>
        
<ul>
          
<li><code>initial_context</code> &#x2013; Propiedad que se usa para realizar el lookup en el InitialContext (initialContext.lookup(initial_context)). Esta propiedad es opcional, si no se informa, se buscar&#xe1; directamente la propiedad data_source.
          </li>
          
<li><code>data_source</code> &#x2013; Es el contexto donde se debe buscar el DataSource. El DataSource se buscar&#xe1; en el contexto resultado de buscar data_source en el InitialContext o si no se ha informado la propiedad se buscar&#xe1; directamente sobre InitialContext.
          </li>
        </ul>
        
<p>Al igual que en las otras configuraciones de DataSource. Es posible enviar propiedades directamente al InitialContext prefijando las propiedades con &#x201c;env.&#x201d;, por ejemplo:
        </p>
        
<ul>
          
<li><code>env.encoding=UTF8</code></li>
        </ul>
        
<p>
         Enviar&#xe1; la propiedad &#x201c;encoding&#x201d; y el valor &#x201c;UTF-8&#x201d; al constructor del InitialContext durante su instanciaci&#xf3;n.
        </p>

    
<p>
      You can plug any 3rd party DataSource by implementing the interface <code>org.apache.ibatis.datasource.DataSourceFactory</code>:
    </p>

        
<pre class="prettyprint"><code>public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}</code></pre>

        
<p>
      The <code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> puede extenderse para crear nuevos
      adaptadores. Por ejemplo, este es el c&#xf3;digo necesario para integrar C3P0:
    </p>

        
<pre class="prettyprint"><code>import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

  public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
  }
}</code></pre>

        
<p>Para configurarlo, a&#xf1;ade una propiedad por cada m&#xe9;todo al que quieres que llame MyBatis.
        A continuaci&#xf3;n se muestra una configuraci&#xf3;n de ejemplo para conectar con una base de datos PostgresSQL:</p>

        
<pre class="prettyprint"><code>&lt;dataSource type=&quot;org.myproject.C3P0DataSourceFactory&quot;&gt;
  &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql:mydb&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/dataSource&gt;
</code></pre>

      </section>

      <section><a id="databaseIdProvider"></a>
<h2>databaseIdProvider</h2>
        
<p>
          MyBatis puede ejeutar sentencias distintas en funci&#xf3;n del fabricante (vendor) de tu base de datos.
          El soporte de m&#xfa;ltiples bases de datos se basa en el atributo de <code>databaseId</code> de los mapped statements.
          MyBatis cargar&#xe1; todos los statements que no tengan atributo <code>databaseId</code> attribute o aquellos
          cuyo <code>databaseId</code> coincida con el valor en curso. Si se encuentra un statement con y sin atributo
          <code>databaseId</code> el &#xfa;ltimo se descartar&#xe1;.
          Para activar el soporte de multi vendor a&#xf1;ade un <code>databaseIdProvider</code>
          al fichero mybatis-config.xml file de la siguiente forma:
        </p>

        
<pre class="prettyprint"><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt;
</code></pre>

    
<p>
      La implementaci&#xf3;n DB_VENDOR del databaseIdProvider establece como databaseId el String devuelto por
      <code>DatabaseMetaData#getDatabaseProductName()</code>.
      Como normalmente este string es demasiado largo, y adem&#xe1;s, distintas versiones del mismo producto devuelven valores
      similares, puedes traducirlo a un valor m&#xe1;s corto a&#xf1;adiendo propiedades de la siguente forma:
    </p>

        
<pre class="prettyprint"><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;
  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;
  &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;
  &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;
&lt;/databaseIdProvider&gt;</code></pre>

    
<p>
      Cuando se a&#xf1;aden propiedades, el databaseIdProvider DB_VENDOR devuelve el primer valor que corresponde a la primera clave
      encontrada en el nombre devuelto por <code>DatabaseMetaData#getDatabaseProductName()</code> o &quot;null&quot; si no se encuentra ninguna.
      En este caso, si <code>getDatabaseProductName()</code> devuelve &quot;Oracle (DataDirect)&quot; el databaseId se informar&#xe1; con &quot;oracle&quot;.
    </p>

    
<p>
      Puedes construir tu propio DatabaseIdProvider implementando la interfaz <code>org.apache.ibatis.mapping.DatabaseIdProvider</code>
      y registrandolo en el fichero mybatis-config.xml:
    </p>

        
<pre class="prettyprint"><code>public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // Since 3.5.2, change to default method
    // NOP
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}</code></pre>

      </section>

      <section><a id="mappers"></a>
<h2>mappers</h2>
        
<p>
          Ahora que se ha configurado el comportamiento de MyBatis con todos los elementos de configuraci&#xf3;n comentados estamos listos para definir los SQL mapped statements (sentencias SQL mapeadas). Primeramente necesitaremos indicarle a MyBatis d&#xf3;nde encontrarlos. Java no ofrece muchas posibilidades de auto-descubrimiento as&#xed; que la mejor forma es simplemente decirle a MyBatis donde encontrar los ficheros de mapeo. Puedes utilizar referencias tipo classpath, o tipo path o referencias url completamente cualificadas (incluyendo file:///) . Por ejemplo:
        </p>
        
<pre class="prettyprint"><code>&lt;!-- Using classpath relative resources --&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>

        
<pre class="prettyprint"><code>&lt;!-- Using url fully qualified paths --&gt;
&lt;mappers&gt;
  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>

        
<pre class="prettyprint"><code>&lt;!-- Using mapper interface classes --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>

        
<pre class="prettyprint"><code>&lt;!-- Register all interfaces in a package as mappers --&gt;
&lt;mappers&gt;
  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;</code></pre>

        
<p>
         Esta configuraci&#xf3;n s&#xf3;lo indica a MyBatis cu&#xe1;les son los ficheros de mapeo. El resto de la configuraci&#xf3;n se encuentra dentro de estos ficheros, y eso es de lo que hablaremos en el siguiente apartado.
        </p>
      </section>
    </section>
  
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>©      2009–2025
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
  </body>
</html>