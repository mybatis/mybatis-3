<?xml version="1.0" encoding="UTF-8"?>
<!--

       Copyright 2009-2022 the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>MyBatis 3 | 配置</title>
    <author email="clinton.begin@gmail.com">Clinton Begin</author>
    <author email="nanlei1987@gmail.com">Nan Lei</author>
    <author email="echowdx@gmail.com">Dongxu Wang</author>
  </properties>

  <body>
    <section name="配置">
      <p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。
      配置文档的顶层结构如下：</p>

      <ul>
        <li>
          configuration（配置）
          <ul>
            <li><a href="#properties">properties（属性）</a></li>
            <li><a href="#settings">settings（设置）</a></li>
            <li><a href="#typeAliases">typeAliases（类型别名）</a></li>
            <li><a href="#typeHandlers">typeHandlers（类型处理器）</a></li>
            <li><a href="#objectFactory">objectFactory（对象工厂）</a></li>
            <li><a href="#plugins">plugins（插件）</a></li>
            <li><a href="#environments">environments（环境配置）</a>
              <ul>
                <li>
                  environment（环境变量）
                  <ul>
                    <li>transactionManager（事务管理器）</li>
                    <li>dataSource（数据源）</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
            <li><a href="#mappers">mappers（映射器）</a></li>
          </ul>
        </li>
      </ul>
      <subsection name="属性（properties）" id="properties">
        <p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：</p>
        <source><![CDATA[<properties resource="org/mybatis/example/config.properties">
  <property name="username" value="dev_user"/>
  <property name="password" value="F2Fa3!33TYyg"/>
</properties>]]></source>
        <p>设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如:
        </p>
        <source><![CDATA[<dataSource type="POOLED">
  <property name="driver" value="${driver}"/>
  <property name="url" value="${url}"/>
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>]]></source>
        <p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。
          driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p>
        <p>也可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值。例如：</p>
        <source><![CDATA[SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);

// ... 或者 ...

SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);
]]></source>
        <p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p>
        <ul>
          <li>首先读取在 properties 元素体内指定的属性。
          </li>
          <li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据
          url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。
          </li>
          <li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。
          </li>
        </ul>
        <p>因此，通过方法参数传递的属性具有最高优先级，resource/url
        属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。</p>

        <p>
		    从 MyBatis 3.4.2 开始，你可以为占位符指定一个默认值。例如：
        </p>
        <source><![CDATA[
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- 如果属性 'username' 没有被配置，'username' 属性的值将为 'ut_user' -->
</dataSource>]]></source>

        <p>
		  这个特性默认是关闭的。要启用这个特性，需要添加一个特定的属性来开启这个特性。例如：
        </p>

        <source><![CDATA[
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- 启用默认值特性 -->
</properties>]]></source>

        <p>
          <span class="label important">提示</span>
          如果你在属性名中使用了 <code>":"</code>
          字符（如：<code>db:username</code>），或者在 SQL
          映射中使用了 OGNL 表达式的三元运算符（如： <code>${tableName != null ?
          tableName : 'global_constants'}</code>），就需要设置特定的属性来修改分隔属性名和默认值的字符。例如：
        </p>

        <source><![CDATA[
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- 修改默认值的分隔符 -->
</properties>]]></source>
        <source><![CDATA[
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${db:username?:ut_user}"/>
</dataSource>]]></source>

      </subsection>
      <subsection name="设置（settings）" id="settings">
        <p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。
        下表描述了设置中各项设置的含义、默认值等。</p>

        <table>
          <thead>
            <tr>
              <th>设置名</th>
              <th>描述</th>
              <th>有效值</th>
              <th>默认值</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                cacheEnabled
              </td>
              <td>
                全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                lazyLoadingEnabled
              </td>
              <td>
                延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。
                特定关联关系中可通过设置 <code>fetchType</code>
                属性来覆盖该项的开关状态。
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                aggressiveLazyLoading
              </td>
              <td>
                开启时，任一方法的调用都会加载该对象的所有延迟加载属性。
                否则，每个延迟加载属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。
              </td>
              <td>
                true | false
              </td>
              <td>
                false （在 3.4.1 及之前的版本中默认为 true）
              </td>
            </tr>
            <tr>
              <td>
                multipleResultSetsEnabled
              </td>
              <td>
                是否允许单个语句返回多结果集（需要数据库驱动支持）。
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                useColumnLabel
              </td>
              <td>
                使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                useGeneratedKeys
              </td>
              <td>
                允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为
                true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。
              </td>
              <td>
                true | false
              </td>
              <td>
                False
              </td>
            </tr>
            <tr>
              <td>
                autoMappingBehavior
              </td>
              <td>
                指定 MyBatis 应如何自动映射列到字段或属性。
                NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。
                FULL 会自动映射任何复杂的结果集（无论是否嵌套）。
              </td>
              <td>
                NONE, PARTIAL, FULL
              </td>
              <td>
                PARTIAL
              </td>
            </tr>
            <tr>
              <td>
                autoMappingUnknownColumnBehavior
              </td>
              <td>
			  指定发现自动映射目标未知列（或未知属性类型）的行为。
                <ul>
                  <li><code>NONE</code>: 不做任何反应</li>
                  <li><code>WARNING</code>:
                  输出警告日志（<code>'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'</code>
                  的日志等级必须设置为 <code>WARN</code>）</li>
                  <li><code>FAILING</code>: 映射失败 (抛出 <code>SqlSessionException</code>)</li>
                </ul>
              </td>
              <td>
                NONE, WARNING, FAILING
              </td>
              <td>
                NONE
              </td>
            </tr>
            <tr>
              <td>
                defaultExecutorType
              </td>
              <td>
                配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）；
                BATCH 执行器不仅重用语句还会执行批量更新。
              </td>
              <td>
                SIMPLE
                REUSE
                BATCH
              </td>
              <td>
                SIMPLE
              </td>
            </tr>
            <tr>
              <td>
                defaultStatementTimeout
              </td>
              <td>
                设置超时时间，它决定数据库驱动等待数据库响应的秒数。
              </td>
              <td>
                任意正整数
              </td>
              <td>
                未设置 (null)
              </td>
            </tr>
            <tr>
              <td>
                defaultFetchSize
              </td>
              <td>
                为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。
              </td>
              <td>
                任意正整数
              </td>
              <td>
                未设置 (null)
              </td>
            </tr>
            <tr>
              <td>
                defaultResultSetType
              </td>
              <td>
                指定语句默认的滚动策略。（新增于 3.5.2）
              </td>
              <td>
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置）
              </td>
              <td>
                未设置 (null)
              </td>
            </tr>
            <tr>
              <td>
                safeRowBoundsEnabled
              </td>
              <td>
                是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。
              </td>
              <td>
                true | false
              </td>
              <td>
                False
              </td>
            </tr>
            <tr>
              <td>
                safeResultHandlerEnabled
              </td>
              <td>
                是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。
              </td>
              <td>
                true | false
              </td>
              <td>
                True
              </td>
            </tr>
            <tr>
              <td>
                mapUnderscoreToCamelCase
              </td>
              <td>
                是否开启驼峰命名自动映射，即从经典数据库列名
                A_COLUMN 映射到经典 Java 属性名 aColumn。
              </td>
              <td>
                true | false
              </td>
              <td>
                False
              </td>
            </tr>
            <tr>
              <td>
                localCacheScope
              </td>
              <td>
                MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。
                默认值为 SESSION，会缓存一个会话中执行的所有查询。
                若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。
              </td>
              <td>
                SESSION | STATEMENT
              </td>
              <td>
                SESSION
              </td>
            </tr>
            <tr>
              <td>
                jdbcTypeForNull
              </td>
              <td>
                当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。
                某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。
              </td>
              <td>
                JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。
              </td>
              <td>
                OTHER
              </td>
            </tr>
            <tr>
              <td>
                lazyLoadTriggerMethods
              </td>
              <td>
                指定对象的哪些方法触发一次延迟加载。
              </td>
              <td>
                用逗号分隔的方法列表。
              </td>
              <td>
                equals,clone,hashCode,toString
              </td>
            </tr>
            <tr>
              <td>
                defaultScriptingLanguage
              </td>
              <td>
                指定动态 SQL 生成使用的默认脚本语言。
              </td>
              <td>
                一个类型别名或全限定类名。
              </td>
              <td>
                org.apache.ibatis.scripting.xmltags.XMLLanguageDriver
              </td>
            </tr>
            <tr>
              <td>
                defaultEnumTypeHandler
              </td>
              <td>
                指定 Enum 使用的默认 <code>TypeHandler</code> 。（新增于 3.4.5）
              </td>
              <td>
                一个类型别名或全限定类名。
              </td>
              <td>
                org.apache.ibatis.type.EnumTypeHandler
              </td>
            </tr>
            <tr>
              <td>
                callSettersOnNulls
              </td>
              <td>
                指定当结果集中值为 null 的时候是否调用映射对象的 setter（map
                对象时为 put）方法，这在依赖于 Map.keySet() 或 null
                值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                returnInstanceForEmptyRow
              </td>
              <td>
				当返回行的所有列都是空时，MyBatis默认返回 <code>null</code>。
				当开启这个设置时，MyBatis会返回一个空实例。
				请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                logPrefix
              </td>
              <td>
                指定 MyBatis 增加到日志名称的前缀。
              </td>
              <td>
                任何字符串
              </td>
              <td>
                未设置
              </td>
            </tr>
            <tr>
              <td>
                logImpl
              </td>
              <td>
                指定 MyBatis 所用日志的具体实现，未指定时将自动查找。
              </td>
              <td>
                SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
              </td>
              <td>
                未设置
              </td>
            </tr>
            <tr>
              <td>
                proxyFactory
              </td>
              <td>
                指定 Mybatis 创建可延迟加载对象所用到的代理工具。
              </td>
              <td>
                CGLIB | JAVASSIST
              </td>
              <td>
                JAVASSIST （MyBatis 3.3 以上）
              </td>
            </tr>
            <tr>
              <td>
                vfsImpl
              </td>
              <td>
                指定 VFS 的实现
              </td>
              <td>
                自定义 VFS 的实现的类全限定名，以逗号分隔。
              </td>
              <td>
                未设置
              </td>
            </tr>
            <tr>
              <td>
                useActualParamName
              </td>
              <td>
                允许使用方法签名中的名称作为语句参数名称。
		        为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 <code>-parameters</code> 选项。（新增于 3.4.1）
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                configurationFactory
              </td>
              <td>
                指定一个提供 <code>Configuration</code> 实例的类。
		            这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。
		            这个类必须包含一个签名为<code>static Configuration getConfiguration()</code> 的方法。（新增于 3.2.3）
              </td>
              <td>
                一个类型别名或完全限定类名。
              </td>
              <td>
                未设置
              </td>
            </tr>
            <tr>
              <td>
                shrinkWhitespacesInSql
              </td>
              <td>
                从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5)
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                defaultSqlProviderType
              </td>
              <td>
                Specifies an sql provider class that holds provider method (Since 3.5.6).
                This class apply to the <code>type</code>(or <code>value</code>) attribute on sql provider annotation(e.g. <code>@SelectProvider</code>),
                when these attribute was omitted.
              </td>
              <td>
                A type alias or fully qualified class name
              </td>
              <td>
                Not set
              </td>
            </tr>
            <tr>
              <td>
                nullableOnForEach
              </td>
              <td>
                Specifies the default value of 'nullable' attribute on 'foreach' tag. (Since 3.5.9)
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          一个配置完整的 settings 元素的示例如下：
        </p>
        <source><![CDATA[<settings>
  <setting name="cacheEnabled" value="true"/>
  <setting name="lazyLoadingEnabled" value="true"/>
  <setting name="multipleResultSetsEnabled" value="true"/>
  <setting name="useColumnLabel" value="true"/>
  <setting name="useGeneratedKeys" value="false"/>
  <setting name="autoMappingBehavior" value="PARTIAL"/>
  <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>
  <setting name="defaultExecutorType" value="SIMPLE"/>
  <setting name="defaultStatementTimeout" value="25"/>
  <setting name="defaultFetchSize" value="100"/>
  <setting name="safeRowBoundsEnabled" value="false"/>
  <setting name="mapUnderscoreToCamelCase" value="false"/>
  <setting name="localCacheScope" value="SESSION"/>
  <setting name="jdbcTypeForNull" value="OTHER"/>
  <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
</settings>]]></source>

      </subsection>
      <subsection name="类型别名（typeAliases）" id="typeAliases">
        <p>类型别名可为 Java 类型设置一个缩写名字。
        它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p>
        <source><![CDATA[<typeAliases>
  <typeAlias alias="Author" type="domain.blog.Author"/>
  <typeAlias alias="Blog" type="domain.blog.Blog"/>
  <typeAlias alias="Comment" type="domain.blog.Comment"/>
  <typeAlias alias="Post" type="domain.blog.Post"/>
  <typeAlias alias="Section" type="domain.blog.Section"/>
  <typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>
]]></source>
        <p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
        <p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：
        </p>
        <source><![CDATA[<typeAliases>
  <package name="domain.blog"/>
</typeAliases>
]]></source>
        <p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用
        Bean 的首字母小写的非限定类名来作为它的别名。
          比如 <code>domain.blog.Author</code> 的别名为
          <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p>
        <source><![CDATA[@Alias("author")
public class Author {
    ...
}
]]></source>
        <p>下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p>
        <table>
          <thead>
            <tr>
              <th>
                别名
              </th>
              <th>
                映射的类型
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                _byte
              </td>
              <td>
                byte
              </td>
            </tr>
            <tr>
              <td>
                _long
              </td>
              <td>
                long
              </td>
            </tr>
            <tr>
              <td>
                _short
              </td>
              <td>
                short
              </td>
            </tr>
            <tr>
              <td>
                _int
              </td>
              <td>
                int
              </td>
            </tr>
            <tr>
              <td>
                _integer
              </td>
              <td>
                int
              </td>
            </tr>
            <tr>
              <td>
                _double
              </td>
              <td>
                double
              </td>
            </tr>
            <tr>
              <td>
                _float
              </td>
              <td>
                float
              </td>
            </tr>
            <tr>
              <td>
                _boolean
              </td>
              <td>
                boolean
              </td>
            </tr>
            <tr>
              <td>
                string
              </td>
              <td>
                String
              </td>
            </tr>
            <tr>
              <td>
                byte
              </td>
              <td>
                Byte
              </td>
            </tr>
            <tr>
              <td>
                long
              </td>
              <td>
                Long
              </td>
            </tr>
            <tr>
              <td>
                short
              </td>
              <td>
                Short
              </td>
            </tr>
            <tr>
              <td>
                int
              </td>
              <td>
                Integer
              </td>
            </tr>
            <tr>
              <td>
                integer
              </td>
              <td>
                Integer
              </td>
            </tr>
            <tr>
              <td>
                double
              </td>
              <td>
                Double
              </td>
            </tr>
            <tr>
              <td>
                float
              </td>
              <td>
                Float
              </td>
            </tr>
            <tr>
              <td>
                boolean
              </td>
              <td>
                Boolean
              </td>
            </tr>
            <tr>
              <td>
                date
              </td>
              <td>
                Date
              </td>
            </tr>
            <tr>
              <td>
                decimal
              </td>
              <td>
                BigDecimal
              </td>
            </tr>
            <tr>
              <td>
                bigdecimal
              </td>
              <td>
                BigDecimal
              </td>
            </tr>
            <tr>
              <td>
                object
              </td>
              <td>
                Object
              </td>
            </tr>
            <tr>
              <td>
                map
              </td>
              <td>
                Map
              </td>
            </tr>
            <tr>
              <td>
                hashmap
              </td>
              <td>
                HashMap
              </td>
            </tr>
            <tr>
              <td>
                list
              </td>
              <td>
                List
              </td>
            </tr>
            <tr>
              <td>
                arraylist
              </td>
              <td>
                ArrayList
              </td>
            </tr>
            <tr>
              <td>
                collection
              </td>
              <td>
                Collection
              </td>
            </tr>
            <tr>
              <td>
                iterator
              </td>
              <td>
                Iterator
              </td>
            </tr>
          </tbody>
        </table>
      </subsection>
      <subsection name="类型处理器（typeHandlers）" id="typeHandlers">
        <p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时，
          都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。</p>
        <p>
          <span class="label important">提示</span>
         从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。
        </p>
        <table>
          <thead>
            <tr>
              <th>
                类型处理器
              </th>
              <th>
                Java 类型
              </th>
              <th>
                JDBC 类型
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <code>BooleanTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Boolean</code>, <code>boolean</code>
              </td>
              <td>
                数据库兼容的 <code>BOOLEAN</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>ByteTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Byte</code>, <code>byte</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>BYTE</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>ShortTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Short</code>, <code>short</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>SMALLINT</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>IntegerTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Integer</code>, <code>int</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>INTEGER</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>LongTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Long</code>, <code>long</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>BIGINT</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>FloatTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Float</code>, <code>float</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>FLOAT</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>DoubleTypeHandler</code>
              </td>
              <td>
                <code>java.lang.Double</code>, <code>double</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>BigDecimalTypeHandler</code>
              </td>
              <td>
                <code>java.math.BigDecimal</code>
              </td>
              <td>
                数据库兼容的 <code>NUMERIC</code> 或 <code>DECIMAL</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>StringTypeHandler</code>
              </td>
              <td>
                <code>java.lang.String</code>
              </td>
              <td>
                <code>CHAR</code>, <code>VARCHAR</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>ClobReaderTypeHandler</code>
              </td>
              <td>
                <code>java.io.Reader</code>
              </td>
              <td>
                -
              </td>
            </tr>
            <tr>
              <td>
                <code>ClobTypeHandler</code>
              </td>
              <td>
                <code>java.lang.String</code>
              </td>
              <td>
                <code>CLOB</code>, <code>LONGVARCHAR</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>NStringTypeHandler</code>
              </td>
              <td>
                <code>java.lang.String</code>
              </td>
              <td>
                <code>NVARCHAR</code>, <code>NCHAR</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>NClobTypeHandler</code>
              </td>
              <td>
                <code>java.lang.String</code>
              </td>
              <td>
                <code>NCLOB</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>BlobInputStreamTypeHandler</code>
              </td>
              <td>
                <code>java.io.InputStream</code>
              </td>
              <td>
                -
              </td>
            </tr>
            <tr>
              <td>
                <code>ByteArrayTypeHandler</code>
              </td>
              <td>
                <code>byte[]</code>
              </td>
              <td>
                数据库兼容的字节流类型
              </td>
            </tr>
            <tr>
              <td>
                <code>BlobTypeHandler</code>
              </td>
              <td>
                <code>byte[]</code>
              </td>
              <td>
                <code>BLOB</code>, <code>LONGVARBINARY</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>DateTypeHandler</code>
              </td>
              <td>
                <code>java.util.Date</code>
              </td>
              <td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>DateOnlyTypeHandler</code>
              </td>
              <td>
                <code>java.util.Date</code>
              </td>
              <td>
                <code>DATE</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>TimeOnlyTypeHandler</code>
              </td>
              <td>
                <code>java.util.Date</code>
              </td>
              <td>
                <code>TIME</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>SqlTimestampTypeHandler</code>
              </td>
              <td>
                <code>java.sql.Timestamp</code>
              </td>
              <td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>SqlDateTypeHandler</code>
              </td>
              <td>
                <code>java.sql.Date</code>
              </td>
              <td>
                <code>DATE</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>SqlTimeTypeHandler</code>
              </td>
              <td>
                <code>java.sql.Time</code>
              </td>
              <td>
                <code>TIME</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>ObjectTypeHandler</code>
              </td>
              <td>
                Any
              </td>
              <td>
                <code>OTHER</code> 或未指定类型
              </td>
            </tr>
            <tr>
              <td>
                <code>EnumTypeHandler</code>
              </td>
              <td>
                Enumeration Type
              </td>
              <td>
                VARCHAR 或任何兼容的字符串类型，用来存储枚举的名称（而不是索引序数值）
              </td>
            </tr>
            <tr>
              <td>
                <code>EnumOrdinalTypeHandler</code>
              </td>
              <td>
                Enumeration Type
              </td>
              <td>
                任何兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code>
                类型，用来存储枚举的序数值（而不是名称）。
              </td>
            </tr>
            <tr>
              <td>
                <code>SqlxmlTypeHandler</code>
              </td>
              <td>
                <code>java.lang.String</code>
              </td>
              <td>
                <code>SQLXML</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>InstantTypeHandler</code>
              </td>
              <td>
                <code>java.time.Instant</code>
              </td>
              <td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>LocalDateTimeTypeHandler</code>
              </td>
              <td>
                <code>java.time.LocalDateTime</code>
              </td>
              <td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>LocalDateTypeHandler</code>
              </td>
              <td>
                <code>java.time.LocalDate</code>
              </td>
              <td>
                <code>DATE</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>LocalTimeTypeHandler</code>
              </td>
              <td>
                <code>java.time.LocalTime</code>
              </td>
              <td>
                <code>TIME</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>OffsetDateTimeTypeHandler</code>
              </td>
              <td>
                <code>java.time.OffsetDateTime</code>
              </td>
              <td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>OffsetTimeTypeHandler</code>
              </td>
              <td>
                <code>java.time.OffsetTime</code>
              </td>
              <td>
                <code>TIME</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>ZonedDateTimeTypeHandler</code>
              </td>
              <td>
                <code>java.time.ZonedDateTime</code>
              </td>
              <td>
                <code>TIMESTAMP</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>YearTypeHandler</code>
              </td>
              <td>
                <code>java.time.Year</code>
              </td>
              <td>
                <code>INTEGER</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>MonthTypeHandler</code>
              </td>
              <td>
                <code>java.time.Month</code>
              </td>
              <td>
                <code>INTEGER</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>YearMonthTypeHandler</code>
              </td>
              <td>
                <code>java.time.YearMonth</code>
              </td>
              <td>
                <code>VARCHAR</code> 或 <code>LONGVARCHAR</code>
              </td>
            </tr>
            <tr>
              <td>
                <code>JapaneseDateTypeHandler</code>
              </td>
              <td>
                <code>java.time.chrono.JapaneseDate</code>
              </td>
              <td>
                <code>DATE</code>
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。
          具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口，
          或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>，
          并且可以（可选地）将它映射到一个 JDBC 类型。比如：
        </p>
        <source><![CDATA[// ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
]]></source>

        <source><![CDATA[<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.mybatis.example.ExampleTypeHandler"/>
</typeHandlers>
]]></source>

        <p>
          使用上述的类型处理器将会覆盖已有的处理 Java String 类型的属性以及
          VARCHAR 类型的参数和结果的类型处理器。
          要注意 MyBatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 VARCHAR 类型，
          以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。
        </p>
        <p>
          通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：
        </p>
        <ul>
          <li>
            在类型处理器的配置元素（typeHandler 元素）上增加一个
            <code>javaType</code> 属性（比如：<code>javaType="String"</code>）；
            </li>
          <li>
            在类型处理器的类上增加一个
            <code>@MappedTypes</code> 注解指定与其关联的 Java 类型列表。
            如果在 <code>javaType</code> 属性中也同时指定，则注解上的配置将被忽略。
          </li>
        </ul>

        <p>可以通过两种方式来指定关联的 JDBC 类型：</p>
        <ul>
          <li>
            在类型处理器的配置元素上增加一个 <code>jdbcType</code>
            属性（比如：<code>jdbcType="VARCHAR"</code>）；
          </li>
          <li>
            在类型处理器的类上增加一个 <code>@MappedJdbcTypes</code>
            注解指定与其关联的 JDBC 类型列表。
            如果在 <code>jdbcType</code> 属性中也同时指定，则注解上的配置将被忽略。
          </li>
        </ul>

        <p>
          当在 <code>ResultMap</code> 中决定使用哪种类型处理器时，此时 Java
          类型是已知的（从结果类型中获得），但是 JDBC 类型是未知的。
	      因此 Mybatis 使用 <code>javaType=[Java 类型], jdbcType=null</code>
          的组合来选择一个类型处理器。
	      这意味着使用 <code>@MappedJdbcTypes</code>
          注解可以<i>限制</i>类型处理器的作用范围，并且可以确保，除非显式地设置，否则类型处理器在
          <code>ResultMap</code> 中将不会生效。
	      如果希望能在 <code>ResultMap</code> 中隐式地使用类型处理器，那么设置
          <code>@MappedJdbcTypes</code> 注解的 <code>includeNullJdbcType=true</code> 即可。
	      然而从 Mybatis 3.4.0 开始，如果某个 Java 类型<b>只有一个</b>注册的类型处理器，即使没有设置 <code>includeNullJdbcType=true</code>，那么这个类型处理器也会是 <code>ResultMap</code> 使用 Java
          类型时的默认处理器。
        </p>

        <p>最后，可以让 MyBatis 帮你查找类型处理器：</p>
        <source><![CDATA[<!-- mybatis-config.xml -->
<typeHandlers>
  <package name="org.mybatis.example"/>
</typeHandlers>
]]></source>

        <p>注意在使用自动发现功能的时候，只能通过注解方式来指定 JDBC 的类型。</p>
        <p>你可以创建能够处理多个类的泛型类型处理器。为了使用泛型类型处理器，
          需要增加一个接受该类的 class 作为参数的构造器，这样 MyBatis

          会在构造一个类型处理器实例的时候传入一个具体的类。</p>
        <source><![CDATA[//GenericTypeHandler.java
public class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {

  private Class<E> type;

  public GenericTypeHandler(Class<E> type) {
    if (type == null) throw new IllegalArgumentException("Type argument cannot be null");
    this.type = type;
  }
  ...
]]></source>

        <p><code>EnumTypeHandler</code> 和 <code>EnumOrdinalTypeHandler</code>
        都是泛型类型处理器，我们将会在接下来的部分详细探讨。</p>

      </subsection>

      <subsection name="处理枚举类型">
        <p>若想映射枚举类型 <code>Enum</code>，则需要从 <code>EnumTypeHandler</code>
        或者 <code>EnumOrdinalTypeHandler</code> 中选择一个来使用。</p>

        <p>比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用
        <code>EnumTypeHandler</code> 来把 <code>Enum</code> 值转换成对应的名字。</p>

        <b>注意 <code>EnumTypeHandler</code>
        在某种意义上来说是比较特别的，其它的处理器只针对某个特定的类，而它不同，它会处理任意继承了
        <code>Enum</code> 的类。</b>

        <p>不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样简单：在配置文件中把
          <code>EnumOrdinalTypeHandler</code> 加到 <code>typeHandlers</code> 中即可，
          这样每个 <code>RoundingMode</code> 将通过他们的序数值来映射成对应的整形数值。
        </p>
        <source><![CDATA[<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="java.math.RoundingMode"/>
</typeHandlers>
]]></source>
        <p>但要是你想在一个地方将 <code>Enum</code> 映射成字符串，在另外一个地方映射成整形值呢？</p>
        <p>
          自动映射器（auto-mapper）会自动地选用 <code>EnumOrdinalTypeHandler</code> 来处理枚举类型，
          所以如果我们想用普通的 <code>EnumTypeHandler</code>，就必须要显式地为那些 SQL 语句设置要使用的类型处理器。
        </p>
        <p>（下一节才开始介绍映射器文件，如果你是首次阅读该文档，你可能需要先跳过这里，过会再来看。）</p>
        <source><![CDATA[<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.apache.ibatis.submitted.rounding.Mapper">
	<resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<result column="funkyNumber" property="funkyNumber"/>
		<result column="roundingMode" property="roundingMode"/>
	</resultMap>

	<select id="getUser" resultMap="usermap">
		select * from users
	</select>
	<insert id="insert">
	    insert into users (id, name, funkyNumber, roundingMode) values (
	    	#{id}, #{name}, #{funkyNumber}, #{roundingMode}
	    )
	</insert>

	<resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap2">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<result column="funkyNumber" property="funkyNumber"/>
		<result column="roundingMode" property="roundingMode" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
	</resultMap>
	<select id="getUser2" resultMap="usermap2">
		select * from users2
	</select>
	<insert id="insert2">
	    insert into users2 (id, name, funkyNumber, roundingMode) values (
	    	#{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler}
	    )
	</insert>

</mapper>
]]></source>
        <p>注意，这里的 select 语句必须指定 <code>resultMap</code> 而不是 <code>resultType</code>。</p>
      </subsection>

      <subsection name="对象工厂（objectFactory）" id="objectFactory">
        <p>每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。
          默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。
          如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。比如：</p>
        <source><![CDATA[// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  public Object create(Class type) {
    return super.create(type);
  }
  public Object create(Class type, List<Class> constructorArgTypes, List<Object> constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }}
]]></source>

        <source><![CDATA[<!-- mybatis-config.xml -->
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
  <property name="someProperty" value="100"/>
</objectFactory>]]></source>
        <p>ObjectFactory 接口很简单，它包含两个创建实例用的方法，一个是处理默认无参构造方法的，另外一个是处理带参数的构造方法的。
          另外，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后，
          objectFactory 元素体中定义的属性会被传递给 setProperties 方法。</p>

      </subsection>
      <subsection name="插件（plugins）" id="plugins">
        <p>
          MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：
        </p>
        <ul>
          <li>
            Executor
            (update, query, flushStatements, commit, rollback,
            getTransaction, close,
            isClosed)
          </li>
          <li>
            ParameterHandler
            (getParameterObject, setParameters)
          </li>
          <li>
            ResultSetHandler
            (handleResultSets, handleOutputParameters)
          </li>
          <li>
            StatementHandler
            (prepare, parameterize, batch, update, query)
          </li>
        </ul>
        <p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。
          如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。
          因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。
          这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p>
        <p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p>

        <source><![CDATA[// ExamplePlugin.java
@Intercepts({@Signature(
  type= Executor.class,
  method = "update",
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  private Properties properties = new Properties();
  public Object intercept(Invocation invocation) throws Throwable {
    // implement pre processing if need
    Object returnObject = invocation.proceed();
    // implement post processing if need
    return returnObject;
  }
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
}]]></source>

        <source><![CDATA[<!-- mybatis-config.xml -->
<plugins>
  <plugin interceptor="org.mybatis.example.ExamplePlugin">
    <property name="someProperty" value="100"/>
  </plugin>
</plugins>]]></source>
        <p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用，
          这里的 Executor 是负责执行底层映射语句的内部对象。</p>
        <p><span class="label important">提示</span>
          <strong>覆盖配置类</strong>
        </p>
        <p>除了用插件来修改 MyBatis 核心行为以外，还可以通过完全覆盖配置类来达到目的。只需继承配置类后覆盖其中的某个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会极大影响 MyBatis 的行为，务请慎之又慎。</p>
      </subsection>
      <subsection name="环境配置（environments）" id="environments">
        <p>
          MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中，
          现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema
          的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。</p>
        <p>
          <strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory
          实例只能选择一种环境。</strong>
        </p>
        <p>
          所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory
          实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：
        </p>
        <ul>
          <li>
            <strong>每个数据库对应一个 SqlSessionFactory 实例</strong>
          </li>
        </ul>
        <p>
          为了指定创建哪种环境，只要将它作为可选的参数传递给
          SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：
        </p>

        <source><![CDATA[SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);]]></source>

        <p>如果忽略了环境参数，那么将会加载默认环境，如下所示：
        </p>

        <source><![CDATA[SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);]]></source>

        <p>environments 元素定义了如何配置环境。
        </p>

        <source><![CDATA[<environments default="development">
  <environment id="development">
    <transactionManager type="JDBC">
      <property name="..." value="..."/>
    </transactionManager>
    <dataSource type="POOLED">
      <property name="driver" value="${driver}"/>
      <property name="url" value="${url}"/>
      <property name="username" value="${username}"/>
      <property name="password" value="${password}"/>
    </dataSource>
  </environment>
</environments>]]></source>
        <p>
          注意一些关键点:
        </p>
        <ul>
          <li>
            默认使用的环境 ID（比如：default="development"）。
          </li>
          <li>
            每个 environment 元素定义的环境 ID（比如：id="development"）。
          </li>
          <li>
            事务管理器的配置（比如：type="JDBC"）。
          </li>
          <li>
            数据源的配置（比如：type="POOLED"）。
          </li>
        </ul>
        <p>
          默认环境和环境 ID 顾名思义。
          环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。
        </p>
        <p>
          <strong>事务管理器（transactionManager）</strong>
        </p>
        <p>在 MyBatis 中有两种类型的事务管理器（也就是 type="[JDBC|MANAGED]"）：</p>
        <ul>
          <li>
            JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。
          </li>
          <li>
            MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。
            默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如:
            <source><![CDATA[<transactionManager type="MANAGED">
  <property name="closeConnection" value="false"/>
</transactionManager>]]></source>
          </li>
        </ul>
        <p>
          <span class="label important">提示</span>
          如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为
          Spring 模块会使用自带的管理器来覆盖前面的配置。
        </p>
        <p>
          这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以用
          TransactionFactory 接口实现类的全限定名或类型别名代替它们。
        </p>
        <source><![CDATA[public interface TransactionFactory {
  default void setProperties(Properties props) { // 从 3.5.2 开始，该方法为默认方法
    // 空实现
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}]]></source>
        <p>在事务管理器实例化后，所有在 XML 中配置的属性将会被传递给 setProperties()
        方法。你的实现还需要创建一个 Transaction 接口的实现类，这个接口也很简单：</p>
        <source><![CDATA[public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}]]></source>
        <p>使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。</p>
        <p>
          <strong>数据源（dataSource）</strong>
        </p>
        <p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
        <ul>
          <li>大多数 MyBatis
          应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。
          </li>
        </ul>
        <p>有三种内建的数据源类型（也就是 type="[UNPOOLED|POOLED|JNDI]"）：</p>
        <p>
          <strong>UNPOOLED</strong>– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。
          性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：</p>
        <ul>
          <li><code>driver</code> – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。
          </li>
          <li><code>url</code> – 这是数据库的 JDBC URL 地址。
          </li>
          <li><code>username</code> – 登录数据库的用户名。
          </li>
          <li><code>password</code> – 登录数据库的密码。
          </li>
          <li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。
          </li>
          <li><code>defaultNetworkTimeout</code> – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 <code>java.sql.Connection#setNetworkTimeout()</code> 的 API 文档以获取更多信息。
          </li>
        </ul>
        <p>作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：
        </p>
        <ul>
          <li><code>driver.encoding=UTF8</code></li>
        </ul>
        <p>这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为
        <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。
        </p>
        <p>
          <strong>POOLED</strong>– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。
          这种处理方式很流行，能使并发 Web 应用快速响应请求。
        </p>
        <p>除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</p>
        <ul>
          <li><code>poolMaximumActiveConnections</code> – 在任意时间可存在的活动（正在使用）连接数量，默认值：10
          </li>
          <li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。
          </li>
          <li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）
          </li>
          <li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。
          </li>
          <li><code>poolMaximumLocalBadConnectionTolerance</code> – 这是一个关于坏连接容忍度的底层设置，
            作用于每一个尝试从缓存池获取连接的线程。
            如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 <code>poolMaximumIdleConnections</code>
            与 <code>poolMaximumLocalBadConnectionTolerance</code> 之和。 默认值：3（新增于 3.4.5）
          </li>
          <li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。
          </li>
          <li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，需要设置 <code>poolPingQuery</code> 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。
          </li>
          <li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。
          </li>
        </ul>
        <p>
          <strong>JNDI</strong> – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性：
        </p>
        <ul>
          <li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。
          </li>
          <li><code>data_source</code> – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。
          </li>
        </ul>
        <p>和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给 InitialContext。比如：
        </p>
        <ul>
          <li><code>env.encoding=UTF8</code></li>
        </ul>
        <p>这就会在 InitialContext 实例化时往它的构造方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性。
        </p>

        <p>
          你可以通过实现接口 <code>org.apache.ibatis.datasource.DataSourceFactory</code> 来使用第三方数据源实现：
        </p>

        <source><![CDATA[public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}]]></source>

        <p>
          <code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：
        </p>

        <source><![CDATA[import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

  public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
  }
}]]></source>

        <p>为了令其工作，记得在配置文件中为每个希望 MyBatis 调用的 setter 方法增加对应的属性。
        下面是一个可以连接至 PostgreSQL 数据库的例子：</p>

        <source><![CDATA[<dataSource type="org.myproject.C3P0DataSourceFactory">
  <property name="driver" value="org.postgresql.Driver"/>
  <property name="url" value="jdbc:postgresql:mydb"/>
  <property name="username" value="postgres"/>
  <property name="password" value="root"/>
</dataSource>
]]></source>

      </subsection>

      <subsection name="数据库厂商标识（databaseIdProvider）" id="databaseIdProvider">
        <p>
          MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性。
          MyBatis 会加载带有匹配当前数据库 <code>databaseId</code> 属性和所有不带 <code>databaseId</code> 属性的语句。
          如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃。
          为支持多厂商特性，只要像下面这样在 mybatis-config.xml 文件中加入 <code>databaseIdProvider</code> 即可：
        </p>
        <source><![CDATA[<databaseIdProvider type="DB_VENDOR" />
]]></source>

        <p>
          databaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为
          <code>DatabaseMetaData#getDatabaseProductName()</code> 返回的字符串。
          由于通常情况下这些字符串都非常长，而且相同产品的不同版本会返回不同的值，你可能想通过设置属性别名来使其变短：
        </p>

        <source><![CDATA[<databaseIdProvider type="DB_VENDOR">
  <property name="SQL Server" value="sqlserver"/>
  <property name="DB2" value="db2"/>
  <property name="Oracle" value="oracle" />
</databaseIdProvider>]]></source>

        <p>
          在提供了属性别名时，databaseIdProvider 的 DB_VENDOR 实现会将 databaseId
          设置为数据库产品名与属性中的名称第一个相匹配的值，如果没有匹配的属性，将会设置为 “null”。
          在这个例子中，如果 <code>getDatabaseProductName()</code>
          返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。
        </p>

        <p>
          你可以通过实现接口 <code>org.apache.ibatis.mapping.DatabaseIdProvider</code>
          并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider：
        </p>

        <source><![CDATA[public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // 从 3.5.2 开始，该方法为默认方法
    // 空实现
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}]]></source>

      </subsection>

      <subsection name="映射器（mappers）" id="mappers">
        <p>
          既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。
          但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。
          在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉
          MyBatis 到哪里去找映射文件。
          你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。例如：
        </p>
        <source><![CDATA[<!-- 使用相对于类路径的资源引用 -->
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers>]]></source>

        <source><![CDATA[<!-- 使用完全限定资源定位符（URL） -->
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
  <mapper url="file:///var/mappers/PostMapper.xml"/>
</mappers>]]></source>

        <source><![CDATA[<!-- 使用映射器接口实现类的完全限定类名 -->
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
  <mapper class="org.mybatis.builder.PostMapper"/>
</mappers>]]></source>

        <source><![CDATA[<!-- 将包内的映射器接口实现全部注册为映射器 -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>]]></source>

        <p>这些配置会告诉 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL
        映射文件了，也就是接下来我们要讨论的。</p>
      </subsection>
    </section>
  </body>
</document>
