<?xml version="1.0" encoding="UTF-8"?>
<!--

       Copyright 2009-2020 the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>MyBatis 3 | 設定</title>
    <author email="clinton.begin@gmail.com">Clinton Begin</author>
    <author email="harawata@gmail.com">Iwao AVE!</author>
  </properties>

  <body>
    <section name="設定">
      <p>
        MyBatis の設定ファイルには、MyBatis の動作をカスタマイズするための設定やプロパティが含まれています。ファイルの上位レベルの構造は次のようになっています。
      </p>

      <ul>
        <li>
          configuration
          <ul>
            <li><a href="#properties">properties</a></li>
            <li><a href="#settings">settings</a></li>
            <li><a href="#typeAliases">typeAliases</a></li>
            <li><a href="#typeHandlers">typeHandlers</a></li>
            <li><a href="#objectFactory">objectFactory</a></li>
            <li><a href="#plugins">plugins</a></li>
            <li><a href="#environments">environments</a>
              <ul>
                <li>
                  environment
                  <ul>
                    <li>transactionManager</li>
                    <li>dataSource</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#databaseIdProvider">databaseIdProvider</a></li>
            <li><a href="#mappers">mappers</a></li>
          </ul>
        </li>
      </ul>
      <subsection name="properties">
        <p>
          'properties' は、別ファイルで設定することができて上書き可能なプロパティです。よく使われる Java Properties ファイルのインスタンス、または properties 要素の子要素として設定することができます。<br />例：
        </p>
        <source><![CDATA[<properties resource="org/mybatis/example/config.properties">
  <property name="username" value="dev_user"/>
  <property name="password" value="F2Fa3!33TYyg"/>
</properties>]]></source>
        <p>
          読み込んだプロパティは設定ファイル全体を通して使用可能で、変数を動的に設定することができます。<br/>例：
        </p>
        <source><![CDATA[<dataSource type="POOLED">
  <property name="driver" value="${driver}"/>
  <property name="url" value="${url}"/>
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>]]></source>
        <p>
          この例では username と password の値が properties 要素で指定した値に、そして driver と url の値が config.properties 内で定義されている値に置き換えられます。この仕組みによって柔軟な設定が実現可能です。
        </p>
        <p>
          SqlSessionFactoryBuilder.build() メソッドに Properties を渡すこともできます。<br />例：
        </p>
        <source><![CDATA[SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);

// ... or ...

SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);
]]></source>
        <p>
          あるプロパティが複数の箇所で指定されている場合、MyBatis は次の順番で値を読み込みます。
        </p>
        <ul>
          <li>まず最初に properties 要素のボディで指定されたプロパティが読み込まれます。
          </li>
          <li>次に、クラスパスリソースや properties 要素の url 属性で指定された Properties が読み込まれます。先に設定されていた値があれば上書きされます。
          </li>
          <li>そして最後にメソッドの引数として渡された値が読み込まれます。ここでも properties 要素のボディで指定された値や resource/url 属性で指定されたファイルから同じキーを持つ値が読み込まれていた場合には上書きされます。
          </li>
        </ul>
        <p>
          従って、メソッド引数として渡されたプロパティが最も優先度が高く、次に resource/url 属性、最も優先度が低いのは properties 要素のボディで指定された値ということになります。
        </p>

        <p>
          MyBatis 3.4.2以降では、下記に示すようにプレースホルダの中にデフォルト値を指定することができます。
        </p>
        <source><![CDATA[
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- 'username'プロパティが存在しない場合は、 usernameは'ut_user'になる -->
</dataSource>]]></source>

        <p>
          この機能はデフォルトでは無効になっています。もしプレースホルダの中にデフォルト値を指定したい場合は、下記に示すように特別なプロパティを追加して機能を有効化する必要があります。
        </p>

        <source><![CDATA[
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- この機能を有効化 -->
</properties>]]></source>

        <p>
          <span class="label important">NOTE</span> また、既にプロパティキーとして<code>":"</code>を使用(例: <code>db:username</code>)していたり、
          SQL定義の中でOGNL式の三項演算子(例: <code>${tableName != null ? tableName : 'global_constants'}</code>)を使用している場合は、
          下記に示すように特別なプロパティを追加してキーとデフォルト値を分割するための文字を変更する必要があります。
        </p>

        <source><![CDATA[
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- 分割文字を変更 -->
</properties>]]></source>
        <source><![CDATA[
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${db:username?:ut_user}"/>
</dataSource>]]></source>

      </subsection>
      <subsection name="settings">
        <p>
          'settings' は、実行時に MyBatis の動作を変更することができる、非常に重要な調整点です。
          各設定についての説明と設定可能な値およびデフォルト値を以下の表にまとめてあります。
        </p>
        <table>
          <thead>
            <tr>
              <th>設定</th>
              <th>説明</th>
              <th>設定可能な値</th>
              <th>デフォルト値</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                cacheEnabled
              </td>
              <td>
                このコンフィグレーション内で定義されている全てのキャッシュの有効／無効を切り替えるグローバルな設定です。
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                lazyLoadingEnabled
              </td>
              <td>
                Lazy Loading（遅延読み込み）の有効／無効を切り替えるグローバルな設定です。
                無効にした場合、association として指定されているデータは直ちに読み込まれます。
                association 要素で <code>fetchType</code> 属性が指定されている場合はそちらの指定が優先されます。
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                aggressiveLazyLoading
              </td>
              <td>
                この設定が有効の場合、オブジェクトのいずれかのメソッド呼び出しと同時にすべての Lazy loading が実行されます。
                無効の場合は、各プロパティはそれぞれ要求時に読み込まれます（関連項目 <code>lazyLoadTriggerMethods</code> ）。
              </td>
              <td>
                true | false
              </td>
              <td>
                false （3.4.1 以下は true）
              </td>
            </tr>
            <tr>
              <td>
                multipleResultSetsEnabled
              </td>
              <td>
                １つのステートメントから複数の ResultSet を返すことを許可するかどうかを指定します（複数 ResultSet に対応したドライバが必要です）。
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                useColumnLabel
              </td>
              <td>
                列名の代わりに列ラベルを使用します。
                ドライバによって動作が異なります。
                ドライバのドキュメントを参照するか、両方のモードを試して動作を確認してください。
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                useGeneratedKeys
              </td>
              <td>
                JDBC の generated keys サポートを使用するかどうかを指定します。
                Derby のように非互換となっていても動作するドライバに対応するため、true を設定した場合は強制的に generated keys を使用します。
              </td>
              <td>
                true | false
              </td>
              <td>
                False
              </td>
            </tr>
            <tr>
              <td>
                autoMappingBehavior
              </td>
              <td>
                MyBatis の自動マッピング機能（列をフィールド／プロパティに自動的にマッピングする機能）の動作を指定します。
                NONE を指定すると自動マッピングは無効となります。
                PARTIAL が指定された場合、association や collection などを含まない単純な resultMap のみが自動マッピングの対象となります。
                FULL が指定された場合、ネストされた結果などの複雑なものも含めて全てが自動マッピングの対象となります。
              </td>
              <td>
                NONE, PARTIAL, FULL
              </td>
              <td>
                PARTIAL
              </td>
            </tr>
            <tr>
              <td>
                autoMappingUnknownColumnBehavior
              </td>
              <td>
                自動マッピング対象のプロパティが存在しない(又はプロパティ型がサポート外の)カラムを検知した時の動作を指定します。
                <ul>
                  <li><code>NONE</code>: 何もしません</li>
                  <li><code>WARNING</code>: 警告ログを出力します (<code>'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'</code> のログレベルを<code>WARN</code>に設定してください)</li>
                  <li><code>FAILING</code>: 自動マッピング処理をエラーにします。(<code>SqlSessionException</code>が発生します)</li>
                </ul>
              </td>
              <td>
                NONE, WARNING, FAILING
              </td>
              <td>
                NONE
              </td>
            </tr>
            <tr>
              <td>
                defaultExecutorType
              </td>
              <td>
                デフォルトの executor を指定します。
                SIMPLE executor は特別なことは何もしません。
                REUSE executor は PreparedStatement を再利用します。
                BATCH executor はステートメントを再利用してバッチ更新を実行します。
              </td>
              <td>
                SIMPLE
                REUSE
                BATCH
              </td>
              <td>
                SIMPLE
              </td>
            </tr>
            <tr>
              <td>
                defaultStatementTimeout
              </td>
              <td>
                ドライバがデータベースからの応答を待ち続ける秒数（タイムアウト）を設定します。
              </td>
              <td>
                正の整数（単位：秒）
              </td>
              <td>
                なし (null)
              </td>
            </tr>
            <tr>
              <td>
                defaultFetchSize
              </td>
              <td>
                検索結果のフェッチサイズを制御するためのドライバヒントを設定します。
                このパラメータ値はクエリ毎の設定で上書きできます。
              </td>
              <td>
                正の整数
              </td>
              <td>
                なし (null)
              </td>
            </tr>
            <tr>
              <td>
                defaultResultSetType
              </td>
              <td>
                ステートメント毎の設定を省略した場合のスクロール方法を指定します。 (導入されたバージョン: 3.5.2)
              </td>
              <td>
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(指定しない時と同じ動作)
              </td>
              <td>
                なし (null)
              </td>
            </tr>
            <tr>
              <td>
                safeRowBoundsEnabled
              </td>
              <td>
                ネストされたステートメントに対して RowBounds の使用を許可するかどうかを設定します。
                許可する場合は、 false を設定します。
              </td>
              <td>
                true | false
              </td>
              <td>
                False
              </td>
            </tr>
            <tr>
              <td>
                safeResultHandlerEnabled
              </td>
              <td>
                ネストされたステートメントに対して ResultHandler の使用を許可するかどうかを設定します。
                許可する場合は、 false を設定します。
              </td>
              <td>
                true | false
              </td>
              <td>
                True
              </td>
            </tr>
            <tr>
              <td>
                mapUnderscoreToCamelCase
              </td>
              <td>
                データベースにある A_COLUMN のようなアンダースコアを含む列を Camel Case の Java プロパティ aColumn に自動的にマッピングする機能の有効／無効を切り替えます。
              </td>
              <td>
                true | false
              </td>
              <td>
                False
              </td>
            </tr>
            <tr>
              <td>
                localCacheScope
              </td>
              <td>
                MyBatis は循環参照の解決やネストされたクエリのスピード向上のためにローカルキャッシュを使用します。
                デフォルト（SESSION）では同一セッション内の全てのクエリ結果がキャッシュされます。localCacheScope に STATEMENT を設定した場合、ローカルキャッシュはステートメントごとに適用されます。言い換えると、同一 SqlSession に対する複数の呼び出しでデータが共有されることはありません。
              </td>
              <td>
                SESSION | STATEMENT
              </td>
              <td>
                SESSION
              </td>
            </tr>
            <tr>
              <td>
                jdbcTypeForNull
              </td>
              <td>
                引数の JDBC タイプが未指定の場合、null 値に対して割り当てられる JDBC タイプを設定します。
                ドライバによっては列に対する JDBC タイプの指定が必須な場合もありますが、NULL, VARCHAR, OTHER などの汎用の型を指定すれば動作するものもあります。
              </td>
              <td>
                JdbcType 列挙型。一般的には NULL, VARCHAR, OTHER のいずれかです。
              </td>
              <td>
                OTHER
              </td>
            </tr>
            <tr>
              <td>
                lazyLoadTriggerMethods
              </td>
              <td>
                Lazy loading のトリガとなる Object のメソッドを指定します。
              </td>
              <td>
                カンマ区切りのメソッド名のリスト
              </td>
              <td>
                equals,clone,hashCode,toString
              </td>
            </tr>
            <tr>
              <td>
                defaultScriptingLanguage
              </td>
              <td>
                ダイナミック SQL を記述する際のデフォルトの言語を指定します。
              </td>
              <td>
                タイプエイリアスまたは完全修飾クラス名
              </td>
              <td>
                org.apache.ibatis.scripting.xmltags.XMLLanguageDriver
              </td>
            </tr>
            <tr>
              <td>
                defaultEnumTypeHandler
              </td>
              <td>
                Enum型に適用するデフォルトの <code>TypeHandler</code> を指定します。(導入されたバージョン: 3.4.5)
              </td>
              <td>
                タイプエイリアスまたは完全修飾クラス名
              </td>
              <td>
                org.apache.ibatis.type.EnumTypeHandler
              </td>
            </tr>
            <tr>
              <td>
                callSettersOnNulls
              </td>
              <td>
                取得した値が null の場合にセッターあるいは Map の put メソッドを呼び出すかどうかを指定します。
                この設定は Map.keySet() や null 値による初期化を利用している場合に有用です。プリミティブ型（int, boolean, 等）に null がセットされることはありません。
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                returnInstanceForEmptyRow
              </td>
              <td>
                取得した列が全て NULL だった場合、デフォルトの動作では <code>null</code> が返りますが、 returnInstanceForEmptyRow に true を設定すると空のインスタンスが返るようになります。この動作はネストされた結果をマッピングする際にも適用されます。導入されたバージョン: 3.4.2
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                logPrefix
              </td>
              <td>
                MyBatis が出力するログに付加される接頭辞を指定します。
              </td>
              <td>
                任意の文字列
              </td>
              <td>
                未指定
              </td>
            </tr>
            <tr>
              <td>
                logImpl
              </td>
              <td>
                MyBatis のログ出力に使用するロギング実装を指定します。未指定の場合は自動的検出されます。
              </td>
              <td>
                SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
              </td>
              <td>
                未指定
              </td>
            </tr>
            <tr>
              <td>
                proxyFactory
              </td>
              <td>
                Lazy Loading（遅延読み込み）に対応したオブジェクトを生成する際に使用するプロクシツールを指定します。
              </td>
              <td>
                CGLIB | JAVASSIST
              </td>
              <td>
                JAVASSIST (MyBatis 3.3 以上)
              </td>
            </tr>
            <tr>
              <td>
                vfsImpl
              </td>
              <td>
                VFS 実装クラスを指定します。
              </td>
              <td>
                完全修飾クラス名（カンマ区切りで複数指定可能）
              </td>
              <td>
                未指定
              </td>
            </tr>
            <tr>
              <td>
                useActualParamName
              </td>
              <td>
                ステートメントの引数を参照する際、メソッドシグネチャで宣言されている名前で参照できるようにします。
                このオプションを有効にする場合、プロジェクトを Java 8 （コンパイラオプション <code>-parameters</code> 付き）でコンパイルする必要があります。 (導入されたバージョン: 3.4.1)
              </td>
              <td>
                true | false
              </td>
              <td>
                true
              </td>
            </tr>
            <tr>
              <td>
                configurationFactory
              </td>
              <td>
                デシリアライズされたオブジェクトの遅延読込（Lazy loading）を行う際に利用される <code>Configuration</code> のインスタンスを返すクラスを指定します。
                このクラスには次のシグネチャを持つメソッドが定義されている必要があります。 <code>static Configuration getConfiguration()</code>. (導入されたバージョン: 3.2.3)
              </td>
              <td>
                タイプエイリアスまたは完全修飾クラス名
              </td>
              <td>
                未指定
              </td>
            </tr>
            <tr>
              <td>
                shrinkWhitespacesInSql
              </td>
              <td>
                SQL 内の余分な空白文字を削除します。リテラル文字列も対象となる点に注意してください。（導入されたバージョン: 3.5.5）
              </td>
              <td>
                true | false
              </td>
              <td>
                false
              </td>
            </tr>
            <tr>
              <td>
                defaultSqlProviderType
              </td>
              <td>
                SQLを提供するメソッドを保持するSQLプロバイダクラスを指定します(導入されたバージョン: 3.5.6)。
                ここで指定したクラスは、SQLプロバイダアノテーション(例: <code>@SelectProvider</code>)の<code>type</code>(または <code>value</code>) 属性を省略した際に適用されます。
              </td>
              <td>
                タイプエイリアスまたは完全修飾クラス名
              </td>
              <td>
                未指定
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          各種設定を含む settings の例：
        </p>
        <source><![CDATA[<settings>
  <setting name="cacheEnabled" value="true"/>
  <setting name="lazyLoadingEnabled" value="true"/>
  <setting name="multipleResultSetsEnabled" value="true"/>
  <setting name="useColumnLabel" value="true"/>
  <setting name="useGeneratedKeys" value="false"/>
  <setting name="autoMappingBehavior" value="PARTIAL"/>
  <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>
  <setting name="defaultExecutorType" value="SIMPLE"/>
  <setting name="defaultStatementTimeout" value="25"/>
  <setting name="defaultFetchSize" value="100"/>
  <setting name="safeRowBoundsEnabled" value="false"/>
  <setting name="mapUnderscoreToCamelCase" value="false"/>
  <setting name="localCacheScope" value="SESSION"/>
  <setting name="jdbcTypeForNull" value="OTHER"/>
  <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
</settings>]]></source>

      </subsection>
      <subsection name="typeAliases">
        <p>
          タイプエイリアスとは、Java タイプに対する短縮名です。
          XML の中でクラスを指定する際、完全修飾名の記述を最小限で済ませることができます。<br />
          例えば、

        </p>
        <source><![CDATA[<typeAliases>
  <typeAlias alias="Author" type="domain.blog.Author"/>
  <typeAlias alias="Blog" type="domain.blog.Blog"/>
  <typeAlias alias="Comment" type="domain.blog.Comment"/>
  <typeAlias alias="Post" type="domain.blog.Post"/>
  <typeAlias alias="Section" type="domain.blog.Section"/>
  <typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>
]]></source>
        <p>
          上記のようにタイプエイリアスを定義しておくと、
          <code>domain.blog.Blog</code>
          と書く代わりに
          <code>Blog</code>
          と書くことができます。
        </p>
        <p>
          全てのクラスを列挙する代わりにパッケージを指定することもできます。
        </p>
        <source><![CDATA[<typeAliases>
  <package name="domain.blog"/>
</typeAliases>
]]></source>
        <p>
          この場合、
          <code>domain.blog</code>
          というパッケージ内のクラスに対してタイプエイリアスが登録されます。
          例えば
          <code>domain.blog.Author</code>
          というクラスに対しては
          <code>author</code>
          というタイプエイリアスが登録されます。<br />
          <code>@Alias</code>
          アノテーションを使うと、登録されるエイリアス名を指定することもできます。
          次のようになります。
        </p>
        <source><![CDATA[@Alias("author")
public class Author {
    ...
}
]]></source>
        <p>
          汎用の Java タイプには、予めタイプエイリアスが用意されています。<br />
          これらは全て Case Insensitive （大文字小文字を区別しない）です。
          プリミティブ型の場合は特殊な表記が必要となるので注意してください。
        </p>
        <table>
          <thead>
            <tr>
              <th>
                エイリアス
              </th>
              <th>
                Java タイプ
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                _byte
              </td>
              <td>
                byte
              </td>
            </tr>
            <tr>
              <td>
                _long
              </td>
              <td>
                long
              </td>
            </tr>
            <tr>
              <td>
                _short
              </td>
              <td>
                short
              </td>
            </tr>
            <tr>
              <td>
                _int
              </td>
              <td>
                int
              </td>
            </tr>
            <tr>
              <td>
                _integer
              </td>
              <td>
                int
              </td>
            </tr>
            <tr>
              <td>
                _double
              </td>
              <td>
                double
              </td>
            </tr>
            <tr>
              <td>
                _float
              </td>
              <td>
                float
              </td>
            </tr>
            <tr>
              <td>
                _boolean
              </td>
              <td>
                boolean
              </td>
            </tr>
            <tr>
              <td>
                string
              </td>
              <td>
                String
              </td>
            </tr>
            <tr>
              <td>
                byte
              </td>
              <td>
                Byte
              </td>
            </tr>
            <tr>
              <td>
                long
              </td>
              <td>
                Long
              </td>
            </tr>
            <tr>
              <td>
                short
              </td>
              <td>
                Short
              </td>
            </tr>
            <tr>
              <td>
                int
              </td>
              <td>
                Integer
              </td>
            </tr>
            <tr>
              <td>
                integer
              </td>
              <td>
                Integer
              </td>
            </tr>
            <tr>
              <td>
                double
              </td>
              <td>
                Double
              </td>
            </tr>
            <tr>
              <td>
                float
              </td>
              <td>
                Float
              </td>
            </tr>
            <tr>
              <td>
                boolean
              </td>
              <td>
                Boolean
              </td>
            </tr>
            <tr>
              <td>
                date
              </td>
              <td>
                Date
              </td>
            </tr>
            <tr>
              <td>
                decimal
              </td>
              <td>
                BigDecimal
              </td>
            </tr>
            <tr>
              <td>
                bigdecimal
              </td>
              <td>
                BigDecimal
              </td>
            </tr>
            <tr>
              <td>
                object
              </td>
              <td>
                Object
              </td>
            </tr>
            <tr>
              <td>
                map
              </td>
              <td>
                Map
              </td>
            </tr>
            <tr>
              <td>
                hashmap
              </td>
              <td>
                HashMap
              </td>
            </tr>
            <tr>
              <td>
                list
              </td>
              <td>
                List
              </td>
            </tr>
            <tr>
              <td>
                arraylist
              </td>
              <td>
                ArrayList
              </td>
            </tr>
            <tr>
              <td>
                collection
              </td>
              <td>
                Collection
              </td>
            </tr>
            <tr>
              <td>
                iterator
              </td>
              <td>
                Iterator
              </td>
            </tr>
          </tbody>
        </table>
      </subsection>
      <subsection name="typeHandlers">
        <p>
          MyBatis が PreparedStatement のパラメーターをセットするとき、あるいは ResultSet から値を取得するときには、必ずその Java タイプに対応する TypeHandler が使用されます。<br />
          次の表はデフォルトの TypeHandler の一覧です。
        </p>
        <p>
          <span class="label important">NOTE</span>
          バージョン3.4.5より、JSR-310(Date and Time API)のクラスがデフォルトでサポートされました。
        </p>
        <table>
          <thead>
            <tr>
              <th>
                タイプハンドラー
              </th>
              <th>
                Java タイプ
              </th>
              <th>
                JDBC タイプ
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                BooleanTypeHandler
              </td>
              <td>
                Boolean, boolean
              </td>
              <td>
                BOOLEAN 互換の型
              </td>
            </tr>
            <tr>
              <td>
                ByteTypeHandler
              </td>
              <td>
                Byte, byte
              </td>
              <td>
                NUMERIC または BYTE 互換の型
              </td>
            </tr>
            <tr>
              <td>
                ShortTypeHandler
              </td>
              <td>
                Short, short
              </td>
              <td>
                NUMERIC または SMALLINT 互換の型
              </td>
            </tr>
            <tr>
              <td>
                IntegerTypeHandler
              </td>
              <td>
                Integer, int
              </td>
              <td>
                NUMERIC または INTEGER 互換の型
              </td>
            </tr>
            <tr>
              <td>
                LongTypeHandler
              </td>
              <td>
                Long, long
              </td>
              <td>
                NUMERIC または BIGINT 互換の型
              </td>
            </tr>
            <tr>
              <td>
                FloatTypeHandler
              </td>
              <td>
                Float, float
              </td>
              <td>
                NUMERIC または FLOAT 互換の型
              </td>
            </tr>
            <tr>
              <td>
                DoubleTypeHandler
              </td>
              <td>
                Double, double
              </td>
              <td>
                NUMERIC または DOUBLE 互換の型
              </td>
            </tr>
            <tr>
              <td>
                BigDecimalTypeHandler
              </td>
              <td>
                BigDecimal
              </td>
              <td>
                NUMERIC または DECIMAL 互換の型
              </td>
            </tr>
            <tr>
              <td>
                StringTypeHandler
              </td>
              <td>
                String
              </td>
              <td>
                CHAR, VARCHAR
              </td>
            </tr>
            <tr>
              <td>
                ClobReaderTypeHandler
              </td>
              <td>
                java.io.Reader
              </td>
              <td>
                -
              </td>
            </tr>
            <tr>
              <td>
                ClobTypeHandler
              </td>
              <td>
                String
              </td>
              <td>
                CLOB, LONGVARCHAR
              </td>
            </tr>
            <tr>
              <td>
                NStringTypeHandler
              </td>
              <td>
                String
              </td>
              <td>
                NVARCHAR, NCHAR
              </td>
            </tr>
            <tr>
              <td>
                NClobTypeHandler
              </td>
              <td>
                String
              </td>
              <td>
                NCLOB
              </td>
            </tr>
            <tr>
              <td>
                BlobInputStreamTypeHandler
              </td>
              <td>
                java.io.InputStream
              </td>
              <td>
                -
              </td>
            </tr>
            <tr>
              <td>
                ByteArrayTypeHandler
              </td>
              <td>
                byte[]
              </td>
              <td>
                byte ストリーム互換の型
              </td>
            </tr>
            <tr>
              <td>
                BlobTypeHandler
              </td>
              <td>
                byte[]
              </td>
              <td>
                BLOB, LONGVARBINARY
              </td>
            </tr>
            <tr>
              <td>
                DateTypeHandler
              </td>
              <td>
                Date (java.util)
              </td>
              <td>
                TIMESTAMP
              </td>
            </tr>
            <tr>
              <td>
                DateOnlyTypeHandler
              </td>
              <td>
                Date (java.util)
              </td>
              <td>
                DATE
              </td>
            </tr>
            <tr>
              <td>
                TimeOnlyTypeHandler
              </td>
              <td>
                Date (java.util)
              </td>
              <td>
                TIME
              </td>
            </tr>
            <tr>
              <td>
                SqlTimestampTypeHandler
              </td>
              <td>
                Timestamp (java.sql)
              </td>
              <td>
                TIMESTAMP
              </td>
            </tr>
            <tr>
              <td>
                SqlDateTypeHandler
              </td>
              <td>
                Date (java.sql)
              </td>
              <td>
                DATE
              </td>
            </tr>
            <tr>
              <td>
                SqlTimeTypeHandler
              </td>
              <td>
                Time (java.sql)
              </td>
              <td>
                TIME
              </td>
            </tr>
            <tr>
              <td>
                ObjectTypeHandler
              </td>
              <td>
                Any
              </td>
              <td>
                OTHER または指定がない場合
              </td>
            </tr>
            <tr>
              <td>
                EnumTypeHandler
              </td>
              <td>
                Enumeration Type
              </td>
              <td>
                VARCHAR インデックスではなくコードが保存されるので、String 互換の型
              </td>
            </tr>
            <tr>
              <td>
                EnumOrdinalTypeHandler
              </td>
              <td>
                Enumeration Type
              </td>
              <td>
                コードではなく位置（ordinal）が保存されるので、NUMERIC または DOUBLE 互換の型
              </td>
            </tr>
            <tr>
              <td>
                SqlxmlTypeHandler
              </td>
              <td>
                java.lang.String
              </td>
              <td>
                SQLXML
              </td>
            </tr>
            <tr>
              <td>
                InstantTypeHandler
              </td>
              <td>
                java.time.Instant
              </td>
              <td>
                TIMESTAMP
              </td>
            </tr>
            <tr>
              <td>
                LocalDateTimeTypeHandler
              </td>
              <td>
                java.time.LocalDateTime
              </td>
              <td>
                TIMESTAMP
              </td>
            </tr>
            <tr>
              <td>
                LocalDateTypeHandler
              </td>
              <td>
                java.time.LocalDate
              </td>
              <td>
                DATE
              </td>
            </tr>
            <tr>
              <td>
                LocalTimeTypeHandler
              </td>
              <td>
                java.time.LocalTime
              </td>
              <td>
                TIME
              </td>
            </tr>
            <tr>
              <td>
                OffsetDateTimeTypeHandler
              </td>
              <td>
                java.time.OffsetDateTime
              </td>
              <td>
                TIMESTAMP
              </td>
            </tr>
            <tr>
              <td>
                OffsetTimeTypeHandler
              </td>
              <td>
                java.time.OffsetTime
              </td>
              <td>
                TIME
              </td>
            </tr>
            <tr>
              <td>
                ZonedDateTimeTypeHandler
              </td>
              <td>
                java.time.ZonedDateTime
              </td>
              <td>
                TIMESTAMP
              </td>
            </tr>
            <tr>
              <td>
                YearTypeHandler
              </td>
              <td>
                java.time.Year
              </td>
              <td>
                INTEGER
              </td>
            </tr>
            <tr>
              <td>
                MonthTypeHandler
              </td>
              <td>
                java.time.Month
              </td>
              <td>
                INTEGER
              </td>
            </tr>
            <tr>
              <td>
                YearMonthTypeHandler
              </td>
              <td>
                java.time.YearMonth
              </td>
              <td>
                VARCHAR または LONGVARCHAR
              </td>
            </tr>
            <tr>
              <td>
                JapaneseDateTypeHandler
              </td>
              <td>
                java.time.chrono.JapaneseDate
              </td>
              <td>
                DATE
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          標準のタイプハンドラーをオーバーライドしたり、自ら作成したタイプハンドラーを使って未対応あるいは非標準の型を扱うことも可能です。自作する場合は、BaseTypeHandler クラスのサブクラスを作成します。必要に応じて対応する JDBC タイプを指定してください。<br />
          例：
        </p>

        <source><![CDATA[// ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class StringTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
]]></source>

        <source><![CDATA[<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.mybatis.example.ExampleTypeHandler"/>
</typeHandlers>
]]></source>

        <p>
          上記のようにして登録された TypeHandler は、String 型のプロパティと VARCHAR 型の引数または結果のマッピング時に使用されるデフォルトのタイプハンドラーよりも優先的に使用されます。
          MyBatis はデータベースメタデータを参照してタイプを判断している訳ではないので、正しいタイプハンドラーが使用されるよう、パラメーター設定時にフィールドが VARCHAR 型であることを明示する必要があります。MyBatis は実際にステートメントが実行されるまで、データ型のチェックなどは行いません。
        </p>

        <p>
          MyBatis は、このタイプハンドラーの総称型（Genric Type）から適用対象の Java タイプを自動判定しますが、この動作をオーバーライドする方法が２つあります。
        </p>
        <ul>
          <li>typeHandler 要素に javaType 属性を追加する（例：javaType="String"）
          </li>
          <li>TypeHandler の実装クラスに <code>@MappedTypes</code> アノテーションを付加して適用対象の Java タイプのリストを指定します。javaType とアノテーションを両方指定した場合は javaType の指定が優先されます。
          </li>
        </ul>

        <p>typeHandler 要素に jdbcType 属性を追加することで適用対象の JDBC タイプを指定することもできます（例：jdbcType=VARCHAR）。jdbcType 属性が指定されている場合、<code>@MappedJdbcTypes</code> の指定は無視されます。
        </p>
        <p>適用対象の JDBC タイプを指定する方法は二つあります。</p>
        <ul>
          <li>typeHandler 要素に jdbcType 属性を追加する（例：jdbcType=VARCHAR）。</li>
          <li>TypeHandler の実装クラスに <code>@MappedJdbcTypes</code> を付加し、JDBC タイプのリストを指定します。jdbcType 属性が指定されている場合、このアノテーションは無視されます。</li>
        </ul>

        <p>
          <code>ResultMap</code>　でプロパティの指定に <code>typeHandler</code> と <code>jdbcType</code> が明示的に指定されていない場合、パース時点で <code>javaType</code> はプロパティの型から推測可能ですが <code>jdbcType</code> は未知となります。 MyBatis は javaType=[推測された型] と jdbcType=null にマップされた TypeHandler を探します。
          TypeHandler を jdbcType=null にマップするためには <code>@MappedJdbcTypes</code> の <code>includeNullJdbcType</code> 属性に <code>true</code> を指定します。<br />
          MyBatis 3.4.0 以降は javaType に対してマップされている TypeHandler が１つの場合は登録時の jdbcType に関わらずこの TypeHandler が使われるようになりました。
        </p>

        <p>また、MyBatis にタイプハンドラーを自動検出させることもできます。</p>
        <source><![CDATA[<!-- mybatis-config.xml -->
<typeHandlers>
  <package name="org.mybatis.example"/>
</typeHandlers>
]]></source>

        <p>
          自動検出機能を使う場合、適用対象の JDBC タイプの指定はアノテーションで行う必要があります。
        </p>
        <source><![CDATA[@MappedTypes(BigInteger.class)
public class BigIntegerHandler implements TypeHandler<BigInteger> {
   ...
}
]]></source>

        <p>
          複数のクラスを扱う汎用の TypeHandler を作成することもできます。
          引数に Class を受け取るコンストラクタを定義しておくと、MyBatis が TypeHandler のインスタンスを作成する際に実際のクラスが渡されます。
        </p>

        <source><![CDATA[//GenericTypeHandler.java
public class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {

  private Class<E> type;

  public GenericTypeHandler(Class<E> type) {
    if (type == null) throw new IllegalArgumentException("Type argument cannot be null");
    this.type = type;
  }
  ...
]]></source>

        <p>この後の節では汎用の TypeHandler である <code>EnumTypeHandler</code> と <code>EnumOrdinalTypeHandler</code> について解説します。
        </p>

      </subsection>

      <subsection name="Handling Enums">
        <p>
          <code>Enum</code> （列挙型）をマップする場合、
          <code>EnumTypeHandler</code> または <code>EnumOrdinalTypeHandler</code> のどちらかを使うことになります。
        </p>

        <p>例えば数値の丸めモード（java.math.RoundingMode）を格納する場合、デフォルトでは <code>EnumTypeHandler</code> が使われ、各 <code>Enum</code> は名前の文字列（DOWN, HALF_UP, etc.）に変換されます。
        </p>

        <b>他の TypeHandler が特定のクラスを対象としているのに対し、<code>EnumTypeHandler</code> は <code>Enum</code> を継承した任意のクラスを対象とする特別な TypeHandler です。</b>

        <p>では名前以外の値を格納したい場合、例えばデータベース管理者が数値で格納して欲しいと言ってきた場合はどうすれば良いのでしょうか。
        簡単です：設定ファイルの <code>typeHandlers</code> に <code>EnumOrdinalTypeHandler</code> を追加すれば <code>RoundingMode</code> は ordinal の数値に変換されてマップされます。
        </p>
       <source><![CDATA[<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="java.math.RoundingMode"/>
</typeHandlers>
]]></source>
        <p>
          では、同じ <code>Enum</code> を、あるテーブルには文字列として格納し、別のテーブルには数値として格納したいといった場合はどうでしょう。
        </p>
        <p>
          上の設定により自動マッピングでは <code>EnumOrdinalTypeHandler</code> が使われますので、
          <code>EnumTypeHandler</code> を使いたい箇所ではこれを明示的に指定する必要があります。
        </p>
        <p>
          （Mapper ファイルについては次の章で解説していますので、このドキュメントを初めて読む方はこの部分を後回しにした方が良いかも知れません）
        </p>
        <source><![CDATA[<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.apache.ibatis.submitted.rounding.Mapper">
	<resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<result column="funkyNumber" property="funkyNumber"/>
		<result column="roundingMode" property="roundingMode"/>
	</resultMap>

	<select id="getUser" resultMap="usermap">
		select * from users
	</select>
	<insert id="insert">
	    insert into users (id, name, funkyNumber, roundingMode) values (
	    	#{id}, #{name}, #{funkyNumber}, #{roundingMode}
	    )
	</insert>

	<resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap2">
		<id column="id" property="id"/>
		<result column="name" property="name"/>
		<result column="funkyNumber" property="funkyNumber"/>
		<result column="roundingMode" property="roundingMode" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
	</resultMap>
	<select id="getUser2" resultMap="usermap2">
		select * from users2
	</select>
	<insert id="insert2">
	    insert into users2 (id, name, funkyNumber, roundingMode) values (
	    	#{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler}
	    )
	</insert>

</mapper>
]]></source>
        <p>
          typeHandler を指定するため、select 要素では <code>resultType</code> ではなく <code>resultMap</code> を使う必要があります。
        </p>
      </subsection>

      <subsection name="objectFactory">
        <p>
          MyBatis が新しい結果オブジェクトのインスタンスを作るときは ObjectFactory が使われます。
          デフォルトの ObjectFactory は、対象クラスのデフォルトコンストラクタまたは引数付きのコンストラクタを使ってインスタンスを作成するだけです。
          ObjectFactory を自作することで、デフォルトの ObjectFactory の動作をオーバーライドすることもできます。<br />
          例：
        </p>
        <source><![CDATA[// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  public Object create(Class type) {
    return super.create(type);
  }
  public Object create(Class type, List<Class> constructorArgTypes, List<Object> constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }}
]]></source>

        <source><![CDATA[<!-- mybatis-config.xml -->
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
  <property name="someProperty" value="100"/>
</objectFactory>]]></source>
        <p>
          ObjectFactory のインターフェイスは非常にシンプルです。
          ２つある create メソッドのうち１つはデフォルトコンストラクタを扱うもので、もうひとつは引数を取るコンストラクタを扱います。<br />
          もう１つのメソッド setProperties は ObjectFactory を設定するために使うことができます。
          設定ファイルの objectFactory 要素のボディで定義されているプロパティは、ObjectFactory が初期化された後に setProperties メソッドの引数として渡されます。
        </p>

      </subsection>
      <subsection name="plugins">
        <p>
          MyBatis が Mapped Statement を実行する際、いくつかのタイミングで処理をインターセプトすることができます。
          デフォルトでは、プラグインを使って下記のメソッド呼び出しをインターセプトすることができるようになっています。
        </p>
        <ul>
          <li>
            Executor
            (update, query, flushStatements, commit, rollback,
            getTransaction, close,
            isClosed)
          </li>
          <li>
            ParameterHandler
            (getParameterObject, setParameters)
          </li>
          <li>
            ResultSetHandler
            (handleResultSets, handleOutputParameters)
          </li>
          <li>
            StatementHandler
            (prepare, parameterize, batch, update, query)
          </li>
        </ul>
        <p>
          これらのクラスおよびメソッドに関する詳細は、各メソッドのシグネチャや MyBatis のリリースに含まれているソースコードを参照してください。
          単にメソッドの呼び出しを監視する以上のことをしたいのなら、その動作について十分に理解しておく必要があります。
          メソッドのデフォルトの動作を変更したりオーバーライドするということは、MyBatis のコア部分の動作に影響を与える可能性があるということを忘れないでください。これらのクラスやメソッドは非常に低レベルのものなので、プラグインを使うときは注意が必要です。
        </p>
        <p>
          プラグインはとても強力ですが、使うのは比較的簡単です。
          Interceptor インターフェイスを実装したら、インターセプト対象のメソッドシグネチャを指定するだけです。
        </p>

        <source><![CDATA[// ExamplePlugin.java
@Intercepts({@Signature(
  type= Executor.class,
  method = "update",
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  private Properties properties = new Properties();
  public Object intercept(Invocation invocation) throws Throwable {
    // implement pre processing if need
    Object returnObject = invocation.proceed();
    // implement post processing if need
    return returnObject;
  }
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
}]]></source>

        <source><![CDATA[<!-- mybatis-config.xml -->
<plugins>
  <plugin interceptor="org.mybatis.example.ExamplePlugin">
    <property name="someProperty" value="100"/>
  </plugin>
</plugins>]]></source>
        <p>
          上記のプラグインは Executor インスタンスの update メソッド呼び出しをインターセプトします。Executor は、低レベルで mapped statement を実行する内部オブジェクトです。
        </p>
        <p><span class="label important">NOTE</span>
          <strong>Configuration クラスをオーバーライドする
          </strong>
        </p>
        <p>
          プラグインによって MyBatis の動作を変更する以外に、Configuration クラスをオーバーライドすることもできます。
          方法は単純で、Configuration のサブクラスを作って任意のメソッドをオーバーライドし、SqlSessionFactoryBuilder.build(myConfig) のようにして呼び出すだけです。
          繰り返しになりますが、これは MyBatis の動作に重大な影響を与える可能性があるので注意してください。
        </p>
      </subsection>
      <subsection name="environments">
        <p>
          MyBatis では複数の環境設定を定義することができます。これは、同じ SQL Map を複数のデータベースに対して使いたいとき役に立ちます。例えば、開発環境、デモ環境、本番環境で、それぞれ異なる設定場合や、本番環境の同じスキーマを持つ複数のデータベースがあり、両方に対して同じ SQL Map を使いたい場合など、様々な用途が考えられます。
        </p>
        <p>
          <strong>
            ひとつだけ注意しなくてはならないことは、複数の環境設定を扱うことはできますが、一つの SqlSessionFactory インスタンスに対しては一つの環境しか割り当てることができない、ということです。
          </strong>
        </p>
        <p>
          もし二つのデータベースに接続したいのなら、それぞれの接続に対して一つずつ、合計二つの SqlSessionFactory を作る必要があります。データベースが三つなら SqlSessionFactory も三つ必要、といった具合です。実に簡単なルールです。
        </p>
        <ul>
          <li>
            <strong>一つのデータベースにつき、一つの SqlSessionFactory が必要です。
            </strong>
          </li>
        </ul>
        <p>
          SqlSessionFactoryBuilder に envrionment を渡すことで、どの環境に対する SqlSessionFactory をビルドするか指定することができます。
          envrionment を引数に取るシグネチャは下記の２つです。
        </p>

        <source><![CDATA[SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment,properties);]]></source>

        <p>
          environment が省略された場合、デフォルトの environment がロードされます。
        </p>

        <source><![CDATA[SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader,properties);]]></source>

        <p>
          environment の具体的な設定は、environments 要素で行います。
        </p>

        <source><![CDATA[<environments default="development">
  <environment id="development">
    <transactionManager type="JDBC">
      <property name="..." value="..."/>
    </transactionManager>
    <dataSource type="POOLED">
      <property name="driver" value="${driver}"/>
      <property name="url" value="${url}"/>
      <property name="username" value="${username}"/>
      <property name="password" value="${password}"/>
    </dataSource>
  </environment>
</environments>]]></source>
        <p>
          ここでのポイントは以下の通りです。
        </p>
        <ul>
          <li>
            デフォルトの環境 (default="development")
          </li>
          <li>
            各環境のID (id="development")
          </li>
          <li>
            トランザクションマネージャーの設定 (type="JDBC")
          </li>
          <li>
            データソースの設定 (type="POOLED")
          </li>
        </ul>
        <p>
          デフォルト環境と環境 ID は自明です。
          各環境の ID は自由に命名して構いませんが、デフォルトとして指定した環境 ID を必ず定義しておいてください。
        </p>
        <p>
          <strong>transactionManager</strong>
        </p>
        <p>
          MyBatis では二種類のトランザクションマネージャー（JDBC と MANAGED）が用意されています。
        </p>
        <ul>
          <li>
            JDBC - JDBC トランザクションマネージャーは、単純に JDBC のコミットとロールバックの機能を直接利用します。
            この場合、トランザクションのスコープはデータソースから取得した接続に依存します。
          </li>
          <li>
            MANAGED - MANAGED トランザクションマネージャーはコミットもロールバックもしません。
            トランザクションのライフサイクルは全てコンテナ（JEE アプリケーションサーバーなど）が管理することになります。
            MANAGED マネージャーは接続をクローズするのがデフォルトの動作ですが、お使いのコンテナによってはこの動作を変更する必要があります。以下のようにして closeConnection に false を設定してください。
            <source><![CDATA[<transactionManager type="MANAGED">
  <property name="closeConnection" value="false"/>
</transactionManager>]]></source>
          </li>
        </ul>
        <p>
          <span class="label important">NOTE</span>
          MyBatis を Spring と組み合わせて使う場合、トランザクションマネージャーの設定は不要です（設定しても Spring 側で用意したトランザクションマネージャーによって上書きされます）。
        </p>
        <p>
          トランザクションマネージャーに必須のプロパティはありませんが、これらはともにタイプエイリアスです。つまり、TransactionFactory インターフェイスの実装クラスの完全修飾クラス名を指定すれば、MyBatis が用意した二種類のトランザクションマネージャーの代わりに独自に実装したトランザクションマネージャーを利用することが可能です。
        </p>
        <source><![CDATA[public interface TransactionFactory {
  default void setProperties(Properties props) { // Since 3.5.2, change to default method
    // NOP
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}]]></source>
        <p>
          XML ファイルの中で properties 要素で指定されたプロパティは、インスタンスが作成された後、setProperties() メソッドに渡されます。
          トランザクションマネージャーの他に Transaction の実装クラスが必要となります。
          こちらも非常にシンプルなインターフェイスです。
        </p>
        <source><![CDATA[public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}]]></source>
        <p>
          これらのインターフェイスを使えば、MyBatis のトランザクション管理方法を完全にカスタマイズすることが可能です。
        </p>
        <p>
          <strong>dataSource</strong>
        </p>
        <p>
          dataSource 要素では、JDBC 標準の DataSource インターフェイスを実装している JDBC Connection オブジェクトの取得元を指定します。
        </p>
        <ul>
          <li>ほとんどの MyBatis アプリケーションではサンプルのように dataSource を設定することになるはずですが、これは必須というわけではありません。
            ただし、遅延読み込み (Lazy Loading) を利用する場合はこのデータソースを使う必要があります。
          </li>
        </ul>
        <p>MyBatis では、３つのデータソースタイプが用意されています (type="????")
        </p>
        <p>
          <strong>UNPOOLED</strong>
          – このデータソースは、リクエストごとに接続のオープン／クローズを実行します。
          少々遅いですが、即時の接続を必要としないシンプルなアプリケーションの場合は良い選択肢です。
          パフォーマンスに関しては、お使いのデータベースによっても変わってきます。
          接続プールの重要性が低いデータベースの場合はこの設定が最適となります。
          UNPOOLED データソースに対して設定可能なプロパティは下記の通りです。
        </p>
        <ul>
          <li>driver – JDBC ドライバーの完全修飾 Java クラス名（ドライバーに含まれているデータソースクラスではありません）
          </li>
          <li>url – JDBC 接続 URL
          </li>
          <li>username – データベース接続時のユーザー名
          </li>
          <li>password - データベース接続時のパスワード
          </li>
          <li>defaultTransactionIsolationLevel – デフォルトのトランザクション分離レベル
          </li>
          <li>defaultNetworkTimeout – 任意の要求に対するデータベースからの応答待機期限のデフォルト値（ミリ秒）。詳細は <code>java.sql.Connection#setNetworkTimeout()</code> の javadoc 参照。
          </li>
        </ul>
        <p>
          オプションとして、データベースドライバーのプロパティを設定することもできます。
          この場合、プロパティ名に接頭辞 "driver." を付加します。<br />
          例：
        </p>
        <ul>
          <li>driver.encoding=UTF8
          </li>
        </ul>
        <p>
          上記の例では、DriverManager.getConnection(url, driverProperties) メソッド経由でドライバーに渡されるプロパティとして "encoding=UTF8" が追加されます。
        </p>
        <p>
          <strong>POOLED</strong>
          – このデータソースは新規接続開始時に必要となる初期接続と認証の時間を省くため JDBC 接続をプールします。
          Web アプリケーションでは応答速度向上のために良く使われる設定です。
        </p>
        <p>
          POOLED データソースには、UNPOOLED に対して設定可能なプロパティに加えて以下を指定することができます。
        </p>
        <ul>
          <li>poolMaximumActiveConnections – 同時にプールされる接続数の最大値です。
            デフォルト: 10
          </li>
          <li>poolMaximumIdleConnections – 同時にプールされるアイドル接続数の最大値です。
          </li>
          <li>poolMaximumCheckoutTime – プールされた接続が足りなくなった場合、使用中の接続でこの時間を経過しても戻されていない接続があれば強制的に切断されます。
            デフォルト: 20000ms （20秒）
          </li>
          <li>poolTimeToWait – 接続の取得に長時間を要した場合にログを出力し、接続の再取得を試みる機会を与えるための低レベルの設定です（プールが誤って設定された場合、無限に待機状態となってしまうのを防ぐため）。
            デフォルト: 20000ms （20秒）
          </li>
          <li><code>poolMaximumLocalBadConnectionTolerance</code> – This is a low level setting about
            tolerance of bad connections got for any thread. If a thread got a bad connection, it may
            still have another chance to re-attempt to get another connection which is valid. But the
            retrying times should not more than the sum of <code>poolMaximumIdleConnections</code>
            and <code>poolMaximumLocalBadConnectionTolerance</code>.
            Default:
            3 (Since: 3.4.5)
          </li>
          <li>poolPingQuery – プールされた接続が正常で、リクエストを受け付けられる状態にあるかどうか確認するためにデータベースに送信される ping クエリを設定します。
            デフォルトは "NO PING QUERY SET" で、一般的なドライバーであれば問い合わせは失敗し、適切なエラーメッセージが出力されるはずです。
          </li>
          <li>poolPingEnabled – ping クエリの有効／無効を設定します。有効化した場合は poolPingQuery に適切な SQL 文（できるだけ軽いもの）を指定する必要があります。
            デフォルト: false
          </li>
          <li>poolPingConnectionsNotUsedFor – poolPingQuery が実行されるまでの時間を設定します。
            データベース接続がタイムアウトするまでの時間に合わせて設定することで、必要以上に ping クエリが実行されるのを防ぎます。
            デフォルト: 0（poolPingEnabled が true の場合、すべての接続に対して毎回 ping が実行されます）
          </li>
        </ul>
        <p>
          <strong>JNDI</strong>
          – JNDI 経由でデータソースを取得する EJB やアプリケーションサーバーと併用することを想定したデータソースです。
          設定に必要なプロパテイは２つだけです。
        </p>
        <ul>
          <li>initial_context – InitialContext から Context を参照する際に使用されるプロパティです（i.e. initialContext.lookup(initial_context))。
            このプロパティは省略可能で、省略した場合は InitialContext に対して直接 data_source プロパティの参照が実行されます。
          </li>
          <li>data_source – データソースのインスタンを参照するためのコンテクストパスです。
            この参照は initial_context で指定したコンテキストに対して（initial_context が省略された場合は直接 InitialContext に対して）実行されます。
          </li>
        </ul>
        <p>他の DataSource 設定と同様に、"env." という接頭辞を付けることで InitialContext にそのまま渡されるプロパティを設定することができます。<br />
          例：
        </p>
        <ul>
          <li>env.encoding=UTF8
          </li>
        </ul>
        <p>
          上記のように指定すると、"encoding=UTF8" というプロパティが InitialContext のインスタンス生成時にコンストラクタに渡されます。
        </p>

        <p>
          上記以外の DataSource を利用する場合は <code>org.apache.ibatis.datasource.DataSourceFactory</code> インターフェイスを実装したアダプタを作成します。
        </p>

        <source><![CDATA[public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}]]></source>

        <p>
          アダプタを作成する際は <code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> を継承することもできます。
          下記は C3P0 のデータソースを利用する場合の実装例です。
        </p>

        <source><![CDATA[import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

  public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
  }
}]]></source>

        <p>
          作成したアダプタを設定する場合は property 要素を使って必要なプロパティを指定します。
          上述のアダプタを使って PostgreSQL に接続する場合の設定例を挙げておきます。
        </p>

        <source><![CDATA[<dataSource type="org.myproject.C3P0DataSourceFactory">
  <property name="driver" value="org.postgresql.Driver"/>
  <property name="url" value="jdbc:postgresql:mydb"/>
  <property name="username" value="postgres"/>
  <property name="password" value="root"/>
</dataSource>
]]></source>

      </subsection>

      <subsection name="databaseIdProvider">
        <p>
          MyBatis では、利用するデータベースによって異なるステートメントを実行することができます。
          複数データベースサポート機能は、各ステートメントの <code>databaseId</code> 属性によって実現されます。
          MyBatis は定義されているステートメントの中で <code>databaseId</code> 属性が指定されていないステートメントおよび現在の設定と一致する <code>databaseId</code> 属性を持ったステートメントをロードします。
          同じステートメントで、<code>databaseId</code> 属性が指定されているものと指定されていないものが両方定義されていた場合、指定がないステートメントは無視されます。
          複数データベースサポート機能を有効にするには、mybatis-config.xml に <code>databaseIdProvider</code> を追加します。
        </p>

        <source><![CDATA[<databaseIdProvider type="DB_VENDOR" />
]]></source>

    <p>
      databaseIdProvider に DB_VENDOR が指定された場合は VendorDatabaseIdProvider がプロバイダとして使われます。
      この実装は、<code>DatabaseMetaData#getDatabaseProductName()</code> から返される製品名の文字列を「現在の databaseId」として返します。この文字列は長すぎる上にバージョンによって異なる値を返すことがあるので、次のようにプロパティを指定して短い文字列に変換できるようになっています。
    </p>

        <source><![CDATA[<databaseIdProvider type="DB_VENDOR">
  <property name="SQL Server" value="sqlserver"/>
  <property name="DB2" value="db2"/>
  <property name="Oracle" value="oracle" />
</databaseIdProvider>]]></source>

    <p>
      プロパティが指定された場合、VendorDatabaseIdProvider は <code>DatabaseMetaData#getDatabaseProductName()</code> から返された製品名に name 属性で指定された文字列が含まれているかどうかチェックし、含まれている場合は value 属性で指定されている文字列を「現在の databaseId」として返します。指定された name が一つも含まれていない場合は "null" を返します。
      上記の例で、<code>getDatabaseProductName()</code> が "Oracle (DataDirect)" という文字列を返す場合、現在の databaseId は "oracle" となります。
    </p>

    <p>
      DatabaseIdProvider を自作することも可能です。<code>org.apache.ibatis.mapping.DatabaseIdProvider</code> インターフェイスを実装したクラスを作成し、mybatis-config.xml で databaseIdProvider の type 属性の値として、作成したクラスの完全修飾クラス名を指定します。
    </p>

        <source><![CDATA[public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // Since 3.5.2, change to default method
    // NOP
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}]]></source>

      </subsection>

      <subsection name="mappers">
        <p>
          上記のように configuration 要素を設定することで MyBatis の動作設定は完了したので、Mapped SQL Statement の定義を行う準備ができました。
          まず、定義ファイルの場所を指定する必要があります。
          Java にはこのような場合に利用できる自動検出の仕組みがないので、単純にマッピングファイルの場所を指定します。
          相対パスでクラスパスリソースへの参照を指定することもできますし、文字列リテラルでフルパスか完全修飾 URL 形式（file:/// でも可）を指定することも可能です。<br />
          例：
        </p>
        <source><![CDATA[<!-- Using classpath relative resources -->
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers>]]></source>

        <source><![CDATA[<!-- Using url fully qualified paths -->
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
  <mapper url="file:///var/mappers/PostMapper.xml"/>
</mappers>]]></source>

        <source><![CDATA[<!-- Using mapper interface classes -->
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
  <mapper class="org.mybatis.builder.PostMapper"/>
</mappers>]]></source>

        <source><![CDATA[<!-- Register all interfaces in a package as mappers -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>]]></source>

        <p>
          これらの設定は、単に MyBatis にマッピングファイルの場所を伝えているだけで、その先は各 SQL マップファイルの定義次第ということになります（次の章で説明します）。
        </p>
      </subsection>
    </section>
  </body>
</document>
