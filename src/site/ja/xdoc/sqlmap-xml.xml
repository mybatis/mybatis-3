<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2010-2012 the original author or authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!-- version: $Id$ -->

<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>MyBatis 3 | Mapper XML ファイル</title>
    <author email="clinton.begin@gmail.com">Clinton Begin</author>
    <author email="harawata@gmail.com">Iwao AVE!</author>
  </properties>

  <body>
    <section name="Mapper XML ファイル">
      <p>
        Mapped Statement こそ MyBatis のパワーの源です。
        ここで魔法がかけられているのです。
        Mapper XML ファイルは、そのパワーの割に比較的シンプルです。
        JDBC で同じ処理を書くのと比べると、９割以上のコードが省略できると思います。
        MyBatis は SQL にフォーカスし、可能な限りあなたの邪魔をしないように設計されています。
      </p>
      <p>
        Mapper XML ファイルの第一階層の要素は下記のとおりです（この順番で定義する必要があります）。
      </p>
      <ul>
        <li>
          <code>cache</code>
          – 指定されたネームスペースに対するキャッシュの設定です。
        </li>
        <li>
          <code>cache-ref</code>
          – 別のネームスペースで定義されているキャッシュ設定を参照します。
        </li>
        <li>
          <code>resultMap</code>
          – データベースから取得した結果セットを Java オブジェクトにマッピングするための情報を記述する、最も複雑で強力な要素です。
        </li>
        <li>
          <strike>
            <code>parameterMap</code>
            – 非推奨！ パラメーターをマップする古い方法です。インラインパラメーターの使用が推奨されており、この要素は将来削除される予定です。ここでは解説しません。
          </strike>
        </li>
        <li>
          <code>sql</code>
          – 他のステートメントから参照することができる、再利用可能な SQL 文字列です。
        </li>
        <li>
          <code>insert</code>
          – マップされた INSERT ステートメントです。
        </li>
        <li>
          <code>update</code>
          – マップされた UPDATE ステートメントです。
        </li>
        <li>
          <code>delete</code>
          – マップされた DELETE ステートメントです。
        </li>
        <li>
          <code>select</code>
          – マップされた SELECT ステートメントです。
        </li>
      </ul>
      <p>
        次の章では、それぞれの要素について詳しく説明していきます。
        まずはステートメントからです。
      </p>

      <subsection name="select">
        <p>
          select ステートメントは、MyBatis で最も頻繁に使われる要素のひとつです。
          データを取り出すことができてはじめてデータベースにデータを追加する意味があるので、ほとんどのアプリケーションではデータを変更するよりも検索する回数の方が多くなります。
          insert, update, delete のそれぞれに対して、多くの select があるはずです。
          これは MyBatis の大原則の一つであり、クエリ発行と結果のマッピングに注力している理由でもあります。
          シンプルなケースでは、select 要素は非常に簡単です。１つ例を挙げましょう。
        </p>

        <source><![CDATA[<select id="selectPerson" parameterType="int" resultType="hashmap">
  SELECT * FROM PERSON WHERE ID = #{id}
</select>]]></source>

        <p>
          これは selectPerson というステートメントで、int （または Integer）型の引数を取り、列名を key、値を value として保持する HashMap を返します。
        </p>

        <p>
          パラメーターは次のように記述されています。
        </p>

        <source><![CDATA[#{id}]]></source>

        <p>
          このように記述すると、MyBatis は PreparedStatement のパラメーターを作成します。
          JDBC では PreparedStatement を作成する場合の '?' に相当します。
        </p>

        <source><![CDATA[// Similar JDBC code, NOT MyBatis…
String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);]]></source>

        <p>
          JDBC 単体で select 結果を展開してオブジェクトのインスタンスにマップするためにはもっと多くのコードが必要ですが、MyBatis を使えばそうしたコードは書かずに済みます。
          パラメーターと結果のマッピングについては他にも知っておくべきことが数多くあります。
          これらについては、後ほどそれぞれに独立した章を用意して説明します。
        </p>

        <p>
          ステートメントに関して細かい設定ができるように、select 要素には多くの属性があります。
        </p>

        <source><![CDATA[<select
  id="selectPerson"
  parameterType="int"
  parameterMap="deprecated"
  resultType="hashmap"
  resultMap="personResultMap"
  flushCache="false"
  useCache="true"
  timeout="10000"
  fetchSize="256"
  statementType="PREPARED"
  resultSetType="FORWARD_ONLY">]]></source>

        <table>
          <caption>Select Attributes</caption>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>id</td>
              <td>このネームスペース内で固有な識別子。ステートメントを参照する際に使用します。</td>
            </tr>
            <tr>
              <td>parameterType</td>
              <td>このステートメントに渡される引数の型。完全修飾クラス名またはエイリアス。TypeHandler は実際の引数に応じて自動的に導出されるため、この属性は省略可能です。デフォルト値：未設定
              </td>
            </tr>
            <tr>
              <td>
                <strike><code>parameterMap</code></strike>
              </td>
              <td>
                <strike>
                  別の場所で定義されている <code>parameterMap</code> を参照する非推奨の方法。インラインパラメーターマッピングと <code>parameterType</code> 属性を使用してください。
                </strike>
              </td>
            </tr>
            <tr>
              <td>resultType</td>
              <td>
                このステートメントから返されるオブジェクトの型。完全修飾クラス名またはエイリアス。ステートメントがコレクションを返す場合は、コレクションの型ではなくコレクションに含まれるオブジェクトの型を指定する必要があります。<br />
                <code>resultType</code> と <code>resultMap</code> は、どちらか一方のみ指定可能です。
              </td>
            </tr>
            <tr>
              <td>resultMap</td>
              <td>
                別の場所で定義されている <code>resultMap</code> を参照します。 Result Map は MyBatis の中でも最も強力な機能で、深く理解すれば複雑なマッピングが必要となる様々なケースに対応することができます。<br />
                <code>resultType</code> と <code>resultMap</code> は、どちらか一方のみ指定可能です。
              </td>
            </tr>
            <tr>
              <td>flushCache</td>
              <td>
                true を指定した場合、ステートメント実行時にローカルキャッシュおよび２次キャッシュがフラッシュ（＝クリア）されます。select ステートメントの場合、デフォルト値は <code>false</code> です。
              </td>
            </tr>
            <tr>
              <td>useCache</td>
              <td>
                true を指定した場合、ステートメントの結果が２次キャッシュに保存されます。select ステートメントの場合、デフォルト値は <code>true</code> です。
              </td>
            </tr>
            <tr>
              <td>timeout</td>
              <td>
                ドライバーがデータベースからの応答が戻らない場合に、ドライバーが例外を投げるまでの最大待機時間（単位：秒）を設定します。デフォルトは未設定（ドライバー依存）です。
              </td>
            </tr>
            <tr>
              <td>fetchSize</td>
              <td>
                ドライバーが結果を返す際に内部的に使用するキャッシュのサイズを指定します（ドライバーに対するヒントです）。デフォルトは未指定（ドライバー依存）です。
              </td>
            </tr>
            <tr>
              <td>statementType</td>
              <td>
                 MyBatis がクエリを実行する際に使用する Statement の種類を指定します。設定可能な値は <code>STATEMENT</code>, <code>PREPARED</code>, <code>CALLABLE</code> で、それぞれ <code>Statement</code>, <code>PreparedStatement</code>, <code>CallableStatement</code> が使用されます。デフォルトは <code>PREPARED</code> です。
              </td>
            </tr>
            <tr>
              <td><code>resultSetType</code></td>
              <td>
                <code>FORWARD_ONLY</code>, <code>SCROLL_SENSITIVE</code>, <code>SCROLL_INSENSITIVE</code> のいずれかを指定します。デフォルトは未指定（ドライバー依存）です。
              </td>
            </tr>
            <tr>
              <td><code>databaseId</code></td>
              <td>databaseIdProvider が設定されている場合、MyBatis は定義されているステートメントの中で <code>databaseId</code> 属性が指定されていないステートメントおよび現在の設定と一致する <code>databaseId</code> 属性を持ったステートメントをロードします。
                同じステートメントで、<code>databaseId</code> 属性が指定されているものと指定されていないものが両方定義されていた場合、指定がないステートメントは無視されます。
              </td>
            </tr>
            <tr>
              <td><code>resultOrdered</code></td>
              <td>この属性は結果がネストされた select ステートメントでのみ有効です。true が設定された場合、MyBatis はクエリの結果が正しい順番にソートされているという前提でマッピングを実行します。これによりメモリ消費を抑えることができます。
                デフォルトは <code>false</code> です。
              </td>
            </tr>
            <tr>
              <td><code>resultSets</code></td>
              <td>複数の ResultSet を利用する場合にのみ有効です。ステートメントが返す ResultSet にそれぞれ任意の名前を付けてリストアップします。名前はカンマで区切ります。
              </td>
            </tr>
          </tbody>
        </table>
      </subsection>

      <subsection name="insert, update and delete">
        <p>
          データを変更するステートメントである insert, update, delete は、非常によく似た実装となっています。
        </p>

        <source><![CDATA[<insert
  id="insertAuthor"
  parameterType="domain.blog.Author"
  flushCache="true"
  statementType="PREPARED"
  keyProperty=""
  keyColumn=""
  useGeneratedKeys=""
  timeout="20">

<update
  id="insertAuthor"
  parameterType="domain.blog.Author"
  flushCache="true"
  statementType="PREPARED"
  timeout="20">

<delete
  id="insertAuthor"
  parameterType="domain.blog.Author"
  flushCache="true"
  statementType="PREPARED"
  timeout="20">]]></source>

        <table>
          <caption>Insert, Update and Delete Attributes</caption>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>id</td>
              <td>このネームスペース内で固有な識別子。ステートメントを参照する際に使用します。</td>
            </tr>
            <tr>
              <td>parameterType</td>
              <td>このステートメントに渡される引数の型。完全修飾クラス名またはエイリアス。TypeHandler は実際の引数に応じて自動的に導出されるため、この属性は省略可能です。デフォルト値：未設定
              </td>
            </tr>
            <tr>
              <td>
                <strike><code>parameterMap</code></strike>
              </td>
              <td>
                <strike>
                  別の場所で定義されている parameterMap を参照する非推奨の方法。インラインパラメーターマッピングと parameterType 属性を使用してください。
                </strike>
              </td>
            </tr>
            <tr>
              <td>flushCache</td>
              <td>
                true を指定した場合、ステートメント実行時にローカルキャッシュおよび２次キャッシュがフラッシュ（＝クリア）されます。insert, update, delete ステートメントの場合、デフォルト値は <code>true</code> です。
              </td>
            </tr>
            <tr>
              <td>timeout</td>
              <td>
                ドライバーがデータベースからの応答が戻らない場合に、ドライバーが例外を投げるまでの最大待機時間を設定します。デフォルトは未設定（ドライバー依存）です。
              </td>
            </tr>
            <tr>
              <td>statementType</td>
              <td>
                 MyBatis がクエリを実行する際に使用する Statement の種類を指定します。設定可能な値は STATEMENT, PREPARED, CALLABLE で、それぞれ Statement, PreparedStatement, CallableStatement が使用されます。デフォルトは PREPARED です。
              </td>
            </tr>
            <tr>
              <td>useGeneratedKeys</td>
              <td>（insert, update のみ）MyBatis に対して、JDBC の getGeneratedKeys メソッドを使ってデータベース側で自動生成されたキーを取得するよう指示します（例えば MySQL や SQL Server のような RDBMS における auto increment が設定された列の値が取得できます）。デフォルト値は false です。
              </td>
            </tr>
            <tr>
              <td>keyProperty</td>
              <td>
                （insert, update のみ）getGeneratedKeys メソッドまたは selectKey 要素で指定されたクエリによって取得したキーの値は、ここで指定したプロパティにセットされます。カンマ区切りでの複数指定にも対応しています。
              </td>
            </tr>
            <tr>
              <td>keyColumn</td>
              <td>（insert, update のみ）テーブル内で自動生成が設定されている列の名前を指定します。この設定は、特定のデータベース（例えば PostgreSQL）で、テーブルの先頭以外の列にキーの自動生成が設定されている場合にのみ必要となります。カンマ区切りでの複数指定にも対応しています。
              </td>
            </tr>
            <tr>
              <td><code>databaseId</code></td>
              <td>databaseIdProvider が設定されている場合、MyBatis は定義されているステートメントの中で <code>databaseId</code> 属性が指定されていないステートメントおよび現在の設定と一致する <code>databaseId</code> 属性を持ったステートメントをロードします。
                同じステートメントで、<code>databaseId</code> 属性が指定されているものと指定されていないものが両方定義されていた場合、指定がないステートメントは無視されます。
              </td>
            </tr>
          </tbody>
        </table>

        <p>以下、insert, update, delete ステートメントの例をいくつか挙げておきます。</p>

        <source><![CDATA[<insert id="insertAuthor">
  insert into Author (id,username,password,email,bio)
  values (#{id},#{username},#{password},#{email},#{bio})
</insert>

<update id="updateAuthor">
  update Author set
    username = #{username},
    password = #{password},
    email = #{email},
    bio = #{bio}
  where id = #{id}
</update>

<delete id="deleteAuthor">
  delete from Author where id = #{id}
</delete>]]></source>

        <p>
          前述のように、insert は自動生成されたキーを扱うため、追加の属性や子要素を持つことができるようになっています。
        </p>

        <p>
          お使いのデータベースがキーの自動生成に対応しているなら（MySQL や SQL Server は対応しています）、単純に useGeneratedKeys に true を設定し、keyPropoerty でキーが格納されるプロパティを指定するだけです。
          例えば上記の Author テーブルで id 列に自動生成が設定されていた場合、ステートメントは次のように書くことができます。
        </p>

        <source><![CDATA[<insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id">
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
</insert>]]></source>

        <p>
          主にキーの自動生成に対応していないデータベースやドライバーのため、MyBatis はもうひとつ別の方法を提供しています。
        </p>

        <p>
          全く実用的ではありませんが、MyBatis の柔軟さを示す意味も込めて、ID をランダムに生成する例を挙げておきます。
        </p>
        <source><![CDATA[<insert id="insertAuthor">
  <selectKey keyProperty="id" resultType="int" order="BEFORE">
    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1
  </selectKey>
  insert into Author
    (id, username, password, email,bio, favourite_section)
  values
    (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})
</insert>]]></source>
        <p>
          上記の例では、最初に selectKey ステートメントが実行され、Author オブジェクトの id プロパティに生成された乱数がセットされます。
          次に、insert ステートメントが実行されます。
          こうすることで、Java 側でややこしいコードを書かなくても自動生成と同様の結果を得ることができるようになっています。
        </p>
        <p>
          selectKey 要素は次の属性を持っています。
        </p>
        <source><![CDATA[<selectKey
  keyProperty="id"
  resultType="int"
  order="BEFORE"
  statementType="PREPARED">]]></source>

        <table>
          <caption>selectKey Attributes</caption>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>keyProperty</td>
              <td>selectKey ステートメントの結果がセットされるプロパティを指定します。カンマ区切りでの複数指定にも対応しています。</td>
            </tr>
            <tr>
              <td>keyColumn</td>
              <td>プロパティに対応する結果セット中の列名を指定します。カンマ区切りでの複数指定にも対応しています。</td>
            </tr>
            <tr>
              <td>resultType</td>
              <td>
                結果の型を指定します。ほとんどの場合、MyBatis は自動的に型を推測することができますが、念のため設定しておいても害はありません。文字列も含めて、任意の単純型を指定することができます。複数の列が自動生成対象となっている場合、対応するプロパティを持つクラスあるいは Map を指定することができます。
              </td>
            </tr>
            <tr>
              <td>order</td>
              <td>
                BEFORE または AFTER が指定可能です。BEFORE を指定した場合、最初に selectKey を実行して keyProperty に取得したキーを設定し、その後で insert を実行します。
                AFTER を指定した場合、先に insert を実行してから selectKey ステートメントを実行します。
                後者は、Oracle のように insert ステートメントの中に sequence の呼び出しを含むようなケースで良く使われます。
              </td>
            </tr>
            <tr>
              <td>statementType</td>
              <td>
                select などと同じく Statement の種類を指定することができます。設定可能な値は STATEMENT, PREPARED, CALLABLE で、それぞれ Statement, PreparedStatement, CallableStatement が使用されます。
              </td>
            </tr>
          </tbody>
        </table>
      </subsection>

      <subsection name="sql">
        <p>
          この要素を使うと、再利用可能な SQL コードのスニペットを定義しておいて、他のステートメントにインクルードすることができます。<br />
          例：
        </p>

        <source><![CDATA[<sql id="userColumns"> id,username,password </sql>]]></source>

        <p>
          上記の SQL スニペットを他のステートメントにインクルードするには、次のように記述します。
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="map">
  select <include refid="userColumns"/>
  from some_table
  where id = #{id}
</select>]]></source>
      </subsection>

      <subsection name="Parameters">
        <p>
          これまでのステートメントの例では、すべて単純なパラメーターを利用していました。パラメーターは非常に強力な要素です。単純な用途（たぶん全用途の９割くらい）については、特筆すべきことはありません。<br />
          例：
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="User">
  select id, username, password
  from users
  where id = #{id}
</select>]]></source>

        <p>
          上記は、名前を指定してパラメーターを参照するごく簡単な例です。parameterType が int と指定されていますので、好きな名前を使って参照することができます。プリミティブ型や Integer, String などの単純型はプロパティを持たないので、引数の参照はパラメーターの値そのものに置き換えられます。<br />
          パラメーターとして複合型を渡した場合はもう少し複雑です。次の例を見てください。
        </p>

        <source><![CDATA[<insert id="insertUser" parameterType="User">
  insert into users (id, username, password)
  values (#{id}, #{username}, #{password})
</insert>]]></source>

        <p>
          User 型のオブジェクトがパラメーターとしてステートメントに渡されると、id, username, password の各プロパティが参照され、その値が PreparedStatement の引数として渡されます。
        </p>

        <p>
          このように、ステートメントにパラメーターを渡すだけならとても簡単です。しかし、パラメーターマップには更にいろいろな機能があります。
        </p>

        <p>
          まず、他と同じ様に、より具体的に型を指定することができます。
        </p>

        <source><![CDATA[#{property,javaType=int,jdbcType=NUMERIC}]]></source>

        <p>
          他と同様、ほとんどの場合 javaType は自動的に検出されますが、例外は HashMap です。パラメーターとして HashMap を使う場合は、正しい TypeHandler が使用されるよう javaType を指定してください。
        </p>

        <p>
          <span class="label important">重要</span> JDBC の仕様上、値として null を設定する場合は JDBC タイプが必須となります。
          詳しくは PreparedStatement.setNull() メソッドの javadoc を参照してください。
        </p>

        <p>
          タイプハンドラーの完全修飾クラス名またはエイリアスを指定して、特定のタイプハンドラーを割り当てることもできます。
        </p>

        <source><![CDATA[#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}]]></source>

        <p>
          だんだんゴチャゴチャしてきましたが、実際のところ、これらの属性を指定することは滅多にないと思います。
        </p>

        <p>
          数値型に関しては、有効桁数を指定するための numericScale という属性もあります。
        </p>

        <source><![CDATA[#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}]]></source>

        <p>
          最後になりますが、mode 属性で IN, OUT, INOUT パラメーターを指定することができます。
          OUT または INOUT の場合は、パラメーターオブジェクトのプロパティの値が変更されます。
          mode が OUT または INOUT で jdbcType が CURSOR（Oracle の REFCURSOR）の場合は、ResultSet とパラメーターの型をマッピングする resultMap を指定する必要があります。ただし jdbcType として CURSOR を指定した場合 javaType には自動的に ResultSet が設定されますので、javaType の指定は省略可能です。
        </p>

        <source><![CDATA[#{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}]]></source>

        <p>
          MyBatis ではより高度な struct のようなデータ型もサポートされていますが、OUT パラメーターを登録するときに型名を指定する必要があります。
        </p>

        <source><![CDATA[#{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap}]]></source>

        <p>
          このように多くの強力なオプションがあるわけですが、ほとんどの場合、単純にプロパティ名を指定すれば、後は MyBatis がよきに計らってくれるはずです。
          あとは、null が設定可能な列に対して jdbcType を指定するくらいでしょう。
        </p>

        <source><![CDATA[#{firstName}
#{middleInitial,jdbcType=VARCHAR}
#{lastName}]]></source>

        <p>
          文字列代入
        </p>

        <p>
          デフォルトでは、#{} という表記を使うと PreparedStatement のプロパティが生成され、PreparedStatement の引数（? の部分）に対して安全な値が設定されるようになっています。
          これは安全かつ高速なので、ほとんどすべてのケースで推奨される方法ですが、時には文字列をそのまま SQL 文に挿入した方が都合が良い場合があります。例えば ORDER BY 句は以下のように記述できます。
        </p>

        <source><![CDATA[ORDER BY ${columnName}]]></source>

        <p>
          この場合、MyBatis は引数として渡された文字列を変更したりエスケープしたりしません。
        </p>

        <p>
          <span class="label important">重要</span> この方法を使って、ユーザーが入力した文字列を直接 SQL 文に代入するのは危険です。SQL インジェクションの原因となる可能性がありますので、ユーザーによる入力を受け付けないようにしておくか、常にプログラム側で独自にエスケープやチェックの処理を行うようにしてください。
        </p>
      </subsection>

      <subsection name="Result Maps">
        <p>
          MyBatis の中で最も重要かつ強力なのが resultMap 要素です。resultMap のおかげで、JDBC を使って ResultSet からデータを取得する場合に書かなくてはならないコードの９割を省くことができ、またときには JDBC がサポートすらしていないことも可能となるのです。
          実際、複雑なクエリの結果を結合してマッピングするコードを書く場合、数千行ものコードになってしまう場合もあります。
          ResultMap は、簡単なステートメントなら明示的にマッピングな記述を省略でき、複雑なステートメントの場合でもオブジェクト同士の関連付けを行うための必要最小限のコードのみを記述すれば良いように設計されています。
        </p>

        <p>
          明示的な resultMap を必要としない、簡単な Mapped Statement については既に例として出てきました。<br />
          例：
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="map">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>]]></source>

        <p>
          この例の場合、resultType で指定された通り、すべての列が自動的に HashMap のキーとしてマップされます。
          便利な時もありますが、HashMap は良いドメインモデルとは言えません。
          ほとんどのアプリケーションではドメインモデルとして JavaBeans や POJO (Plain Old Java Objects) を使っていると思います。MyBatis はどちらもサポートしています。<br />
          次のような JavaBean があったとします。
        </p>
        <source><![CDATA[package com.someapp.model;
public class User {
  private int id;
  private String username;
  private String hashedPassword;
  
  public int getId() {
    return id;
  }
  public void setId(int id) {
    this.id = id;
  }
  public String getUsername() {
    return username;
  }
  public void setUsername(String username) {
    this.username = username;
  }
  public String getHashedPassword() {
    return hashedPassword;
  }
  public void setHashedPassword(String hashedPassword) {
    this.hashedPassword = hashedPassword;
  }
}]]></source>

        <p>
          JavaBeans の仕様によれば、上記のクラスは３つのプロパティ id, username, hashedPassword を持っているということになります。
          これらのプロパティは、先に挙げた select ステートメントの中で指定されている列名と一致しています。
        </p>

        <p>
          このような条件を満たす JavaBean であれば、HashMap のときと同じように ResultSet にマップすることができます。
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="com.someapp.model.User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>]]></source>

        <p>
          タイプエイリアスを使えば何度も完全修飾クラス名を入力しなくて済む、ということも思い出してください。
        </p>

        <source><![CDATA[<!-- In Config XML file -->
<typeAlias type="com.someapp.model.User" alias="User"/>

<!-- In SQL Mapping XML file -->
<select id="selectUsers" resultType="User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>]]></source>

        <p>
          こうしたケースでは、名前に基づいて列を JavaBean にマップするための ResultMap が MyBatis によって自動的に作成されます。
          もし列名が一致しない場合、select 文で列に別名をつけることで対応可能です（列の別名は標準 SQL の機能です）。
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="User">
  select
    user_id     as "id",
    user_name     as "userName",
    hashed_password   as "hashedPassword"
  from some_table
  where id = #{id}
</select>]]></source>

        <p>
          ResultMap の素晴らしいところは、まだ一つの例も挙げていないにも関わらず、あなたは既にその多くを学んでいるということです。
          これらのシンプルなケースでは既に見てきた以上のことは何も必要ありません。
          列名の不一致を解消するもう一つの方法でもありますが、この最後のサンプルで resultMap を明示的に定義したらどうなるか見てみましょう。
        </p>

        <source><![CDATA[<resultMap id="userResultMap" type="User">
  <id property="id" column="user_id" />
  <result property="username" column="username"/>
  <result property="password" column="password"/>
</resultMap>]]></source>

        <p>
          そして、resultMap 属性を使って定義した ResultMap を参照するステートメントは以下のようになります（resultType 属性は削除しています）。
        </p>

        <source><![CDATA[<select id="selectUsers" resultMap="userResultMap">
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
</select>]]></source>

        <p>
          全てがこんなに簡単なら良いのでしょうが、そう甘くはありません。
        </p>
      </subsection>

      <subsection name="高度な結果マッピング">

        <p>
          MyBatis は「データベースは必ずしも希望通りに定義されている訳ではない」という思想に基づいて設計されています。
          すべてのデータベースが完全な第三正規形あるいは BCNF なら最高ですが、実際はそうではありません。
          また、たったひとつで全てのアプリケーションに適合できるようなデータベースを作ることができたら素晴らしいですが、これも現実とは異なります。
          こうした問題に対する MyBatis の答えが Result Map です。
        </p>

        <p>例えば、こんなステートメントをどうやってマップすれば良いのでしょう？</p>

        <source><![CDATA[<!-- Very Complex Statement -->
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">
  select
    B.id as blog_id,
    B.title as blog_title,
    B.author_id as blog_author_id,
    A.id as author_id,
    A.username as author_username,
    A.password as author_password,
    A.email as author_email,
    A.bio as author_bio,
    A.favourite_section as author_favourite_section,
    P.id as post_id,
    P.blog_id as post_blog_id,
    P.author_id as post_author_id,
    P.created_on as post_created_on,
    P.section as post_section,
    P.subject as post_subject,
    P.draft as draft,
    P.body as post_body,
    C.id as comment_id,
    C.post_id as comment_post_id,
    C.name as comment_name,
    C.comment as comment_text,
    T.id as tag_id,
    T.name as tag_name
  from Blog B
    left outer join Author A on B.author_id = A.id
    left outer join Post P on B.id = P.blog_id
    left outer join Comment C on P.id = C.post_id
    left outer join Post_Tag PT on PT.post_id = P.id
    left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
</select>]]></source>

        <p>
          あなたはおそらく、Author によって書かれた、たくさんの Post を持つ Blog といったようなオブジェクトモデルにマップしたいと考えるでしょう。
          次に上げるのは、複雑な ResultMap の完全な例です（Author, Blog, Post, Comments, Tags はすべてタイプエイリアスとします）。
          後ほどひとつずつ説明しますが、とりあえず目を通してみてください。
          最初は難解に思えるかも知れませんが、実際は非常にシンプルです。
        </p>

        <source><![CDATA[<!-- Very Complex Result Map -->
<resultMap id="detailedBlogResultMap" type="Blog">
  <constructor>
    <idArg column="blog_id" javaType="int"/>
  </constructor>
  <result property="title" column="blog_title"/>
  <association property="author" javaType="Author">
    <id property="id" column="author_id"/>
    <result property="username" column="author_username"/>
    <result property="password" column="author_password"/>
    <result property="email" column="author_email"/>
    <result property="bio" column="author_bio"/>
    <result property="favouriteSection" column="author_favourite_section"/>
  </association>
  <collection property="posts" ofType="Post">
    <id property="id" column="post_id"/>
    <result property="subject" column="post_subject"/>
    <association property="author" javaType="Author"/>
    <collection property="comments" ofType="Comment">
      <id property="id" column="comment_id"/>
    </collection>
    <collection property="tags" ofType="Tag" >
      <id property="id" column="tag_id"/>
    </collection>
    <discriminator javaType="int" column="draft">
      <case value="1" resultType="DraftPost"/>
    </discriminator>
  </collection>
</resultMap>]]></source>

        <p>
          resultMap 要素には多くの子要素や階層構造があり、それぞれについて多少説明が必要です。
          以下は resultMap 要素の構成要素です。
        </p>

        <h4>resultMap</h4>
        <ul>
          <li>
            <code>constructor</code> - クエリ結果をコンストラクタに渡してクラスのインスタンスを作成する場合に使用します。
            <ul>
              <li><code>idArg</code> - このコンストラクタ引数が ID であることを明示します。ID 列を明示することによって全体のパフォーマンスが向上します。</li>
              <li><code>arg</code> - 通常のコンストラクタ引数です。</li>
            </ul>
          </li>
          <li><code>id</code> – このフィールドまたはプロパティが ID であることを明示します。ID を明示することによって全体のパフォーマンスが向上します。</li>
          <li><code>result</code> – フィールドまたは JavaBean のプロパティにセットされる通常のデータです。</li>
          <li>
            <code>association</code> – 複雑型のアソシエーションを定義します。多くのマッピングはこのタイプに当てはまります。
            <ul>
              <li>ネストされた Result Map – アソシエーション自身も resultMap として記述します。他で定義されている resultMap を参照することもできます。
              </li>
            </ul>
          </li>
          <li>
            <code>collection</code> – 複雑型のコレクションを定義します。
            <ul>
              <li>ネストされた Result Map – コレクション自身も resultMap として記述します。他で定義されている resultMap を参照することもできます。</li>
            </ul>
          </li>
          <li>
            <code>discriminator</code> – 結果の値を使ってどの resultMap を使用するか決定します。
            <ul>
              <li>
                <code>case</code> – case は Result Map の一種で、値が一致した場合に使用されます。
                <ul>
                  <li>ネストされた Result Map – case も Result Map なので、resultMap とほぼ同じ要素を持つことができます。また、別の場所で定義された resultMap を参照することもできます。
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <table>
          <caption>ResultMap Attributes</caption>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>id</code></td>
              <td>このネームスペース内で固有の識別子。resultMap を参照する際に使用します。</td>
            </tr>
            <tr>
              <td><code>type</code></td>
              <td>Java クラスの完全修飾クラス名またはタイプエイリアスを指定します（前に出てきた標準のタイプエイリアスのリストを参照してください）。
              </td>
            </tr>
            <tr>
              <td><code>autoMapping</code></td>
              <td>この resulMap に結果をマッピングする際、自動マッピングを使用するかどうかを true / false で指定します。ここでの指定はグローバルな設定（autoMappingBehavior）より優先されます。デフォルト：未指定
              </td>
            </tr>
          </tbody>
        </table>

        <p>
          <span class="label important">ベストプラクティス</span> ResultMap は段階的に実装するようにしましょう。ユニットテストも効果的です。
          上で見たような巨大な resultMap を一度に実装しようとするとミスが発生しやすく、作業も困難です。
          シンプルなところからスタートして、ユニットテストを書きながら徐々に拡張しましょう。
          フレームワークの欠点でもありますが、ソースが公開されているかどうかに関わらず、フレームワークはある種のブラックボックスとなり得ます。期待通りに動作していることを確かめるにはユニットテストが一番です。
          ユニットテストはバグを報告する場合も役に立ちます。
        </p>

        <p>
          次の章ではそれぞれの要素について詳しく見ていきます。
        </p>

        <h4>id と result</h4>

        <source><![CDATA[<id property="id" column="post_id"/>
<result property="subject" column="post_subject"/>]]></source>

        <p>
          <i>id</i> と <i>result</i> は結果マッピングの基本となる要素です。
          どちらも、ある列の値を単純型（String, int, double, Date など）のプロパティまたはフィールドにマップするときに使用します。
        </p>

        <p>
          両者の違いは、<i>id</i> は、その結果が識別子プロパティ（オブジェクトのインスタンスを比較する際に使われます）であることを表すという点のみです。
          これによって全体的なパフォーマンスが向上しますが、特に恩恵をうけるのはキャッシュとネストされた結果マッピング（＝JOIN マッピング）の処理を行うときです。
        </p>

        <p>
          どちらも多くの属性を持っています。
        </p>

        <table>
          <caption>id and result Attributes</caption>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>property</td>
              <td>
                結果列の値をマップするフィールドまたはプロパティを指定します。名前が一致する JavaBean プロパティがあれば、そのプロパティが使われます。もしなければ、MyBatis は次に名前が一致するフィールドを探します。
                どちらの場合も、ドット表記を使って複雑型のプロパティを指定することができます。
                例えば、 "username" のような単純なプロパティを指定することもできますし、 "address.street.number" のように複雑なプロパティを指定することもできます。
              </td>
            </tr>
            <tr>
              <td>column</td>
              <td>
                データベースで定義されている列名、あるいは列の別名を指定します。resultSet.getString(columnName) メソッドの引数として渡される文字列と同じと考えてください。
              </td>
            </tr>
            <tr>
              <td>javaType</td>
              <td>
                Java クラスの完全修飾クラス名またはタイプエイリアスを指定します（前に出てきた標準のタイプエイリアスのリストを参照してください）。
                通常、JavaBean にマッピングする場合の javaType は MyBatis によって正しく判別されます。
                ただし、HashMap にマッピングする場合は正しい動作を保証するため適切な javaType を指定するようにしてください。
              </td>
            </tr>
            <tr>
              <td>jdbcType</td>
              <td>
                サポートされている JDBC データ型（この後のテーブルにリストがあります）を指定します。
                JDBC データ型の指定が必須となるのは、insert, update, delete の各ステートメントで null が許可されている列を指定した場合だけです。
                これは JDBC の仕様で MyBatis の仕様ではありません。
                ですから、直接 JDBC を使ったコードを書く場合でも null が許可されている列に対しては、やはりデータ型を指定する必要があります。
              </td>
            </tr>
            <tr>
              <td>typeHandler</td>
              <td>
                デフォルトのタイプハンドラーについては既に説明しました。
                このプロパティを使うと、デフォルトのタイプハンドラーをオーバーライドすることができます。
                タイプハンドラーの完全修飾クラス名またはタイプエイリアスを指定します。
              </td>
            </tr>
          </tbody>
        </table>

        <h4>サポートされている JDBC データ型</h4>

        <p>
          参考として、MyBatis に含まれている JdbcType 列挙型によってサポートされている JDBC データ型を以下に挙げておきます。
        </p>

        <table>
          <tr>
            <td>BIT</td>
            <td>FLOAT</td>
            <td>CHAR</td>
            <td>TIMESTAMP</td>
            <td>OTHER</td>
            <td>UNDEFINED</td>
          </tr>
          <tr>
            <td>TINYINT</td>
            <td>REAL</td>
            <td>VARCHAR</td>
            <td>BINARY</td>
            <td>BLOG</td>
            <td>NVARCHAR</td>
          </tr>
          <tr>
            <td>SMALLINT</td>
            <td>DOUBLE</td>
            <td>LONGVARCHAR</td>
            <td>VARBINARY</td>
            <td>CLOB</td>
            <td>NCHAR</td>
          </tr>
          <tr>
            <td>INTEGER</td>
            <td>NUMERIC</td>
            <td>DATE</td>
            <td>LONGVARBINARY</td>
            <td>BOOLEAN</td>
            <td>NCLOB</td>
          </tr>
          <tr>
            <td>BIGINT</td>
            <td>DECIMAL</td>
            <td>TIME</td>
            <td>NULL</td>
            <td>CURSOR</td>
            <td>ARRAY</td>
          </tr>
        </table>

        <h4>constructor</h4>

        <source><![CDATA[<constructor>
   <idArg column="id" javaType="int"/>
   <arg column="username" javaType="String"/>
</constructor>]]></source>

        <p>
          ほとんどの DTO (Data Transfer Object) やドメインモデルではプロパティを使って値を設定することができますが、時にはイミュータブルなクラスを使いたい場合もあるかも知れません。
          通常更新されることのない参照用データを含むテーブルなどはイミュータブルクラスに向いています。
          コンストラクタインジェクションを使うとインスタンス化の際に値を設定することができるので、カプセル化の妨げとなる public メソッドの定義が不要となります。
          MyBatis は private として定義されているプロパティやフィールドもサポートしていますが、コンストラクタインジェクションを好む人もいると思います。
          <i>constructor</i> 要素を使うとコンストラクタインジェクションによって値をマップすることが可能となります。
        </p>

        <p>
          次のようなコンストラクタを考えてみます。
        </p>

        <source><![CDATA[public class User {
   //...
   public User(int id, String username) {
  //...
  }
//...
}]]></source>

        <p>
          このコンストラクタに結果をインジェクトするためには、パラメーターの型によってコンストラクタを識別する必要があります。
          Java では引数の名前を取得する方法がありませんので、constructor 要素を定義する場合は引数を正しい順番に並べ、適切なデータ型を指定するようにしてください。
        </p>


        <source><![CDATA[<constructor>
   <idArg column="id" javaType="int"/>
   <arg column="username" javaType="String"/>
</constructor>]]></source>

        <p>
          それ以外の属性とルールについては通常の id, result 要素と同じです。
        </p>

        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>column</td>
              <td>
                データベースで定義されている列名、あるいは列の別名を指定します。resultSet.getString(columnName) メソッドの引数として渡される文字列と同じと考えてください。
              </td>
            </tr>
            <tr>
              <td>javaType</td>
              <td>
                Java クラスの完全修飾クラス名またはタイプエイリアスを指定します（前に出てきた標準のタイプエイリアスのリストを参照してください）。
                通常、JavaBean にマッピングする場合の javaType は MyBatis によって正しく判別されます。
                ただし、HashMap にマッピングする場合は正しい動作を保証するため適切な javaType を指定するようにしてください。
              </td>
            </tr>
            <tr>
              <td>jdbcType</td>
              <td>
                サポートされている JDBC データ型（この後のテーブルにリストがあります）を指定します。
                JDBC データ型の指定が必須となるのは、insert, update, delete の各ステートメントで null が許可されている列を指定した場合だけです。
                これは JDBC の仕様で MyBatis の仕様ではありません。
                ですから、直接 JDBC を使ったコードを書く場合でも null が許可されている列に対しては、やはりデータ型を指定する必要があります。
              </td>
            </tr>
            <tr>
              <td>typeHandler</td>
              <td>
                デフォルトのタイプハンドラーについては既に説明しました。
                このプロパティを使うと、デフォルトのタイプハンドラーをオーバーライドすることができます。
                タイプハンドラーの完全修飾クラス名またはタイプエイリアスを指定します。
              </td>
            </tr>
            <tr>
              <td>select</td>
              <td>
                別の場所で定義されているステートメントの ID を指定します。
                ステートメントの結果として取得したデータがこのプロパティにマップされます。
                指定された select ステートメントには column 属性で指定した列の値が引数として渡されます。<br />
                詳細は association 要素の説明を参照してください。
              </td>
            </tr>
            <tr>
              <td>resultMap</td>
              <td>
                別の場所で定義されている ResultMap の ID を指定します。ネストされた結果をこのプロパティにマップする際、指定した ResultMap が使われます。
                この方法は、別の select 文を実行する方法の代わりに使うことができ、複数のテーブルを結合して取得した ResultSet をマップすることができます。
                このような ResultSet には重複や繰り返しが含まれているため、正しく分解してからネストされたオブジェクトグラフにマップしてやる必要がありますが、MyBatis ではこの処理を実現するため Result Map を連結できるようになっています。<br />
                詳細は association 要素の説明を参照してください。
              </td>
            </tr>
          </tbody>
        </table>

        <h4>association</h4>

        <source><![CDATA[<association property="author" column="blog_author_id" javaType="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
</association>]]></source>

        <p>
          association 要素は "has-one" タイプのリレーションシップを扱います。
          例えば、上で出てきたサンプルの Blog は１つの Author を持っています。
          アソシエーションは、他の result とほぼ同じように動作します。
          値を設定するプロパティ、値の取得元となる列、プロパティの javaType （ほとんどの場合自動で検出可能）、必要なら jdbcType、またデフォルトのタイプハンドラーをオーバーライドしたい場合は typeHandler を指定します。
        </p>

        <p>
          association が他と異なるのは、アソシエーションを読み込む方法を MyBatis に伝える必要があるという点です。これには２つの方法があります。
        </p>

        <ul>
          <li>
            select をネストする：別のマップドステートメントを実行してその結果を読み込む方法です。
          </li>
          <li>
            結果をネストする：ネストした Result Map を使って結合（Join）した結果を読み込む方法です。
          </li>
        </ul>

        <p>
          まずは要素の属性を調べてみましょう。
          select, resultMap 以外の属性は result 要素と同じです。
        </p>

        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>property</td>
              <td>
                結果列の値をマップするフィールドまたはプロパティを指定します。名前が一致する JavaBean プロパティがあれば、そのプロパティが使われます。もしなければ、MyBatis は次に名前が一致するフィールドを探します。
                どちらの場合も、ドット表記を使って複雑型のプロパティを指定することができます。
                例えば、 "username" のような単純なプロパティを指定することもできますし、 "address.street.number" のように複雑なプロパティを指定することもできます。
              </td>
            </tr>
            <tr>
              <td>javaType</td>
              <td>
                Java クラスの完全修飾クラス名またはタイプエイリアスを指定します（前に出てきた標準のタイプエイリアスのリストを参照してください）。
                通常、JavaBean にマッピングする場合の javaType は MyBatis によって正しく判別されます。
                ただし、HashMap にマッピングする場合は正しい動作を保証するため適切な javaType を指定するようにしてください。
              </td>
            </tr>
            <tr>
              <td>jdbcType</td>
              <td>
                サポートされている JDBC データ型（この後のテーブルにリストがあります）を指定します。
                JDBC データ型の指定が必須となるのは、insert, update, delete の各ステートメントで null が許可されている列を指定した場合だけです。
                これは JDBC の仕様で MyBatis の仕様ではありません。
                ですから、直接 JDBC を使ったコードを書く場合でも null が許可されている列に対しては、やはりデータ型を指定する必要があります。
              </td>
            </tr>
            <tr>
              <td>typeHandler</td>
              <td>
                デフォルトのタイプハンドラーについては既に説明しました。
                このプロパティを使うと、デフォルトのタイプハンドラーをオーバーライドすることができます。
                タイプハンドラーの完全修飾クラス名またはタイプエイリアスを指定します。
              </td>
            </tr>
          </tbody>
        </table>

        <h4>ネストされた select を使って association を読み込む</h4>

        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>column</td>
              <td>
                ネストされた select ステートメントに引数として渡される列名、あるいは列の別名を指定します。resultSet.getString(columnName) メソッドの引数として渡される文字列と同じと考えてください。
                Note: 複合キー（composite key）を扱う場合、column="{prop1=col1,prop2=col2} のように記述することで複数の列名を指定することができます。この例ではネストされた select の実行時に prop1 と prop2 が引数として渡されます。
              </td>
            </tr>
            <tr>
              <td>select</td>
              <td>
                別の場所で定義されているステートメントの ID を指定します。
                ステートメントの結果として取得したデータがこのプロパティにマップされます。
                指定された select ステートメントには column 属性で指定した列の値が引数として渡されます。<br />
                この表の後に詳しいサンプルがあります。
                Note: 複合キー（composite key）を扱う場合、column="{prop1=col1,prop2=col2} のように記述することで複数の列名を指定することができます。この例ではネストされた select の実行時に prop1 と prop2 が引数として渡されます。
              </td>
            </tr>
            <tr>
              <td><code>fetchType</code></td>
              <td>
                任意の属性で、グローバルな <code>lazyLoadingEnabled</code> の設定をオーバーライドする場合に指定します。
                指定可能な値は <code>lazy</code> または <code>eager</code> です。
              </td>
            </tr>
          </tbody>
        </table>

        <p>
          例：
        </p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <association property="author" column="author_id" javaType="Author" select="selectAuthor"/>
</resultMap>

<select id="selectBlog" resultMap="blogResult">
  SELECT * FROM BLOG WHERE ID = #{id}
</select>

<select id="selectAuthor" resultType="Author">
  SELECT * FROM AUTHOR WHERE ID = #{id}
</select>]]></source>

        <p>
          これだけです。
          select ステートメントが二つありますが、一つは Blog、もう一つは Author を読み込むための selct です。
          Blog の resultMap を見ると、author プロパティを読み込むために "selectAuthor" ステートメントを使うように指示されています。
        </p>

        <p>
          他のプロパティは自動的に読み込まれます（列名とプロパティ名が一致していることが前提となります）。
        </p>

        <p>
          この方法は簡単ですが、大量のデータやリストを扱うのには向いていません。
          この問題は "N+1 セレクト問題" として知られています。
          要約すると、"N+1 セレクト問題" が発生する仕組みは下記のようなものです。
        </p>

        <ul>
          <li>レコードのリストを取得するために SQL ステートメントを一つ実行します（これが "+1" です）。</li>
          <li>結果に含まれる各レコードに対して、その詳細を取得するための select 文が一回ずつ実行されます（これが "N" です）。</li>
        </ul>

        <p>
          場合によっては数百、数千もの SQL ステートメントが実行されることになるので、あまり良い方法とは言えません。
        </p>

        <p>
          幸い MyBatis ではこのようなクエリに対して遅延読み込み（Lazy load）を設定することができるので、すべてのクエリが同時に実行されるような状況を避けることも可能です。
          ただし、リストを読み込んだ直後に各要素を反復処理してネストされたデータにアクセスするような処理を行うと、すべての遅延読み込みが実行されるのでパフォーマンスが極端に悪化します。
        </p>

        <p>
          では、もう一つの方法について説明しましょう。
        </p>

        <h4>ネストされた結果を使って association を読み込む</h4>

        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>resultMap</td>
              <td>
                別の場所で定義されている ResultMap の ID を指定します。ネストされた結果をこのプロパティにマップする際、指定した ResultMap が使われます。
                この方法は、別の select 文を実行する方法の代わりに使うことができ、複数のテーブルを結合して取得した ResultSet をマップすることができます。
                このような ResultSet には重複や繰り返しが含まれているため、正しく分解してからネストされたオブジェクトグラフにマップしてやる必要がありますが、MyBatis ではこの処理を実現するため Result Map を連結できるようになっています。<br />
                実際のサンプルを見た方が分かりやすいと思います。この表の後に例を挙げます。
              </td>
            </tr>
            <tr>
              <td><code>columnPrefix</code></td>
              <td>
                複数のテーブルを結合して取得した ResultSet では、列名の重複を防ぐため別名を付けなくてはならない場合があります。
                columnPrefix を指定すると、別の場所で定義されている resultMap を使って別名の付けられた列をマップすることができます。後で説明するサンプルを参照してください。
              </td>
            </tr>
            <tr>
              <td><code>notNullColumn</code></td>
              <td>
                ネストされた結果をマッピングする際、デフォルトでは子オブジェクトのプロパティに対応する列のうち一つでも null でない値がセットされているものがあれば子オブジェクトが生成されます。notNullColumn に列名（複数可）を指定しておくと、指定された列に null 以外の値がセットされた場合にのみ子オブジェクトが生成されます。デフォルト：未指定
              </td>
            </tr>            
            <tr>
              <td><code>autoMapping</code></td>
              <td>このプロパティに結果をマッピングする際、自動マッピングを使用するかどうかを true / false で指定します。ここでの指定はグローバルな設定（autoMappingBehavior）より優先されます。この設定は別の場所で定義されている ResultMap には適用されませんので、<code>select</code> や <code>resultMap</code> が指定されている場合は無効となります。デフォルト：未指定
              </td>
            </tr>
          </tbody>
        </table>

        <p>
          ネストされたアソシエーションについては、既にとても複雑な例を見ていただきました。次のサンプルは、それと比べるとずっと理解しやすいと思います。ここでは、独立した select を実行する代わりに Blog と Author のテーブルを結合するクエリを実行します。
        </p>

        <source><![CDATA[<select id="selectBlog" resultMap="blogResult">
  select
    B.id       as blog_id,
    B.title     as blog_title,
    B.author_id   as blog_author_id,
    A.id       as author_id,
    A.username    as author_username,
    A.password     as author_password,
    A.email     as author_email,
    A.bio       as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
</select>]]></source>

        <p>
          テーブルを結合しているだけでなく、全ての列に固有で分かりやすい別名が指定されていることに注意してください。こうしておくとマッピング作業がずっと楽になります。<br />
          これで結果をマップする準備が整いました。
        </p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author" resultMap="authorResult"/>
</resultMap>

<resultMap id="authorResult" type="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
  <result property="password" column="author_password"/>
  <result property="email" column="author_email"/>
  <result property="bio" column="author_bio"/>
</resultMap>]]></source>

        <p>
          この例では、Blog の "author" を読み込むためのアソシエーションで、別の resultMap "authorResult" を指定しています。
        </p>

        <p>
          <span class="important">超重要</span> ネストされた Result Map では、id 要素が重要な役割を果たします。常に、結果の固有性を判定できる一つ以上のプロパティを id として指定するようにしてください。指定がなくても動作はしますが、パフォーマンスに著しい悪影響を与えます。また、結果の固有性を判定するために必要な最小限のプロパティを指定するようにしてください。主キー（複合キーでも可）は良い選択肢です。
        </p>

        <p>
          上の例では、別の場所で定義した resultMap 要素を指定してアソシエーションを読み込んでいますが、こうすると Author の resultMap を再利用することができます。再利用する必要がない場合や、単に一つの resultMap にマッピングの情報をまとめておきたい場合には、アソシエーションの Result Map をネストすることもできます。この方法で書き直したのが次の例です。
        </p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author" javaType="Author">
    <id property="id" column="author_id"/>
    <result property="username" column="author_username"/>
    <result property="password" column="author_password"/>
    <result property="email" column="author_email"/>
    <result property="bio" column="author_bio"/>
  </association>
</resultMap>]]></source>

        <p>
          もしこの Blog に共著者 co-author が設定されていたらどうなるでしょうか。
          select ステートメントは下記のようになります。
        </p>

        <source><![CDATA[<select id="selectBlog" resultMap="blogResult">
  select
    B.id            as blog_id,
    B.title         as blog_title,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio,
    CA.id           as co_author_id,
    CA.username     as co_author_username,
    CA.password     as co_author_password,
    CA.email        as co_author_email,
    CA.bio          as co_author_bio
  from Blog B
  left outer join Author A on B.author_id = A.id
  left outer join Author CA on B.co_author_id = CA.id
  where B.id = #{id}
</select>]]></source>

        <p>
          Author に対する resultMap は下記のように定義されています。
        </p>

        <source><![CDATA[<resultMap id="authorResult" type="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
  <result property="password" column="author_password"/>
  <result property="email" column="author_email"/>
  <result property="bio" column="author_bio"/>
</resultMap>]]></source>

        <p>
          結果に含まれる列名が resultMap で指定されている列名と異なるので、この resultMap を再利用するためには <code>columnPrefix</code> を指定する必要があります。
        </p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author"
    resultMap="authorResult" />
  <association property="coAuthor"
    resultMap="authorResult"
    columnPrefix="co_" />
</resultMap>]]></source>

        <h4>複数の ResultSet を association にマッピングする</h4>

        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>column</code></td>
              <td>複数の ResultSet を返すステートメントをマッピングする場合、<code>foreignColumn</code> で指定した外部キーと対になってリレーションシップを構成する親オブジェクト側の列を指定します（カンマ区切りで複数指定可能）。
              </td>
            </tr>
            <tr>
              <td><code>foreignColumn</code></td>
              <td>
                <code>column</code> 属性で指定した親オブジェクトの列との照合に使用される外部キーを格納する列を指定します。
              </td>
            </tr>
            <tr>
              <td><code>resultSet</code></td>
              <td>読み込み元の ResultSet の名前を指定します。下記の説明を参照してください。
              </td>
            </tr>
          </tbody>
        </table>
        
        <p>バージョン 3.2.3 から、N+1 セレクト問題を解決する新しい方法が追加されました。</p>
         
        <p>データベースによってはストアドプロシージャから複数の ResultSet を返すことができます。この機能を利用すると、テーブルの結合（Join）を使わず一度の問い合わせで互いに関連する複数のデータを取得することができます。</p>

        <p>以下の例では、ストアドプロシージャが２つの ResultSet を返します。１つめの ResultSet には複数の Blog のデータが含まれており、２つめの ResultSet には複数の Author のデータが含まれています。</p>

        <source><![CDATA[SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM AUTHOR WHERE ID = #{id}]]></source>

        <p>ストアドプロシージャを実行する select 要素の <code>resultSets</code> 属性で、それぞれの ResultSet に名前を付けておく必要があります（カンマ区切り）。ここでは、それぞれ blogs, authors としています。</p>

        <source><![CDATA[<select id="selectBlog" resultSets="blogs,authors" resultMap="blogResult" statementType="CALLABLE">
  {call getBlogsAndAuthors(#{id,jdbcType=INTEGER,mode=IN})}
</select>
]]></source>

        <p>下記の resultMap では、authors 内の各 Author が、それぞれ対応する Blog にマッピングされます。</p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="id" />
  <result property="title" column="title"/>
  <association property="author" javaType="Author" resultSet="authors" column="author_id" foreignColumn="id">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <result property="password" column="password"/>
    <result property="email" column="email"/>
    <result property="bio" column="bio"/>
  </association>
</resultMap>]]></source>

        <p>
          ここまで "has one" タイプのリレーションシップを扱う方法を見て来ましたが、"has many" の場合はどうしたら良いのでしょうか？これは次の章で説明します。
        </p>

        <h4>collection</h4>


        <source><![CDATA[<collection property="posts" ofType="domain.blog.Post">
  <id property="id" column="post_id"/>
  <result property="subject" column="post_subject"/>
  <result property="body" column="post_body"/>
</collection>]]></source>

        <p>
          collection 要素の働きは association とほとんど同じです。同じ説明の繰り返しを省くため、association との違いにフォーカスして見て行きます。
        </p>

        <p>
          引き続き上記のサンプルを使います。Blog に対する Author は一人だけですが、Post は複数存在します。この関係を Blog クラスで表現すると、次のようになると思います。
        </p>

        <source><![CDATA[private List<Post> posts;]]></source>

        <p>
          collection 要素を使ってこのような List 型のプロパティにネストされた結果セットをマップする場合、select をネストする方法と、結果をネストする方法があります。
        </p>

        <h4>ネストされた select を使って collection を読み込む</h4>

        <p>
          まずは、ネストされた select を使って Blog に関連した Post を読み込む例を見てみましょう。
        </p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/>
</resultMap>

<select id="selectBlog" resultMap="blogResult">
  SELECT * FROM BLOG WHERE ID = #{id}
</select>

<select id="selectPostsForBlog" resultType="Blog">
  SELECT * FROM POST WHERE BLOG_ID = #{id}
</select>]]></source>

        <p>
          いろいろ気づいたことがあると思いますが、上で見た association 要素と似た部分が多いと思います。
          まず眼を引くのは collection 要素を使っていることでしょう。次に "ofType" という新しい属性があることに気づくでしょう。
          この属性は、JavaBean のプロパティ（またはフィールド）の型と、コレクションに含まれている型を区別するために必要です。
          したがって、このマッピングは次のように読むことができます。
        </p>

        <source><![CDATA[<collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/>]]></source>

        <p>
          <span class="important">このように読めます</span>: "投稿のリストは、Post クラスを要素とする ArrayList に格納される。"
        </p>

        <p>
          ほとんどの場合、javaType 属性はMyBatis によって推測されるため省略可能です。
          ということで、大抵は下記のように短く書くことができます。
        </p>

        <source><![CDATA[<collection property="posts" column="id" ofType="Post" select="selectPostsForBlog"/>]]></source>

        <h4>ネストされた結果を使って collection を読み込む</h4>

        <p>
          ここまで来れば、ネストされた結果を collection に読み込む方法について想像できるのではないでしょうか。
          なぜなら、association と全く同じだからです（ただし、ネストされた select と同様、"ofType" 属性の指定が必要です）。
        </p>

        <p>まずは SQL を見てみましょう。</p>

        <source><![CDATA[<select id="selectBlog" resultMap="blogResult">
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
</select>]]></source>

        <p>
          Blog と Post テーブルを結合した上で、マッピングを簡単にするため各列に別名を付けています。
          ここまでくれば、次に挙げたシンプルな ResultMap で、Post のリストも含めて Blog のデータを読み込むことができます。
        </p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <collection property="posts" ofType="Post">
    <id property="id" column="post_id"/>
    <result property="subject" column="post_subject"/>
    <result property="body" column="post_body"/>
  </collection>
</resultMap>]]></source>

        <p>
          id 要素の重要さはここでも変わりません。まだ読んでいなければ、上の association 要素についての説明を参照してください。
        </p>

        <p>
          もし、Post のマッピングを再利用したいのであれば、次のように２つの resultMap に分けて書くこともできます。
        </p>
        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <collection property="posts" ofType="Post" resultMap="blogPostResult" columnPrefix="post_"/>
</resultMap>

<resultMap id="blogPostResult" type="Post">
  <id property="id" column="id"/>
  <result property="subject" column="subject"/>
  <result property="body" column="body"/>
</resultMap>]]></source>

        <h4>複数の ResultSets を collection にマッピングする</h4>
        
        <p>
          association で説明したのと同様に、２つの ResultSet を返すストアドプロシージャを呼び出すことができます。１つ目の ResultSet には Blog のリスト、２つ目の ResultSet には Post のリストが含まれているものとします。
        </p>

        <source><![CDATA[SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}]]></source>

       <p>ストアドプロシージャを実行する select 要素の <code>resultSets</code> 属性で、それぞれの ResultSet に名前を付けておく必要があります（カンマ区切り）。ここでは、それぞれ blogs, posts としています。</p>

        <source><![CDATA[<select id="selectBlog" resultSets="blogs,posts" resultMap="blogResult">
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
</select>]]></source>
        
        <p>以下の resultMap では、posts に含まれる Post が、対応する Blog にマッピングされます。</p>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <id property="id" column="id" />
  <result property="title" column="title"/>
  <collection property="posts" ofType="Post" resultSet="posts" column="id" foreignColumn="blog_id">
    <id property="id" column="id"/>
    <result property="subject" column="subject"/>
    <result property="body" column="body"/>
  </collection>
</resultMap>]]></source>

        <p>
          <span class="important">Note</span> collection と association のマッピングに関して、階層の深さやオブジェクトの大きさに制限はありませんし、両者を組み合わせることも可能です。
          ただ、パフォーマンスのことは忘れないようにしてください。
          ユニットテストと負荷テストを怠らなければ、あなたのアプリケーションにとっての最適なアプローチを見つけることができます。
          幸いなことに、後で別のアプローチに切り替える場合でも、MyBatis ならコードの変更は最小限（あるいはゼロ）で済みます。
        </p>

        <p>
          association と collection を使った高度なマッピングはかなり深いテーマです。
          ドキュメントで全てを網羅することはできませんが、少し練習すればすぐに全体がクリアになるはずです。
        </p>

        <h4>discriminator</h4>

        <source><![CDATA[<discriminator javaType="int" column="draft">
  <case value="1" resultType="DraftPost"/>
</discriminator>]]></source>

        <p>
          データベースに対して実行した１回のクエリによって、複数の異なる（何らかの関係を持った）データ型を含む結果が戻ってくることがあります。
          discriminator 要素は、こうしたケースをはじめとして、クラスの継承関係を再現する場合など様々な用途を想定して作られています。
          discriminator は、Java における switch 文と同じように働くので理解するのはそれほど難しくないはずです。
        </p>

        <p>
          discriminator を定義する場合は column と javaType 属性を指定します。
          ここで指定した column は、MyBatis が比較対象の値を参照する際に使用されます。
          javaType は、値が等しいかどうかを調べる際、確実に正しい比較が行われるように指定します（ですが、ほとんどのケースでは String を指定すれば期待通りに動作するはずです）。
          使用例を見てみましょう。
        </p>

        <source><![CDATA[<resultMap id="vehicleResult" type="Vehicle">
  <id property="id" column="id" />
  <result property="vin" column="vin"/>
  <result property="year" column="year"/>
  <result property="make" column="make"/>
  <result property="model" column="model"/>
  <result property="color" column="color"/>
  <discriminator javaType="int" column="vehicle_type">
    <case value="1" resultMap="carResult"/>
    <case value="2" resultMap="truckResult"/>
    <case value="3" resultMap="vanResult"/>
    <case value="4" resultMap="suvResult"/>
  </discriminator>
</resultMap>]]></source>

        <p>
          この例では、MyBatis は結果セットのレコードをひとつずつ取り出して vehicle_type の値を比較します。
          もし、vehicle_type の値が case で指定した条件のいずれかに一致した場合、その case 要素で指定されている resultMap を使って結果のマッピングを行います。
          この処理は排他的に行われます。言い換えると、使われなかった resultMap は無視されるということです（ただし resultMap が継承されている場合は別です。これについてはすぐ後で説明します）。
          一致する case が見つからない場合は、discriminator ブロックの外側で定義されている resultMap だけが適用されます。
          仮に、carResult が次のように定義されていたとします。
        </p>


        <source><![CDATA[<resultMap id="carResult" type="Car">
  <result property="doorCount" column="door_count" />
</resultMap>]]></source>

        <p>
          この場合、doorCount プロパティのみが読み込まれることになります。
          これによって、完全に独立した discriminator case のグループを定義することができます。親の resultMap と全く関連性のない resultMap であっても構いません。
          今回のケースでは車は乗り物の一種（Car is-a Vehicle）なので、car と vehicle の間に関連性があることは明らかです。
          当然、doorCount 以外のプロパティも読み込んで欲しいと思うでしょう。
          resultMap を一箇所変更すれば、希望通りの動作になります。
        </p>

        <source><![CDATA[<resultMap id="carResult" type="Car" extends="vehicleResult">
  <result property="doorCount" column="door_count" />
</resultMap>]]></source>

        <p>
          これで、vehicleResult と carResult の両方で定義されているすべてのプロパティが読み込まれるようになります。
        </p>

        <p>
          繰り返しになりますが、別々の resultMap を定義するのが面倒だと考える方もいると思います。
          簡潔にまとまった表記が好みだという方のために、別の記法も用意されています。
        </p>

        <source><![CDATA[<resultMap id="vehicleResult" type="Vehicle">
  <id property="id" column="id" />
  <result property="vin" column="vin"/>
  <result property="year" column="year"/>
  <result property="make" column="make"/>
  <result property="model" column="model"/>
  <result property="color" column="color"/>
  <discriminator javaType="int" column="vehicle_type">
    <case value="1" resultType="carResult">
      <result property="doorCount" column="door_count" />
    </case>
    <case value="2" resultType="truckResult">
      <result property="boxSize" column="box_size" />
      <result property="extendedCab" column="extended_cab" />
    </case>
    <case value="3" resultType="vanResult">
      <result property="powerSlidingDoor" column="power_sliding_door" />
    </case>
    <case value="4" resultType="suvResult">
      <result property="allWheelDrive" column="all_wheel_drive" />
    </case>
  </discriminator>
</resultMap>]]></source>

        <p>
          <span class="important">思い出してください</span>
          これらは全て Result Map なので、もし result が全く指定されていなければ、MyBatis が自動的に列名と一致する名前を持つプロパティに値を設定します。
          ですから、上で挙げた例の多くは必要以上に冗長になっているといえます。
          ただ、データベースは複雑ですから全てのケースで自動マッピングが使えるということもないでしょう。
        </p>
      </subsection>

      <subsection name="自動マッピング">

        <p>
          前章では、シンプルなケースでは MyBatis の自動マッピングが利用できるということと、複雑なケースではあなた自身で Result Map を記述する必要があるということを説明しました。
          この章では更に、この２つの方法を同時に利用する方法を説明していきます。
          まず、自動マッピングの動作について詳しく見て行きましょう。
        </p>

        <p>
          結果を自動マッピングする際、MyBatis は列名と同じ名前を持つプロパティを探します（大文字と小文字は区別しません）。
          例えば <i>ID</i> という名前の列と <i>id</i> という名前のプロパティが見つかった場合、MyBatis は <i>id</i> プロパティに <i>ID</i> 列の値をセットします。
        </p>

        <p>
          通常、データベースの列名は英数字と単語を区切るアンダースコアで定義され、Java のプロパティはキャメルケースで定義されるのが一般的です。
          <code>mapUnderscoreToCamelCase</code> に true に設定すると、この一般的な命名規則に基づいて自動マッピングを適用することができます。
        </p>
        
        <p>
          Result Map が指定されている場合でも自動マッピングは動作します。この場合、ResultSet に含まれる列のうち、各 Result Map で明示的にマッピングが指定されていない列が自動マッピングの対象となります。
          次の例では、<i>hashed_password</i> 列が password プロパティにマップされ、<i>id</i> と <i>userName</i> 列が自動マッピングの対象となります。
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="User">
  select
    user_id             as "id",
    user_name           as "userName",
    hashed_password
  from some_table
  where id = #{id}
</select>]]></source>

        <source><![CDATA[<resultMap id="userResultMap" type="User">
  <result property="password" column="hashed_password"/>
</resultMap>]]></source>

        <p>
          自動マッピングには３つのレベルがあります。
        </p>
        
        <ul>
          <li>
            <code>NONE</code> - 自動マッピングを無効化します。明示的にマッピングが指定されたプロパティにのみ値がセットされます。
          </li>
          <li>
            <code>PARTIAL</code> - ネストされた Result Map を持たない Result Map のみが自動マッピングの対象となります。
          </li>
          <li>
            <code>FULL</code> - 全ての Result Map が自動マッピングの対象となります。
          </li>
        </ul>

        <p>
          デフォルト値は <code>PARTIAL</code> で、それには理由があります。
          <code>FULL</code> が指定されていると、JOIN 句によって複数のエンティティに対する結果が一行に結合されているような場合に自動マッピングによって意図しないマッピングが実行されてしまう場合があります。
          次の例を見てください。
        </p>
        
        <source><![CDATA[<select id="selectBlog" resultMap="blogResult">
  select
    B.id,
    B.title,
    A.username,
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
</select>]]></source>

        <source><![CDATA[<resultMap id="blogResult" type="Blog">
  <association property="author" javaType="Author" resultMap="authorResult"/>
</resultMap>

<resultMap id="authorResult" type="Author">
  <result property="username" column="author_username"/>
</resultMap>]]></source>
        
        <p>
          この Result Map では、<i>Blog</i> と <i>Author</i> の両方が自動マッピングの対象となりますが、<i>Author</i> に <i>id</i> というプロパティがあり、ResultSet に <i>id</i> という列が含まれているため、Author の id に Blog の id がセットされることになります。
          自動マッピングで <code>FULL</code> を指定する場合は、こうした意図しないマッピングが行われないように注意する必要があります。
        </p>
       

        <p>
          尚、グローバルな自動マッピング設定とは別に、<code>autoMapping</code> 属性を指定することで特定のステートメントでの自動マッピング動作を有効／無効化することもできます。
        </p>

        <source><![CDATA[<select id="selectUsers" resultType="User" autoMapping="false">
  select
    user_id             as "id",
    user_name           as "userName",
    hashed_password
  from some_table
  where id = #{id}
</select>]]></source>
              
      </subsection>

      <subsection name="cache">
        <p>
          MyBatis には非常に柔軟なトランザクション対応のクエリキャッシング機能が用意されています。
          MyBatis 3 では、より強力で、かつ簡単に設定できるよう、キャッシュの実装に多くの改良が加えられています。
        </p>

        <p>
          デフォルトでは、セッション生存期間中のデータを保持するローカルセッションキャッシュのみが有効です。
          グローバルな２次キャッシュを有効にするためには、Mapper XML ファイルに次の一行を追加するだけです。
        </p>

        <source><![CDATA[<cache/>]]></source>

        <p>
          文字通りこれだけです。この行の効果は次の通りです。
        </p>

        <ul>
          <li>この SQL マップファイルに含まれる select ステートメントの結果は全てキャッシュされます。</li>
          <li>この SQL マップファイルに含まれる insert, update, delete ステートメントを実行するとキャッシュがフラッシュされます。</li>
          <li>このキャッシュは LRU アルゴリズムに基づいて置き換えられます。</li>
          <li>このキャッシュは経過時間によってフラッシュされることはありません（つまり Flush Interval は設定されていないということです）。</li>
          <li>このキャッシュはクエリ結果のリストまたはオブジェクトへの参照を 1024 個格納します。</li>
          <li>このキャッシュは読み書き可能なキャッシュとして扱われます。これはつまり、取得したオブジェクトは共有されず、呼び出した側で安全に変更することができる（別の呼び出し元や他スレッドでの変更の影響を受けない）ということを意味しています。</li>
        </ul>

        <p>
          これらのプロパティは cache 要素の属性で変更することができます。
        </p>

        <source><![CDATA[<cache
  eviction="FIFO"
  flushInterval="60000"
  size="512"
  readOnly="true"/>]]></source>

        <p>
          この設定では、以下のようなキャッシュが作成されます。
        </p>
        <ul>
          <li>FIFO アルゴリズムに基づいて置き換えられる。</li>
          <li>60 秒ごとにフラッシュされる。</li>
          <li>結果オブジェクトまたはリストへの参照を 512 個まで格納できる。</li>
          <li>返されるオブジェクトは読み取り専用（read-only）（変更した場合、他の呼び出し元や別スレッドからの変更とコンフリクトする可能性がある）。</li>
        </ul>

        <p>
          指定可能な置換（eviction）ポリシーは以下の通りです。
        </p>

        <ul>
          <li>
            LRU – Least Recently Used: 最も長いこと使われていないオブジェクトを優先的に削除します。
          </li>
          <li>FIFO – First In First Out: 最初に登録されたオブジェクトから順番に削除します。</li>
          <li>
            SOFT – Soft Reference: ガベージコレクターの状態と Soft Reference の規則に基づいてオブジェクトを削除します。
          </li>
          <li>
            WEAK – Weak Reference: ガベージコレクターの状態と Weak Reference の規則に基づいて、より積極的にオブジェクトを削除します。
          </li>
        </ul>

        <p>デフォルト値は LRU です。</p>

        <p>
          flushInterval には、適切な時間（ミリ秒）を表す正の整数を指定することができます。
          デフォルト値は指定なしで、キャッシュがフラッシュされるのはステートメント（insert, update, delete または flushCache が設定された select）が実行された場合のみです。
        </p>

        <p>
          size には任意の正の整数を指定することができますが、実行環境で利用可能なメモリリソースとキャッシュされるオブジェクトのサイズに配慮してください。デフォルト値は 1024 です。
        </p>

        <p>
          readOnly 属性には true または false を設定することができます。読み取り専用キャッシュはキャッシュされたオブジェクトのインスタンスをそのまま呼び出し元に返しますので、このオブジェクトを変更すべきではありません。
          読み取り専用キャッシュの利点は非常に高速だということです。
          読み書き可能なキャッシュは、キャッシュされたオブジェクトを複製して（シリアライゼーションを使います）返しますので読み取り専用と比較すると遅いですが安全です。
          デフォルト値は false です。
        </p>

        <p>
          <span class="label important">NOTE</span> ２次レベルキャッシュはトランザクションに対応しています。SqlSession が (1) commit された場合、あるいは (2) flushCache=true が指定された insert/delete/update が実行されずに rollback された場合に２次レベルキャッシュが更新されます。
        </p>

        <h4>カスタムキャッシュを使う</h4>

        <p>
          上記のプロパティを使ってキャッシュをカスタマイズする方法の他に、自作のキャッシュ実装や 3rd パーティのキャッシュソリューションのアダプタを作成してキャッシュの挙動を完全にオーバーライドしてしまうこともできます。
        </p>

        <source><![CDATA[<cache type="com.domain.something.MyCustomCache"/>]]></source>

        <p>
          上記は、カスタムキャッシュの実装を使用するための設定例です。
          type 属性で指定されているクラスは org.mybatis.cache.Cache インターフェイスを実装している必要があります。
          このインターフェイスは MyBatis の中では複雑な方ですが、その役割を考えればシンプルです。
        </p>

        <source><![CDATA[public interface Cache {
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
}]]></source>

        <p>
          あなたが作成したキャッシュを設定するには、キャッシュの実装クラスに public な JavaBean プロパティを追加し、cache 要素でプロパティを渡しします。
          例えば次のように設定すると、あなたが作成したキャッシュの実装クラスの "setCacheFile(String file)" というメソッドが呼び出されます。
        </p>

        <source><![CDATA[<cache type="com.domain.something.MyCustomCache">
  <property name="cacheFile" value="/tmp/my-custom-cache.tmp"/>
</cache>]]></source>

        <p>設定対象のプロパティは、単純型であれば String 以外でも使用可能です。</p>

        <p>
          ここで重要なのは、キャッシュの設定とキャッシュのインスタンスは Mapper XML ファイルのネームスペースに関連付けられているということです。
          あるネームスペースに対して定義されているキャッシュは、同じネームスペース内で定義されている全てのステートメントに関連付けられます。
          ステートメントごとにキャッシュとの関連性を変更したり無効化することができるように、二つの簡単な属性が用意されています。
          デフォルトでは、各ステートメントは下記のように設定されています。
        </p>

        <source><![CDATA[<select ... flushCache="false" useCache="true"/>
<insert ... flushCache="true"/>
<update ... flushCache="true"/>
<delete ... flushCache="true"/>]]></source>

        <p>
          上記の設定はデフォルトですので、明示的に上記のように設定する必要はありません。
          デフォルトの動作を変更したい場合に限り、flushCache と useCache 属性を設定するようにしてください。
          例えば、特定の select ステートメントの結果をキャッシュの対象から除外したり、ある select ステートメントを実行する際にキャッシュをフラッシュしたい、といった場合です。
          同様に、キャッシュのフラッシュを伴わない update ステートメントを定義したいと思う時があるかも知れません。
        </p>
      </subsection>

      <subsection name="cache-ref">
        <p>
          前の章で説明した通り、あるネームスペースに対して設定されているキャッシュが適用されるのは同じネームスペース内で定義されているステートメントのみですし、このキャッシュをフラッシュするのも同じネームスペース内で定義されているステートメントのみです。
          あるキャッシュの設定とインスタンスを複数のネームスペースで共有したいと思う時があるかも知れません。
          その場合、cache-ref 要素を使って別のネームスペースで定義されているキャッシュの定義を参照することができます。
        </p>

        <source><![CDATA[<cache-ref namespace="com.someone.application.data.SomeMapper"/>]]></source>
      </subsection>
    </section>
  </body>
</document>
