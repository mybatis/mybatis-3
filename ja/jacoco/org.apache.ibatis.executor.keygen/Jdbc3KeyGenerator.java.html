<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Jdbc3KeyGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.executor.keygen</a> &gt; <span class="el_source">Jdbc3KeyGenerator.java</span></div><h1>Jdbc3KeyGenerator.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2009-2019 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.executor.keygen;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.ibatis.binding.MapperMethod.ParamMap;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.ExecutorException;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.reflection.ArrayUtil;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.defaults.DefaultSqlSession.StrictMap;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;

/**
 * @author Clinton Begin
 * @author Kazuki Shimizu
 */
<span class="fc" id="L48">public class Jdbc3KeyGenerator implements KeyGenerator {</span>

  /**
   * A shared instance.
   *
   * @since 3.4.3
   */
<span class="fc" id="L55">  public static final Jdbc3KeyGenerator INSTANCE = new Jdbc3KeyGenerator();</span>

  private static final String MSG_TOO_MANY_KEYS = &quot;Too many keys are generated. There are only %d target objects. &quot;
      + &quot;You either specified a wrong 'keyProperty' or encountered a driver bug like #1523.&quot;;

  @Override
  public void processBefore(Executor executor, MappedStatement ms, Statement stmt, Object parameter) {
    // do nothing
<span class="fc" id="L63">  }</span>

  @Override
  public void processAfter(Executor executor, MappedStatement ms, Statement stmt, Object parameter) {
<span class="fc" id="L67">    processBatch(ms, stmt, parameter);</span>
<span class="fc" id="L68">  }</span>

  public void processBatch(MappedStatement ms, Statement stmt, Object parameter) {
<span class="fc" id="L71">    final String[] keyProperties = ms.getKeyProperties();</span>
<span class="pc bpc" id="L72" title="2 of 4 branches missed.">    if (keyProperties == null || keyProperties.length == 0) {</span>
<span class="nc" id="L73">      return;</span>
    }
<span class="fc" id="L75">    try (ResultSet rs = stmt.getGeneratedKeys()) {</span>
<span class="fc" id="L76">      final ResultSetMetaData rsmd = rs.getMetaData();</span>
<span class="fc" id="L77">      final Configuration configuration = ms.getConfiguration();</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">      if (rsmd.getColumnCount() &lt; keyProperties.length) {</span>
        // Error?
      } else {
<span class="fc" id="L81">        assignKeys(configuration, rs, rsmd, keyProperties, parameter);</span>
      }
<span class="fc" id="L83">    } catch (Exception e) {</span>
<span class="fc" id="L84">      throw new ExecutorException(&quot;Error getting generated key or setting result to parameter object. Cause: &quot; + e, e);</span>
<span class="fc" id="L85">    }</span>
<span class="fc" id="L86">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  private void assignKeys(Configuration configuration, ResultSet rs, ResultSetMetaData rsmd, String[] keyProperties,
      Object parameter) throws SQLException {
<span class="fc bfc" id="L91" title="All 4 branches covered.">    if (parameter instanceof ParamMap || parameter instanceof StrictMap) {</span>
      // Multi-param or single param with @Param
<span class="fc" id="L93">      assignKeysToParamMap(configuration, rs, rsmd, keyProperties, (Map&lt;String, ?&gt;) parameter);</span>
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">    } else if (parameter instanceof ArrayList &amp;&amp; !((ArrayList&lt;?&gt;) parameter).isEmpty()</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        &amp;&amp; ((ArrayList&lt;?&gt;) parameter).get(0) instanceof ParamMap) {</span>
      // Multi-param or single param with @Param in batch operation
<span class="fc" id="L97">      assignKeysToParamMapList(configuration, rs, rsmd, keyProperties, ((ArrayList&lt;ParamMap&lt;?&gt;&gt;) parameter));</span>
    } else {
      // Single param without @Param
<span class="fc" id="L100">      assignKeysToParam(configuration, rs, rsmd, keyProperties, parameter);</span>
    }
<span class="fc" id="L102">  }</span>

  private void assignKeysToParam(Configuration configuration, ResultSet rs, ResultSetMetaData rsmd,
      String[] keyProperties, Object parameter) throws SQLException {
<span class="fc" id="L106">    Collection&lt;?&gt; params = collectionize(parameter);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    if (params.isEmpty()) {</span>
<span class="nc" id="L108">      return;</span>
    }
<span class="fc" id="L110">    List&lt;KeyAssigner&gt; assignerList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">    for (int i = 0; i &lt; keyProperties.length; i++) {</span>
<span class="fc" id="L112">      assignerList.add(new KeyAssigner(configuration, rsmd, i + 1, null, keyProperties[i]));</span>
    }
<span class="fc" id="L114">    Iterator&lt;?&gt; iterator = params.iterator();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">    while (rs.next()) {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">      if (!iterator.hasNext()) {</span>
<span class="fc" id="L117">        throw new ExecutorException(String.format(MSG_TOO_MANY_KEYS, params.size()));</span>
      }
<span class="fc" id="L119">      Object param = iterator.next();</span>
<span class="fc" id="L120">      assignerList.forEach(x -&gt; x.assign(rs, param));</span>
<span class="fc" id="L121">    }</span>
<span class="fc" id="L122">  }</span>

  private void assignKeysToParamMapList(Configuration configuration, ResultSet rs, ResultSetMetaData rsmd,
      String[] keyProperties, ArrayList&lt;ParamMap&lt;?&gt;&gt; paramMapList) throws SQLException {
<span class="fc" id="L126">    Iterator&lt;ParamMap&lt;?&gt;&gt; iterator = paramMapList.iterator();</span>
<span class="fc" id="L127">    List&lt;KeyAssigner&gt; assignerList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L128">    long counter = 0;</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">    while (rs.next()) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">      if (!iterator.hasNext()) {</span>
<span class="fc" id="L131">        throw new ExecutorException(String.format(MSG_TOO_MANY_KEYS, counter));</span>
      }
<span class="fc" id="L133">      ParamMap&lt;?&gt; paramMap = iterator.next();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">      if (assignerList.isEmpty()) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int i = 0; i &lt; keyProperties.length; i++) {</span>
<span class="fc" id="L136">          assignerList</span>
<span class="fc" id="L137">              .add(getAssignerForParamMap(configuration, rsmd, i + 1, paramMap, keyProperties[i], keyProperties, false)</span>
<span class="fc" id="L138">                  .getValue());</span>
        }
      }
<span class="fc" id="L141">      assignerList.forEach(x -&gt; x.assign(rs, paramMap));</span>
<span class="fc" id="L142">      counter++;</span>
<span class="fc" id="L143">    }</span>
<span class="fc" id="L144">  }</span>

  private void assignKeysToParamMap(Configuration configuration, ResultSet rs, ResultSetMetaData rsmd,
      String[] keyProperties, Map&lt;String, ?&gt; paramMap) throws SQLException {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (paramMap.isEmpty()) {</span>
<span class="nc" id="L149">      return;</span>
    }
<span class="fc" id="L151">    Map&lt;String, Entry&lt;Iterator&lt;?&gt;, List&lt;KeyAssigner&gt;&gt;&gt; assignerMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    for (int i = 0; i &lt; keyProperties.length; i++) {</span>
<span class="fc" id="L153">      Entry&lt;String, KeyAssigner&gt; entry = getAssignerForParamMap(configuration, rsmd, i + 1, paramMap, keyProperties[i],</span>
          keyProperties, true);
<span class="fc" id="L155">      Entry&lt;Iterator&lt;?&gt;, List&lt;KeyAssigner&gt;&gt; iteratorPair = assignerMap.computeIfAbsent(entry.getKey(),</span>
<span class="fc" id="L156">          k -&gt; entry(collectionize(paramMap.get(k)).iterator(), new ArrayList&lt;&gt;()));</span>
<span class="fc" id="L157">      iteratorPair.getValue().add(entry.getValue());</span>
    }
<span class="fc" id="L159">    long counter = 0;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">    while (rs.next()) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">      for (Entry&lt;Iterator&lt;?&gt;, List&lt;KeyAssigner&gt;&gt; pair : assignerMap.values()) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (!pair.getKey().hasNext()) {</span>
<span class="fc" id="L163">          throw new ExecutorException(String.format(MSG_TOO_MANY_KEYS, counter));</span>
        }
<span class="fc" id="L165">        Object param = pair.getKey().next();</span>
<span class="fc" id="L166">        pair.getValue().forEach(x -&gt; x.assign(rs, param));</span>
<span class="fc" id="L167">      }</span>
<span class="fc" id="L168">      counter++;</span>
    }
<span class="fc" id="L170">  }</span>

  private Entry&lt;String, KeyAssigner&gt; getAssignerForParamMap(Configuration config, ResultSetMetaData rsmd,
      int columnPosition, Map&lt;String, ?&gt; paramMap, String keyProperty, String[] keyProperties, boolean omitParamName) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">    boolean singleParam = paramMap.values().stream().distinct().count() == 1;</span>
<span class="fc" id="L175">    int firstDot = keyProperty.indexOf('.');</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">    if (firstDot == -1) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (singleParam) {</span>
<span class="fc" id="L178">        return getAssignerForSingleParam(config, rsmd, columnPosition, paramMap, keyProperty, omitParamName);</span>
      }
<span class="fc" id="L180">      throw new ExecutorException(&quot;Could not determine which parameter to assign generated keys to. &quot;</span>
          + &quot;Note that when there are multiple parameters, 'keyProperty' must include the parameter name (e.g. 'param.id'). &quot;
<span class="fc" id="L182">          + &quot;Specified key properties are &quot; + ArrayUtil.toString(keyProperties) + &quot; and available parameters are &quot;</span>
<span class="fc" id="L183">          + paramMap.keySet());</span>
    }
<span class="fc" id="L185">    String paramName = keyProperty.substring(0, firstDot);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (paramMap.containsKey(paramName)) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">      String argParamName = omitParamName ? null : paramName;</span>
<span class="fc" id="L188">      String argKeyProperty = keyProperty.substring(firstDot + 1);</span>
<span class="fc" id="L189">      return entry(paramName, new KeyAssigner(config, rsmd, columnPosition, argParamName, argKeyProperty));</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">    } else if (singleParam) {</span>
<span class="nc" id="L191">      return getAssignerForSingleParam(config, rsmd, columnPosition, paramMap, keyProperty, omitParamName);</span>
    } else {
<span class="fc" id="L193">      throw new ExecutorException(&quot;Could not find parameter '&quot; + paramName + &quot;'. &quot;</span>
          + &quot;Note that when there are multiple parameters, 'keyProperty' must include the parameter name (e.g. 'param.id'). &quot;
<span class="fc" id="L195">          + &quot;Specified key properties are &quot; + ArrayUtil.toString(keyProperties) + &quot; and available parameters are &quot;</span>
<span class="fc" id="L196">          + paramMap.keySet());</span>
    }
  }

  private Entry&lt;String, KeyAssigner&gt; getAssignerForSingleParam(Configuration config, ResultSetMetaData rsmd,
      int columnPosition, Map&lt;String, ?&gt; paramMap, String keyProperty, boolean omitParamName) {
    // Assume 'keyProperty' to be a property of the single param.
<span class="fc" id="L203">    String singleParamName = nameOfSingleParam(paramMap);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">    String argParamName = omitParamName ? null : singleParamName;</span>
<span class="fc" id="L205">    return entry(singleParamName, new KeyAssigner(config, rsmd, columnPosition, argParamName, keyProperty));</span>
  }

  private static String nameOfSingleParam(Map&lt;String, ?&gt; paramMap) {
    // There is virtually one parameter, so any key works.
<span class="fc" id="L210">    return paramMap.keySet().iterator().next();</span>
  }

  private static Collection&lt;?&gt; collectionize(Object param) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (param instanceof Collection) {</span>
<span class="fc" id="L215">      return (Collection&lt;?&gt;) param;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">    } else if (param instanceof Object[]) {</span>
<span class="fc" id="L217">      return Arrays.asList((Object[]) param);</span>
    } else {
<span class="fc" id="L219">      return Arrays.asList(param);</span>
    }
  }

  private static &lt;K, V&gt; Entry&lt;K, V&gt; entry(K key, V value) {
    // Replace this with Map.entry(key, value) in Java 9.
<span class="fc" id="L225">    return new AbstractMap.SimpleImmutableEntry&lt;&gt;(key, value);</span>
  }

  private class KeyAssigner {
    private final Configuration configuration;
    private final ResultSetMetaData rsmd;
    private final TypeHandlerRegistry typeHandlerRegistry;
    private final int columnPosition;
    private final String paramName;
    private final String propertyName;
    private TypeHandler&lt;?&gt; typeHandler;

    protected KeyAssigner(Configuration configuration, ResultSetMetaData rsmd, int columnPosition, String paramName,
<span class="fc" id="L238">        String propertyName) {</span>
<span class="fc" id="L239">      super();</span>
<span class="fc" id="L240">      this.configuration = configuration;</span>
<span class="fc" id="L241">      this.rsmd = rsmd;</span>
<span class="fc" id="L242">      this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span>
<span class="fc" id="L243">      this.columnPosition = columnPosition;</span>
<span class="fc" id="L244">      this.paramName = paramName;</span>
<span class="fc" id="L245">      this.propertyName = propertyName;</span>
<span class="fc" id="L246">    }</span>

    protected void assign(ResultSet rs, Object param) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">      if (paramName != null) {</span>
        // If paramName is set, param is ParamMap
<span class="fc" id="L251">        param = ((ParamMap&lt;?&gt;) param).get(paramName);</span>
      }
<span class="fc" id="L253">      MetaObject metaParam = configuration.newMetaObject(param);</span>
      try {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (typeHandler == null) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">          if (metaParam.hasSetter(propertyName)) {</span>
<span class="fc" id="L257">            Class&lt;?&gt; propertyType = metaParam.getSetterType(propertyName);</span>
<span class="fc" id="L258">            typeHandler = typeHandlerRegistry.getTypeHandler(propertyType,</span>
<span class="fc" id="L259">                JdbcType.forCode(rsmd.getColumnType(columnPosition)));</span>
<span class="fc" id="L260">          } else {</span>
<span class="fc" id="L261">            throw new ExecutorException(&quot;No setter found for the keyProperty '&quot; + propertyName + &quot;' in '&quot;</span>
<span class="fc" id="L262">                + metaParam.getOriginalObject().getClass().getName() + &quot;'.&quot;);</span>
          }
        }
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (typeHandler == null) {</span>
          // Error?
        } else {
<span class="fc" id="L268">          Object value = typeHandler.getResult(rs, columnPosition);</span>
<span class="fc" id="L269">          metaParam.setValue(propertyName, value);</span>
        }
<span class="nc" id="L271">      } catch (SQLException e) {</span>
<span class="nc" id="L272">        throw new ExecutorException(&quot;Error getting generated key or setting result to parameter object. Cause: &quot; + e,</span>
            e);
<span class="fc" id="L274">      }</span>
<span class="fc" id="L275">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>