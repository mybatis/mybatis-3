<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M16 from src/site/markdown/configuration.md at 11 Feb 2024
 | Rendered using Apache Maven Fluido Skin 2.0.0-M8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M16" />
    <meta name="author" content="Clinton Begin" />
    <title>mybatis â€“ MyBatis 3 | Configuration</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M8.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M8.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"><div id="bannerRight"><h1><a href="https://blog.mybatis.org/" class="externalLink"><img class="imageLink" src="../images/mybatis-logo.png" alt="MyBatis logo" /> MyBatis</a></h1></div></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 14 Dec 2023<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 3.5.16-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Reference Documentation</li>
    <li><a href="index.html">Introduction</a></li>
    <li><a href="getting-started.html">Getting Started</a></li>
    <li class="active"><a><span class="icon-chevron-down"></span>Configuration XML</a>
     <ul class="nav nav-list">
      <li><a href="configuration.html#properties">properties</a></li>
      <li><a href="configuration.html#settings">settings</a></li>
      <li><a href="configuration.html#typealiases">typeAliases</a></li>
      <li><a href="configuration.html#typehandlers">typeHandlers</a></li>
      <li><a href="configuration.html#objectfactory">objectFactory</a></li>
      <li><a href="configuration.html#plugins">plugins</a></li>
      <li><a href="configuration.html#environments">environments</a></li>
      <li><a href="configuration.html#databaseidprovider">databaseIdProvider</a></li>
      <li><a href="configuration.html#mappers">mappers</a></li>
     </ul></li>
    <li><a href="sqlmap-xml.html"><span class="icon-chevron-right"></span>Mapper XML Files</a></li>
    <li><a href="dynamic-sql.html">Dynamic SQL</a></li>
    <li><a href="java-api.html"><span class="icon-chevron-right"></span>Java API</a></li>
    <li><a href="statement-builders.html">SQL Builder Class</a></li>
    <li><a href="logging.html">Logging</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><section>
<h2>Configuration</h2>
<p>The MyBatis configuration contains settings and properties that have a dramatic effect on how MyBatis behaves. The high level structure of the document is as follows:</p>
<ul>

<li>configuration
<ul>

<li><a href="#properties">properties</a></li>
<li><a href="#settings">settings</a></li>
<li><a href="#typeAliases">typeAliases</a></li>
<li><a href="#typeHandlers">typeHandlers</a></li>
<li><a href="#objectFactory">objectFactory</a></li>
<li><a href="#plugins">plugins</a></li>
<li><a href="#environments">environments</a>
<ul>

<li>environment
<ul>

<li>transactionManager</li>
<li>dataSource</li>
</ul></li>
</ul></li>
<li><a href="#databaseIdProvider">databaseIdProvider</a></li>
<li><a href="#mappers">mappers</a></li>
</ul></li>
</ul><section>
<h3>properties</h3>
<p>These are externalizable, substitutable properties that can be configured in a typical Java Properties file instance, or passed in through sub-elements of the properties element. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;
&lt;/properties&gt;
</code></pre></div>
<p>The properties can then be used throughout the configuration files to substitute values that need to be dynamically configured. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
&lt;/dataSource&gt;
</code></pre></div>
<p>The username and password in this example will be replaced by the values set in the properties elements. The driver and url properties would be replaced with values contained from the config.properties file. This provides a lot of options for configuration.</p>
<p>Properties can also be passed into the SqlSessionFactoryBuilder.build() methods. For example:</p>

<div class="verbatim">
<pre><code class="language-java">SqlSessionFactory factory =
  sqlSessionFactoryBuilder.build(reader, props);

// ... or ...

SqlSessionFactory factory =
  new SqlSessionFactoryBuilder.build(reader, environment, props);
</code></pre></div>
<p>If a property exists in more than one of these places, MyBatis loads them in the following order:</p>
<ul>

<li>Properties specified in the body of the properties element are read first,</li>
<li>Properties loaded from the classpath resource or url attributes of the properties element are read second, and override any duplicate properties already specified,</li>
<li>Properties passed as a method parameter are read last, and override any duplicate properties that may have been loaded from the properties body and the resource/url attributes.</li>
</ul>
<p>Thus, the highest priority properties are those passed in as a method parameter, followed by resource/url attributes and finally the properties specified in the body of the properties element.</p>
<p>Since the MyBatis 3.4.2, your can specify a default value into placeholder as follow:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- If 'username' property not present, username become 'ut_user' --&gt;
&lt;/dataSource&gt;
</code></pre></div>
<p>This feature is disabled by default. If you specify a default value into placeholder, you should enable this feature by adding a special property as follow:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;
&lt;/properties&gt;
</code></pre></div>
<p><span class="label important">NOTE</span> This will conflict with the <code>&quot;:&quot;</code> character in property keys (e.g. <code>db:username</code>) or the ternary operator of OGNL expressions (e.g. <code>${tableName != null ? tableName : 'global_constants'}</code>) on a SQL definition. If you use either and want default property values, you must change the default value separator by adding this special property:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;
&lt;/properties&gt;
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;username&quot; value=&quot;${db:username?:ut_user}&quot;/&gt;
&lt;/dataSource&gt;
</code></pre></div></section><section>
<h3>settings</h3>
<p>These are extremely important tweaks that modify the way that MyBatis behaves at runtime. The following table describes the settings, their meanings and their default values.</p>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Setting</th>
<th>Description</th>
<th>Valid Values</th>
<th>Default</th></tr></thead><tbody>
<tr class="b">
<td>cacheEnabled</td>
<td>Globally enables or disables any caches configured in any mapper under this configuration.</td>
<td>true | false</td>
<td>true</td></tr>
<tr class="a">
<td>lazyLoadingEnabled</td>
<td>Globally enables or disables lazy loading. When enabled, all relations will be lazily loaded. This value can be superseded for a specific relation by using the <code>fetchType</code> attribute on it.</td>
<td>true | false</td>
<td>false</td></tr>
<tr class="b">
<td>aggressiveLazyLoading</td>
<td>When enabled, any method call will load all the lazy properties of the object. Otherwise, each property is loaded on demand (see also <code>lazyLoadTriggerMethods</code>).</td>
<td>true | false</td>
<td>false (true in &#x2264;3.4.1)</td></tr>
<tr class="a">
<td>multipleResultSetsEnabled</td>
<td>Allows or disallows multiple ResultSets to be returned from a single statement (compatible driver required).</td>
<td>true | false</td>
<td>true</td></tr>
<tr class="b">
<td>useColumnLabel</td>
<td>Uses the column label instead of the column name. Different drivers behave differently in this respect. Refer to the driver documentation, or test out both modes to determine how your driver behaves.</td>
<td>true | false</td>
<td>true</td></tr>
<tr class="a">
<td>useGeneratedKeys</td>
<td>Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work (e.g. Derby).</td>
<td>true | false</td>
<td>False</td></tr>
<tr class="b">
<td>autoMappingBehavior</td>
<td>Specifies if and how MyBatis should automatically map columns to fields/properties. NONE disables auto-mapping. PARTIAL will only auto-map results with no nested result mappings defined inside. FULL will auto-map result mappings of any complexity (containing nested or otherwise).</td>
<td>NONE, PARTIAL, FULL</td>
<td>PARTIAL</td></tr>
<tr class="a">
<td>autoMappingUnknownColumnBehavior</td>
<td>Specify the behavior when detects an unknown column (or unknown property type) of automatic mapping target.
<ul>
<li><code>NONE</code>: Do nothing</li>
<li><code>WARNING</code>: Output warning log (The log level of <code>'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'</code> must be set to <code>WARN</code>)</li>
<li><code>FAILING</code>: Fail mapping (Throw <code>SqlSessionException</code>)</li></ul>Note that there could be false-positives when <code>autoMappingBehavior</code> is set to <code>FULL</code>.</td>
<td>NONE, WARNING, FAILING</td>
<td>NONE</td></tr>
<tr class="b">
<td>defaultExecutorType</td>
<td>Configures the default executor. SIMPLE executor does nothing special. REUSE executor reuses prepared statements. BATCH executor reuses statements and batches updates.</td>
<td>SIMPLE REUSE BATCH</td>
<td>SIMPLE</td></tr>
<tr class="a">
<td>defaultStatementTimeout</td>
<td>Sets the number of seconds the driver will wait for a response from the database.</td>
<td>Any positive integer</td>
<td>Not Set (null)</td></tr>
<tr class="b">
<td>defaultFetchSize</td>
<td>Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting.</td>
<td>Any positive integer</td>
<td>Not Set (null)</td></tr>
<tr class="a">
<td>defaultResultSetType</td>
<td>Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2)</td>
<td>FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(same behavior with &#x2018;Not Set&#x2019;)</td>
<td>Not Set (null)</td></tr>
<tr class="b">
<td>safeRowBoundsEnabled</td>
<td>Allows using RowBounds on nested statements. If allow, set the false.</td>
<td>true | false</td>
<td>False</td></tr>
<tr class="a">
<td>safeResultHandlerEnabled</td>
<td>Allows using ResultHandler on nested statements. If allow, set the false.</td>
<td>true | false</td>
<td>True</td></tr>
<tr class="b">
<td>mapUnderscoreToCamelCase</td>
<td>Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn.</td>
<td>true | false</td>
<td>False</td></tr>
<tr class="a">
<td>localCacheScope</td>
<td>MyBatis uses local cache to prevent circular references and speed up repeated nested queries. By default (SESSION) all queries executed during a session are cached. If localCacheScope=STATEMENT local session will be used just for statement execution, no data will be shared between two different calls to the same SqlSession.</td>
<td>SESSION | STATEMENT</td>
<td>SESSION</td></tr>
<tr class="b">
<td>jdbcTypeForNull</td>
<td>Specifies the JDBC type for null values when no specific JDBC type was provided for the parameter. Some drivers require specifying the column JDBC type but others work with generic values like NULL, VARCHAR or OTHER.</td>
<td>JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER</td>
<td>OTHER</td></tr>
<tr class="a">
<td>lazyLoadTriggerMethods</td>
<td>Specifies which Object's methods trigger a lazy load</td>
<td>A method name list separated by commas</td>
<td>equals,clone,hashCode,toString</td></tr>
<tr class="b">
<td>defaultScriptingLanguage</td>
<td>Specifies the language used by default for dynamic SQL generation.</td>
<td>A type alias or fully qualified class name.</td>
<td>org.apache.ibatis.scripting.xmltags.XMLLanguageDriver</td></tr>
<tr class="a">
<td>defaultEnumTypeHandler</td>
<td>Specifies the <code>TypeHandler</code> used by default for Enum. (Since: 3.4.5)</td>
<td>A type alias or fully qualified class name.</td>
<td>org.apache.ibatis.type.EnumTypeHandler</td></tr>
<tr class="b">
<td>callSettersOnNulls</td>
<td>Specifies if setters or map's put method will be called when a retrieved value is null. It is useful when you rely on Map.keySet() or null value initialization. Note primitives such as (int,boolean,etc.) will not be set to null.</td>
<td>true | false</td>
<td>false</td></tr>
<tr class="a">
<td>returnInstanceForEmptyRow</td>
<td>MyBatis, by default, returns <code>null</code> when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2</td>
<td>true | false</td>
<td>false</td></tr>
<tr class="b">
<td>logPrefix</td>
<td>Specifies the prefix string that MyBatis will add to the logger names.</td>
<td>Any String</td>
<td>Not set</td></tr>
<tr class="a">
<td>logImpl</td>
<td>Specifies which logging implementation MyBatis should use. If this setting is not present logging implementation will be autodiscovered.</td>
<td>SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td>
<td>Not set</td></tr>
<tr class="b">
<td>proxyFactory</td>
<td>Specifies the proxy tool that MyBatis will use for creating lazy loading capable objects.</td>
<td>CGLIB (deprecated since 3.5.10) | JAVASSIST</td>
<td>JAVASSIST (MyBatis 3.3 or above)</td></tr>
<tr class="a">
<td>vfsImpl</td>
<td>Specifies VFS implementations</td>
<td>Fully qualified class names of custom VFS implementation separated by commas.</td>
<td>Not set</td></tr>
<tr class="b">
<td>useActualParamName</td>
<td>Allow referencing statement parameters by their actual names declared in the method signature. To use this feature, your project must be compiled in Java 8 with <code>-parameters</code> option. (Since: 3.4.1)</td>
<td>true | false</td>
<td>true</td></tr>
<tr class="a">
<td>configurationFactory</td>
<td>Specifies the class that provides an instance of <code>Configuration</code>. The returned Configuration instance is used to load lazy properties of deserialized objects. This class must have a method with a signature <code>static Configuration getConfiguration()</code>. (Since: 3.2.3)</td>
<td>A type alias or fully qualified class name.</td>
<td>Not set</td></tr>
<tr class="b">
<td>shrinkWhitespacesInSql</td>
<td>Removes extra whitespace characters from the SQL. Note that this also affects literal strings in SQL. (Since 3.5.5)</td>
<td>true | false</td>
<td>false</td></tr>
<tr class="a">
<td>defaultSqlProviderType</td>
<td>Specifies an sql provider class that holds provider method (Since 3.5.6). This class apply to the <code>type</code>(or <code>value</code>) attribute on sql provider annotation(e.g. <code>@SelectProvider</code>), when these attribute was omitted.</td>
<td>A type alias or fully qualified class name</td>
<td>Not set</td></tr>
<tr class="b">
<td>nullableOnForEach</td>
<td>Specifies the default value of &#x2018;nullable&#x2019; attribute on &#x2018;foreach&#x2019; tag. (Since 3.5.9)</td>
<td>true | false</td>
<td>false</td></tr>
<tr class="a">
<td>argNameBasedConstructorAutoMapping</td>
<td>When applying constructor auto-mapping, argument name is used to search the column to map instead of relying on the column order. (Since 3.5.10)</td>
<td>true | false</td>
<td>false</td></tr></tbody>
</table>

<p>An example of the settings element fully configured is as follows:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;settings&gt;
  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;
  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;safeResultHandlerEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
  &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
  &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;
  &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;org.apache.ibatis.scripting.xmltags.XMLLanguageDriver&quot;/&gt;
  &lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;
  &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;returnInstanceForEmptyRow&quot; value=&quot;false&quot;/&gt;
  &lt;setting name=&quot;logPrefix&quot; value=&quot;exampleLogPreFix_&quot;/&gt;
  &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING&quot;/&gt;
  &lt;setting name=&quot;proxyFactory&quot; value=&quot;CGLIB | JAVASSIST&quot;/&gt;
  &lt;setting name=&quot;vfsImpl&quot; value=&quot;org.mybatis.example.YourselfVfsImpl&quot;/&gt;
  &lt;setting name=&quot;useActualParamName&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;configurationFactory&quot; value=&quot;org.mybatis.example.ConfigurationFactory&quot;/&gt;
&lt;/settings&gt;
</code></pre></div></section><section>
<h3>typeAliases</h3>
<p>A type alias is simply a shorter name for a Java type. It's only relevant to the XML configuration and simply exists to reduce redundant typing of fully qualified classnames. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;typeAliases&gt;
  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;
  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;
  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;
  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;
  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;
  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre></div>
<p>With this configuration, <code>Blog</code> can now be used anywhere that <code>domain.blog.Blog</code> could be.</p>
<p>You can also specify a package where MyBatis will search for beans. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;typeAliases&gt;
  &lt;package name=&quot;domain.blog&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre></div>
<p>Each bean found in <code>domain.blog</code> , if no annotation is found, will be registered as an alias using uncapitalized non-qualified class name of the bean. That is <code>domain.blog.Author</code> will be registered as <code>author</code>. If the <code>@Alias</code> annotation is found its value will be used as an alias. See the example below:</p>

<div class="verbatim">
<pre><code class="language-java">@Alias(&quot;author&quot;)
public class Author {
    ...
}
</code></pre></div>
<p>There are many built-in type aliases for common Java types. They are all case insensitive, note the special handling of primitives due to the overloaded names.</p>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Alias</th>
<th>Mapped Type</th></tr></thead><tbody>
<tr class="b">
<td>_byte</td>
<td>byte</td></tr>
<tr class="a">
<td>_char (since 3.5.10)</td>
<td>char</td></tr>
<tr class="b">
<td>_character (since 3.5.10)</td>
<td>char</td></tr>
<tr class="a">
<td>_long</td>
<td>long</td></tr>
<tr class="b">
<td>_short</td>
<td>short</td></tr>
<tr class="a">
<td>_int</td>
<td>int</td></tr>
<tr class="b">
<td>_integer</td>
<td>int</td></tr>
<tr class="a">
<td>_double</td>
<td>double</td></tr>
<tr class="b">
<td>_float</td>
<td>float</td></tr>
<tr class="a">
<td>_boolean</td>
<td>boolean</td></tr>
<tr class="b">
<td>string</td>
<td>String</td></tr>
<tr class="a">
<td>byte</td>
<td>Byte</td></tr>
<tr class="b">
<td>char (since 3.5.10)</td>
<td>Character</td></tr>
<tr class="a">
<td>character (since 3.5.10)</td>
<td>Character</td></tr>
<tr class="b">
<td>long</td>
<td>Long</td></tr>
<tr class="a">
<td>short</td>
<td>Short</td></tr>
<tr class="b">
<td>int</td>
<td>Integer</td></tr>
<tr class="a">
<td>integer</td>
<td>Integer</td></tr>
<tr class="b">
<td>double</td>
<td>Double</td></tr>
<tr class="a">
<td>float</td>
<td>Float</td></tr>
<tr class="b">
<td>boolean</td>
<td>Boolean</td></tr>
<tr class="a">
<td>date</td>
<td>Date</td></tr>
<tr class="b">
<td>decimal</td>
<td>BigDecimal</td></tr>
<tr class="a">
<td>bigdecimal</td>
<td>BigDecimal</td></tr>
<tr class="b">
<td>biginteger</td>
<td>BigInteger</td></tr>
<tr class="a">
<td>object</td>
<td>Object</td></tr>
<tr class="b">
<td>date[]</td>
<td>Date[]</td></tr>
<tr class="a">
<td>decimal[]</td>
<td>BigDecimal[]</td></tr>
<tr class="b">
<td>bigdecimal[]</td>
<td>BigDecimal[]</td></tr>
<tr class="a">
<td>biginteger[]</td>
<td>BigInteger[]</td></tr>
<tr class="b">
<td>object[]</td>
<td>Object[]</td></tr>
<tr class="a">
<td>map</td>
<td>Map</td></tr>
<tr class="b">
<td>hashmap</td>
<td>HashMap</td></tr>
<tr class="a">
<td>list</td>
<td>List</td></tr>
<tr class="b">
<td>arraylist</td>
<td>ArrayList</td></tr>
<tr class="a">
<td>collection</td>
<td>Collection</td></tr>
<tr class="b">
<td>iterator</td>
<td>Iterator</td></tr></tbody>
</table>
</section><section>
<h3>typeHandlers</h3>
<p>Whenever MyBatis sets a parameter on a PreparedStatement or retrieves a value from a ResultSet, a TypeHandler is used to retrieve the value in a means appropriate to the Java type. The following table describes the default TypeHandlers.</p>
<p><span class="label important">NOTE</span> Since version 3.4.5, MyBatis supports JSR-310 (Date and Time API) by default.</p>
<table class="table table-striped">
<thead>
<tr class="a">
<th>Type Handler</th>
<th>Java Types</th>
<th>JDBC Types</th></tr></thead><tbody>
<tr class="b">
<td><code>BooleanTypeHandler</code></td>
<td><code>java.lang.Boolean</code>, <code>boolean</code></td>
<td>Any compatible <code>BOOLEAN</code></td></tr>
<tr class="a">
<td><code>ByteTypeHandler</code></td>
<td><code>java.lang.Byte</code>, <code>byte</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>BYTE</code></td></tr>
<tr class="b">
<td><code>ShortTypeHandler</code></td>
<td><code>java.lang.Short</code>, <code>short</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>SMALLINT</code></td></tr>
<tr class="a">
<td><code>IntegerTypeHandler</code></td>
<td><code>java.lang.Integer</code>, <code>int</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>INTEGER</code></td></tr>
<tr class="b">
<td><code>LongTypeHandler</code></td>
<td><code>java.lang.Long</code>, <code>long</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>BIGINT</code></td></tr>
<tr class="a">
<td><code>FloatTypeHandler</code></td>
<td><code>java.lang.Float</code>, <code>float</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>FLOAT</code></td></tr>
<tr class="b">
<td><code>DoubleTypeHandler</code></td>
<td><code>java.lang.Double</code>, <code>double</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>DOUBLE</code></td></tr>
<tr class="a">
<td><code>BigDecimalTypeHandler</code></td>
<td><code>java.math.BigDecimal</code></td>
<td>Any compatible <code>NUMERIC</code> or <code>DECIMAL</code></td></tr>
<tr class="b">
<td><code>StringTypeHandler</code></td>
<td><code>java.lang.String</code></td>
<td><code>CHAR</code>, <code>VARCHAR</code></td></tr>
<tr class="a">
<td><code>ClobReaderTypeHandler</code></td>
<td><code>java.io.Reader</code></td>
<td>-</td></tr>
<tr class="b">
<td><code>ClobTypeHandler</code></td>
<td><code>java.lang.String</code></td>
<td><code>CLOB</code>, <code>LONGVARCHAR</code></td></tr>
<tr class="a">
<td><code>NStringTypeHandler</code></td>
<td><code>java.lang.String</code></td>
<td><code>NVARCHAR</code>, <code>NCHAR</code></td></tr>
<tr class="b">
<td><code>NClobTypeHandler</code></td>
<td><code>java.lang.String</code></td>
<td><code>NCLOB</code></td></tr>
<tr class="a">
<td><code>BlobInputStreamTypeHandler</code></td>
<td><code>java.io.InputStream</code></td>
<td>-</td></tr>
<tr class="b">
<td><code>ByteArrayTypeHandler</code></td>
<td><code>byte[]</code></td>
<td>Any compatible byte stream type</td></tr>
<tr class="a">
<td><code>BlobTypeHandler</code></td>
<td><code>byte[]</code></td>
<td><code>BLOB</code>, <code>LONGVARBINARY</code></td></tr>
<tr class="b">
<td><code>DateTypeHandler</code></td>
<td><code>java.util.Date</code></td>
<td><code>TIMESTAMP</code></td></tr>
<tr class="a">
<td><code>DateOnlyTypeHandler</code></td>
<td><code>java.util.Date</code></td>
<td><code>DATE</code></td></tr>
<tr class="b">
<td><code>TimeOnlyTypeHandler</code></td>
<td><code>java.util.Date</code></td>
<td><code>TIME</code></td></tr>
<tr class="a">
<td><code>SqlTimestampTypeHandler</code></td>
<td><code>java.sql.Timestamp</code></td>
<td><code>TIMESTAMP</code></td></tr>
<tr class="b">
<td><code>SqlDateTypeHandler</code></td>
<td><code>java.sql.Date</code></td>
<td><code>DATE</code></td></tr>
<tr class="a">
<td><code>SqlTimeTypeHandler</code></td>
<td><code>java.sql.Time</code></td>
<td><code>TIME</code></td></tr>
<tr class="b">
<td><code>ObjectTypeHandler</code></td>
<td>Any</td>
<td><code>OTHER</code>, or unspecified</td></tr>
<tr class="a">
<td><code>EnumTypeHandler</code></td>
<td>Enumeration Type</td>
<td><code>VARCHAR</code> any string compatible type, as the code is stored (not index).</td></tr>
<tr class="b">
<td><code>EnumOrdinalTypeHandler</code></td>
<td>Enumeration Type</td>
<td>Any compatible <code>NUMERIC</code> or <code>DOUBLE</code>, as the position is stored (not the code itself).</td></tr>
<tr class="a">
<td><code>SqlxmlTypeHandler</code></td>
<td><code>java.lang.String</code></td>
<td><code>SQLXML</code></td></tr>
<tr class="b">
<td><code>InstantTypeHandler</code></td>
<td><code>java.time.Instant</code></td>
<td><code>TIMESTAMP</code></td></tr>
<tr class="a">
<td><code>LocalDateTimeTypeHandler</code></td>
<td><code>java.time.LocalDateTime</code></td>
<td><code>TIMESTAMP</code></td></tr>
<tr class="b">
<td><code>LocalDateTypeHandler</code></td>
<td><code>java.time.LocalDate</code></td>
<td><code>DATE</code></td></tr>
<tr class="a">
<td><code>LocalTimeTypeHandler</code></td>
<td><code>java.time.LocalTime</code></td>
<td><code>TIME</code></td></tr>
<tr class="b">
<td><code>OffsetDateTimeTypeHandler</code></td>
<td><code>java.time.OffsetDateTime</code></td>
<td><code>TIMESTAMP</code></td></tr>
<tr class="a">
<td><code>OffsetTimeTypeHandler</code></td>
<td><code>java.time.OffsetTime</code></td>
<td><code>TIME</code></td></tr>
<tr class="b">
<td><code>ZonedDateTimeTypeHandler</code></td>
<td><code>java.time.ZonedDateTime</code></td>
<td><code>TIMESTAMP</code></td></tr>
<tr class="a">
<td><code>YearTypeHandler</code></td>
<td><code>java.time.Year</code></td>
<td><code>INTEGER</code></td></tr>
<tr class="b">
<td><code>MonthTypeHandler</code></td>
<td><code>java.time.Month</code></td>
<td><code>INTEGER</code></td></tr>
<tr class="a">
<td><code>YearMonthTypeHandler</code></td>
<td><code>java.time.YearMonth</code></td>
<td><code>VARCHAR</code> or <code>LONGVARCHAR</code></td></tr>
<tr class="b">
<td><code>JapaneseDateTypeHandler</code></td>
<td><code>java.time.chrono.JapaneseDate</code></td>
<td><code>DATE</code></td></tr></tbody>
</table>

<p>You can override the type handlers or create your own to deal with unsupported or non-standard types. To do so, implement the interface <code>org.apache.ibatis.type.TypeHandler</code> or extend the convenience class <code>org.apache.ibatis.type.BaseTypeHandler</code> and optionally map it to a JDBC type. For example:</p>

<div class="verbatim">
<pre><code class="language-java">// ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i,
    String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName)
    throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex)
    throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex)
    throws SQLException {
    return cs.getString(columnIndex);
  }
}
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre></div>
<p>Using such a TypeHandler would override the existing type handler for Java String properties and VARCHAR parameters and results. Note that MyBatis does not introspect upon the database metadata to determine the type, so you must specify that it&#x2019;s a VARCHAR field in the parameter and result mappings to hook in the correct type handler. This is due to the fact that MyBatis is unaware of the data type until the statement is executed.</p>
<p>MyBatis will know the Java type that you want to handle with this TypeHandler by introspecting its generic type, but you can override this behavior by two means:</p>
<ul>

<li>Adding a <code>javaType</code> attribute to the typeHandler element (for example: <code>javaType=&quot;String&quot;</code>)</li>
<li>Adding a <code>@MappedTypes</code> annotation to your TypeHandler class specifying the list of java types to associate it with. This annotation will be ignored if the <code>javaType</code> attribute as also been specified.</li>
</ul>
<p>The associated JDBC type can be specified by two means:</p>
<ul>

<li>Adding a <code>jdbcType</code> attribute to the typeHandler element (for example: <code>jdbcType=&quot;VARCHAR&quot;</code>).</li>
<li>Adding a <code>@MappedJdbcTypes</code> annotation to your TypeHandler class specifying the list of JDBC types to associate it with. This annotation will be ignored if the <code>jdbcType</code> attribute as also been specified.</li>
</ul>
<p>When deciding which TypeHandler to use in a <code>ResultMap</code>, the Java type is known (from the result type), but the JDBC type is unknown. MyBatis therefore uses the combination <code>javaType=[TheJavaType], jdbcType=null</code> to choose a TypeHandler. This means that using a <code>@MappedJdbcTypes</code> annotation <em>restricts</em> the scope of a TypeHandler and makes it unavailable for use in <code>ResultMap</code>s unless explicity set. To make a TypeHandler available for use in a <code>ResultMap</code>, set <code>includeNullJdbcType=true</code> on the <code>@MappedJdbcTypes</code> annotation. Since Mybatis 3.4.0 however, if a <strong>single</strong> TypeHandler is registered to handle a Java type, it will be used by default in <code>ResultMap</code>s using this Java type (i.e. even without <code>includeNullJdbcType=true</code>).</p>
<p>And finally you can let MyBatis search for your TypeHandlers:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;package name=&quot;org.mybatis.example&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre></div>
<p>Note that when using the autodiscovery feature JDBC types can only be specified with annotations.</p>
<p>You can create a generic TypeHandler that is able to handle more than one class. For that purpose add a constructor that receives the class as a parameter and MyBatis will pass the actual class when constructing the TypeHandler.</p>

<div class="verbatim">
<pre><code class="language-java">//GenericTypeHandler.java
public class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; {

  private Class&lt;E&gt; type;

  public GenericTypeHandler(Class&lt;E&gt; type) {
    if (type == null) throw new IllegalArgumentException(&quot;Type argument cannot be null&quot;);
    this.type = type;
  }
  ...
</code></pre></div>
<p><code>EnumTypeHandler</code> and <code>EnumOrdinalTypeHandler</code> are generic TypeHandlers. We will learn about them in the following section.</p></section><section>
<h3>Handling Enums</h3>
<p>If you want to map an <code>Enum</code>, you'll need to use either <code>EnumTypeHandler</code> or <code>EnumOrdinalTypeHandler</code>.</p>
<p>For example, let's say that we need to store the rounding mode that should be used with some number if it needs to be rounded. By default, MyBatis uses <code>EnumTypeHandler</code> to convert the <code>Enum</code> values to their names.</p>
<p><strong>Note <code>EnumTypeHandler</code> is special in the sense that unlike other handlers, it does not handle just one specific class, but any class that extends <code>Enum</code></strong></p>
<p>However, we may not want to store names. Our DBA may insist on an integer code instead. That's just as easy: add <code>EnumOrdinalTypeHandler</code> to the <code>typeHandlers</code> in your config file, and now each <code>RoundingMode</code> will be mapped to an integer using its ordinal value.</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;
    javaType=&quot;java.math.RoundingMode&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre></div>
<p>But what if you want to map the same <code>Enum</code> to a string in one place and to integer in another?</p>
<p>The auto-mapper will automatically use <code>EnumOrdinalTypeHandler</code>, so if we want to go back to using plain old ordinary <code>EnumTypeHandler</code>, we have to tell it, by explicitly setting the type handler to use for those SQL statements.</p>
<p>(Mapper files aren't covered until the next section, so if this is your first time reading through the documentation, you may want to skip this for now and come back to it later.)</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;!DOCTYPE mapper
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
    &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;org.apache.ibatis.submitted.rounding.Mapper&quot;&gt;
    &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
        &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt;
        &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;getUser&quot; resultMap=&quot;usermap&quot;&gt;
        select * from users
    &lt;/select&gt;
    &lt;insert id=&quot;insert&quot;&gt;
        insert into users (id, name, funkyNumber, roundingMode) values (
            #{id}, #{name}, #{funkyNumber}, #{roundingMode}
        )
    &lt;/insert&gt;

    &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap2&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
        &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt;
        &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot;
         typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;getUser2&quot; resultMap=&quot;usermap2&quot;&gt;
        select * from users2
    &lt;/select&gt;
    &lt;insert id=&quot;insert2&quot;&gt;
        insert into users2 (id, name, funkyNumber, roundingMode) values (
            #{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler}
        )
    &lt;/insert&gt;

&lt;/mapper&gt;
</code></pre></div>
<p>Note that this forces us to use a <code>resultMap</code> instead of a <code>resultType</code> in our select statements.</p></section><section>
<h3>objectFactory</h3>
<p>Each time MyBatis creates a new instance of a result object, it uses an ObjectFactory instance to do so. The default ObjectFactory does little more than instantiate the target class with a default constructor, or a parameterized constructor if parameter mappings exist. If you want to override the default behaviour of the ObjectFactory, you can create your own. For example:</p>

<div class="verbatim">
<pre><code class="language-java">// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  @Override
  public &lt;T&gt; T create(Class&lt;T&gt; type) {
    return super.create(type);
  }

  @Override
  public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }

  @Override
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }

  @Override
  public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) {
    return Collection.class.isAssignableFrom(type);
  }
}
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- mybatis-config.xml --&gt;
&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
  &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;
</code></pre></div>
<p>The ObjectFactory interface is very simple. It contains two create methods, one to deal with the default constructor, and the other to deal with parameterized constructors. Finally, the setProperties method can be used to configure the ObjectFactory. Properties defined within the body of the objectFactory element will be passed to the setProperties method after initialization of your ObjectFactory instance.</p></section><section>
<h3>plugins</h3>
<p>MyBatis allows you to intercept calls to at certain points within the execution of a mapped statement. By default, MyBatis allows plug-ins to intercept method calls of:</p>
<ul>

<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>The details of these classes methods can be discovered by looking at the full method signature of each, and the source code which is available with each MyBatis release. You should understand the behaviour of the method you&#x2019;re overriding, assuming you&#x2019;re doing something more than just monitoring calls. If you attempt to modify or override the behaviour of a given method, you&#x2019;re likely to break the core of MyBatis. These are low level classes and methods, so use plug-ins with caution.</p>
<p>Using plug-ins is pretty simple given the power they provide. Simply implement the Interceptor interface, being sure to specify the signatures you want to intercept.</p>

<div class="verbatim">
<pre><code class="language-java">// ExamplePlugin.java
@Intercepts({@Signature(
  type= Executor.class,
  method = &quot;update&quot;,
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  private Properties properties = new Properties();

  @Override
  public Object intercept(Invocation invocation) throws Throwable {
    // implement pre-processing if needed
    Object returnObject = invocation.proceed();
    // implement post-processing if needed
    return returnObject;
  }

  @Override
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
}
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- mybatis-config.xml --&gt;
&lt;plugins&gt;
  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre></div>
<p>The plug-in above will intercept all calls to the &#x201c;update&#x201d; method on the Executor instance, which is an internal object responsible for the low-level execution of mapped statements.</p>
<p><span class="label important">NOTE</span> <strong>Overriding the Configuration Class</strong></p>
<p>In addition to modifying core MyBatis behaviour with plugins, you can also override the <code>Configuration</code> class entirely. Simply extend it and override any methods inside, and pass it into the call to the <code>SqlSessionFactoryBuilder.build(myConfig)</code> method. Again though, this could have a severe impact on the behaviour of MyBatis, so use caution.</p></section><section>
<h3>environments</h3>
<p>MyBatis can be configured with multiple environments. This helps you to apply your SQL Maps to multiple databases for any number of reasons. For example, you might have a different configuration for your Development, Test and Production environments. Or, you may have multiple production databases that share the same schema, and you&#x2019;d like to use the same SQL maps for both. There are many use cases.</p>
<p><strong>One important thing to remember though: While you can configure multiple environments, you can only choose ONE per SqlSessionFactory instance.</strong></p>
<p>So if you want to connect to two databases, you need to create two instances of SqlSessionFactory, one for each. For three databases, you&#x2019;d need three instances, and so on. It&#x2019;s really easy to remember:</p>
<ul>

<li><strong>One SqlSessionFactory instance per database</strong></li>
</ul>
<p>To specify which environment to build, you simply pass it to the SqlSessionFactoryBuilder as an optional parameter. The two signatures that accept the environment are:</p>

<div class="verbatim">
<pre><code class="language-java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);
</code></pre></div>
<p>If the environment is omitted, then the default environment is loaded, as follows:</p>

<div class="verbatim">
<pre><code class="language-java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);
</code></pre></div>
<p>The environments element defines how the environment is configured.</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;environments default=&quot;development&quot;&gt;
  &lt;environment id=&quot;development&quot;&gt;
    &lt;transactionManager type=&quot;JDBC&quot;&gt;
      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
    &lt;/transactionManager&gt;
    &lt;dataSource type=&quot;POOLED&quot;&gt;
      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
    &lt;/dataSource&gt;
  &lt;/environment&gt;
&lt;/environments&gt;
</code></pre></div>
<p>Notice the key sections here:</p>
<ul>

<li>The default Environment ID (e.g. default=&#x201c;development&#x201d;).</li>
<li>The Environment ID for each environment defined (e.g. id=&#x201c;development&#x201d;).</li>
<li>The TransactionManager configuration (e.g. type=&#x201c;JDBC&#x201d;)</li>
<li>The DataSource configuration (e.g. type=&#x201c;POOLED&#x201d;)</li>
</ul>
<p>The default environment and the environment IDs are self explanatory. Name them whatever you like, just make sure the default matches one of them.</p>
<p><strong>transactionManager</strong></p>
<p>There are two TransactionManager types (i.e. type=&#x201c;[JDBC|MANAGED]&#x201d;) that are included with MyBatis:</p>
<ul>

<li>
<p>JDBC &#x2013; This configuration simply makes use of the JDBC commit and rollback facilities directly. It relies on the connection retrieved from the dataSource to manage the scope of the transaction. By default, it enables auto-commit when closing the connection for compatibility with some drivers. However, for some drivers, enabling auto-commit is not only unnecessary, but also is an expensive operation. So, since version 3.5.10, you can skip this step by setting the &#x201c;skipSetAutoCommitOnClose&#x201d; property to true. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;transactionManager type=&quot;JDBC&quot;&gt;
  &lt;property name=&quot;skipSetAutoCommitOnClose&quot; value=&quot;true&quot;/&gt;
&lt;/transactionManager&gt;
</code></pre></div></li>
<li>
<p>MANAGED &#x2013; This configuration simply does almost nothing. It never commits, or rolls back a connection. Instead, it lets the container manage the full lifecycle of the transaction (e.g. a JEE Application Server context). By default it does close the connection. However, some containers don&#x2019;t expect this, and thus if you need to stop it from closing the connection, set the &#x201c;closeConnection&#x201d; property to false. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;transactionManager type=&quot;MANAGED&quot;&gt;
  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;
&lt;/transactionManager&gt;
</code></pre></div></li>
</ul>
<p><span class="label important">NOTE</span> If you are planning to use MyBatis with Spring there is no need to configure any TransactionManager because the Spring module will set its own one overriding any previously set configuration.</p>
<p>Neither of these TransactionManager types require any properties. However, they are both Type Aliases, so in other words, instead of using them, you could put your own fully qualified class name or Type Alias that refers to your own implementation of the TransactionFactory interface.</p>

<div class="verbatim">
<pre><code class="language-java">public interface TransactionFactory {
  default void setProperties(Properties props) { // Since 3.5.2, change to default method
    // NOP
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}
</code></pre></div>
<p>Any properties configured in the XML will be passed to the setProperties() method after instantiation. Your implementation would also need to create a Transaction implementation, which is also a very simple interface:</p>

<div class="verbatim">
<pre><code class="language-java">public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}
</code></pre></div>
<p>Using these two interfaces, you can completely customize how MyBatis deals with Transactions.</p>
<p><strong>dataSource</strong></p>
<p>The dataSource element configures the source of JDBC Connection objects using the standard JDBC DataSource interface.</p>
<p>Most MyBatis applications will configure a dataSource as in the example. However, it&#x2019;s not required. Realize though, that to facilitate Lazy Loading, this dataSource is required.</p>
<p>There are three built-in dataSource types (i.e. type=&#x201c;[UNPOOLED|POOLED|JNDI]&#x201d;):</p>
<p><strong>UNPOOLED</strong> &#x2013; This implementation of DataSource simply opens and closes a connection each time it is requested. While it&#x2019;s a bit slower, this is a good choice for simple applications that do not require the performance of immediately available connections. Different databases are also different in this performance area, so for some it may be less important to pool and this configuration will be ideal. The UNPOOLED DataSource has the following properties to configure:</p>
<ul>

<li><code>driver</code> &#x2013; This is the fully qualified Java class of the JDBC driver (NOT of the DataSource class if your driver includes one).</li>
<li><code>url</code> &#x2013; This is the JDBC URL for your database instance.</li>
<li><code>username</code> &#x2013; The database username to log in with.</li>
<li><code>password</code> - The database password to log in with.</li>
<li><code>defaultTransactionIsolationLevel</code> &#x2013; The default transaction isolation level for connections.</li>
<li><code>defaultNetworkTimeout</code> &#x2013; The default network timeout value in milliseconds to wait for the database operation to complete. See the API documentation of <code>java.sql.Connection#setNetworkTimeout()</code> for details.</li>
</ul>
<p>Optionally, you can pass properties to the database driver as well. To do this, prefix the properties with <code>driver.</code>, for example:</p>
<ul>

<li><code>driver.encoding=UTF8</code></li>
</ul>
<p>This will pass the property <code>encoding</code>, with the value <code>UTF8</code>, to your database driver via the <code>DriverManager.getConnection(url, driverProperties)</code> method.</p>
<p><strong>POOLED</strong> &#x2013; This implementation of DataSource pools JDBC Connection objects to avoid the initial connection and authentication time required to create a new Connection instance. This is a popular approach for concurrent web applications to achieve the fastest response.</p>
<p>In addition to the (UNPOOLED) properties above, there are many more properties that can be used to configure the POOLED datasource:</p>
<ul>

<li><code>poolMaximumActiveConnections</code> &#x2013; This is the number of active (i.e. in use) connections that can exist at any given time. Default: 10</li>
<li><code>poolMaximumIdleConnections</code> &#x2013; The number of idle connections that can exist at any given time.</li>
<li><code>poolMaximumCheckoutTime</code> &#x2013; This is the amount of time that a Connection can be &#x201c;checked out&#x201d; of the pool before it will be forcefully returned. Default: 20000ms (i.e. 20 seconds)</li>
<li><code>poolTimeToWait</code> &#x2013; This is a low level setting that gives the pool a chance to print a log status and re-attempt the acquisition of a connection in the case that it&#x2019;s taking unusually long (to avoid failing silently forever if the pool is misconfigured). Default: 20000ms (i.e. 20 seconds)</li>
<li><code>poolMaximumLocalBadConnectionTolerance</code> &#x2013; This is a low level setting about tolerance of bad connections got for any thread. If a thread got a bad connection, it may still have another chance to re-attempt to get another connection which is valid. But the retrying times should not more than the sum of <code>poolMaximumIdleConnections</code> and <code>poolMaximumLocalBadConnectionTolerance</code>. Default: 3 (Since: 3.4.5)</li>
<li><code>poolPingQuery</code> &#x2013; The Ping Query is sent to the database to validate that a connection is in good working order and is ready to accept requests. The default is &#x201c;NO PING QUERY SET&#x201d;, which will cause most database drivers to fail with a decent error message.</li>
<li><code>poolPingEnabled</code> &#x2013; This enables or disables the ping query. If enabled, you must also set the poolPingQuery property with a valid SQL statement (preferably a very fast one). Default: false.</li>
<li><code>poolPingConnectionsNotUsedFor</code> &#x2013; This configures how often the poolPingQuery will be used. This can be set to match the typical timeout for a database connection, to avoid unnecessary pings. Default: 0 (i.e. all connections are pinged every time &#x2013; but only if poolPingEnabled is true of course).</li>
</ul>
<p><strong>JNDI</strong> &#x2013; This implementation of DataSource is intended for use with containers such as EJB or Application Servers that may configure the DataSource centrally or externally and place a reference to it in a JNDI context. This DataSource configuration only requires two properties:</p>
<ul>

<li><code>initial_context</code> &#x2013; This property is used for the Context lookup from the InitialContext (i.e. initialContext.lookup(initial_context)). This property is optional, and if omitted, then the data_source property will be looked up against the InitialContext directly.</li>
<li><code>data_source</code> &#x2013; This is the context path where the reference to the instance of the DataSource can be found. It will be looked up against the context returned by the initial_context lookup, or against the InitialContext directly if no initial_context is supplied.</li>
</ul>
<p>Similar to the other DataSource configurations, it&#x2019;s possible to send properties directly to the InitialContext by prefixing those properties with <code>env.</code>, for example:</p>
<ul>

<li><code>env.encoding=UTF8</code></li>
</ul>
<p>This would send the property <code>encoding</code> with the value of <code>UTF8</code> to the constructor of the InitialContext upon instantiation.</p>
<p>You can plug any 3rd party DataSource by implementing the interface <code>org.apache.ibatis.datasource.DataSourceFactory</code>:</p>

<div class="verbatim">
<pre><code class="language-java">public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}
</code></pre></div>
<p><code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> can be used as super class to build new datasource adapters. For example this is the code needed to plug C3P0:</p>

<div class="verbatim">
<pre><code class="language-java">import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

  public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
  }
}
</code></pre></div>
<p>To set it up, add a property for each setter method you want MyBatis to call. Follows below a sample configuration which connects to a PostgreSQL database:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;dataSource type=&quot;org.myproject.C3P0DataSourceFactory&quot;&gt;
  &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql:mydb&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/dataSource&gt;
</code></pre></div></section><section>
<h3>databaseIdProvider</h3>
<p>MyBatis is able to execute different statements depending on your database vendor. The multi-db vendor support is based on the mapped statements <code>databaseId</code> attribute. MyBatis will load all statements with no <code>databaseId</code> attribute or with a <code>databaseId</code> that matches the current one. In case the same statement is found with and without the <code>databaseId</code> the latter will be discarded. To enable the multi vendor support add a <code>databaseIdProvider</code> to mybatis-config.xml file as follows:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt;
</code></pre></div>
<p>The DB_VENDOR implementation databaseIdProvider sets as databaseId the String returned by <code>DatabaseMetaData#getDatabaseProductName()</code>. Given that usually that string is too long and that different versions of the same product may return different values, you may want to convert it to a shorter one by adding properties like follows:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;
  &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;
  &lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&gt;
  &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;
&lt;/databaseIdProvider&gt;
</code></pre></div>
<p>When properties are provided, the DB_VENDOR databaseIdProvider will search the property value corresponding to the first key found in the returned database product name or &#x201c;null&#x201d; if there is not a matching property. In this case, if <code>getDatabaseProductName()</code> returns &#x201c;Oracle (DataDirect)&#x201d; the databaseId will be set to &#x201c;oracle&#x201d;.</p>
<p>You can build your own DatabaseIdProvider by implementing the interface <code>org.apache.ibatis.mapping.DatabaseIdProvider</code> and registering it in mybatis-config.xml:</p>

<div class="verbatim">
<pre><code class="language-java">public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // Since 3.5.2, changed to default method
    // NOP
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}
</code></pre></div></section><section>
<h3>mappers</h3>
<p>Now that the behavior of MyBatis is configured with the above configuration elements, we&#x2019;re ready to define our mapped SQL statements. But first, we need to tell MyBatis where to find them. Java doesn&#x2019;t really provide any good means of auto-discovery in this regard, so the best way to do it is to simply tell MyBatis where to find the mapping files. You can use classpath relative resource references, fully qualified url references (including <code>file:///</code> URLs), class names or package names. For example:</p>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- Using classpath relative resources --&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- Using url fully qualified paths --&gt;
&lt;mappers&gt;
  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- Using mapper interface classes --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre></div>

<div class="verbatim">
<pre><code class="language-xml">&lt;!-- Register all interfaces in a package as mappers --&gt;
&lt;mappers&gt;
  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre></div>
<p>These statement simply tell MyBatis where to go from here. The rest of the details are in each of the SQL Mapping files, and that&#x2019;s exactly what the next section will discuss.</p></section></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2009â€“2024
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
