<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResultMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.mapping</a> &gt; <span class="el_source">ResultMap.java</span></div><h1>ResultMap.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2009-2023 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.mapping;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.builder.BuilderException;
import org.apache.ibatis.logging.Log;
import org.apache.ibatis.logging.LogFactory;
import org.apache.ibatis.reflection.ParamNameUtil;
import org.apache.ibatis.session.Configuration;

/**
 * @author Clinton Begin
 */
public class ResultMap {
  private Configuration configuration;

  private String id;
  private Class&lt;?&gt; type;
  private List&lt;ResultMapping&gt; resultMappings;
  private List&lt;ResultMapping&gt; idResultMappings;
  private List&lt;ResultMapping&gt; constructorResultMappings;
  private List&lt;ResultMapping&gt; propertyResultMappings;
  private Set&lt;String&gt; mappedColumns;
  private Set&lt;String&gt; mappedProperties;
  private Discriminator discriminator;
  private boolean hasNestedResultMaps;
  private boolean hasNestedQueries;
  private Boolean autoMapping;

  private ResultMap() {
  }

  public static class Builder {
<span class="fc" id="L57">    private static final Log log = LogFactory.getLog(Builder.class);</span>

<span class="fc" id="L59">    private final ResultMap resultMap = new ResultMap();</span>

    public Builder(Configuration configuration, String id, Class&lt;?&gt; type, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc" id="L62">      this(configuration, id, type, resultMappings, null);</span>
<span class="fc" id="L63">    }</span>

    public Builder(Configuration configuration, String id, Class&lt;?&gt; type, List&lt;ResultMapping&gt; resultMappings,
<span class="fc" id="L66">        Boolean autoMapping) {</span>
<span class="fc" id="L67">      resultMap.configuration = configuration;</span>
<span class="fc" id="L68">      resultMap.id = id;</span>
<span class="fc" id="L69">      resultMap.type = type;</span>
<span class="fc" id="L70">      resultMap.resultMappings = resultMappings;</span>
<span class="fc" id="L71">      resultMap.autoMapping = autoMapping;</span>
<span class="fc" id="L72">    }</span>

    public Builder discriminator(Discriminator discriminator) {
<span class="fc" id="L75">      resultMap.discriminator = discriminator;</span>
<span class="fc" id="L76">      return this;</span>
    }

    public Class&lt;?&gt; type() {
<span class="nc" id="L80">      return resultMap.type;</span>
    }

    public ResultMap build() {
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">      if (resultMap.id == null) {</span>
<span class="nc" id="L85">        throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;);</span>
      }
<span class="fc" id="L87">      resultMap.mappedColumns = new HashSet&lt;&gt;();</span>
<span class="fc" id="L88">      resultMap.mappedProperties = new HashSet&lt;&gt;();</span>
<span class="fc" id="L89">      resultMap.idResultMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L90">      resultMap.constructorResultMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L91">      resultMap.propertyResultMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L92">      final List&lt;String&gt; constructorArgNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">      for (ResultMapping resultMapping : resultMap.resultMappings) {</span>
<span class="fc bfc" id="L94" title="All 4 branches covered.">        resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps</span>
<span class="fc bfc" id="L96" title="All 4 branches covered.">            || resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null;</span>
<span class="fc" id="L97">        final String column = resultMapping.getColumn();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (column != null) {</span>
<span class="fc" id="L99">          resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        } else if (resultMapping.isCompositeResult()) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">          for (ResultMapping compositeResultMapping : resultMapping.getComposites()) {</span>
<span class="fc" id="L102">            final String compositeColumn = compositeResultMapping.getColumn();</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">            if (compositeColumn != null) {</span>
<span class="fc" id="L104">              resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));</span>
            }
<span class="fc" id="L106">          }</span>
        }
<span class="fc" id="L108">        final String property = resultMapping.getProperty();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (property != null) {</span>
<span class="fc" id="L110">          resultMap.mappedProperties.add(property);</span>
        }
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {</span>
<span class="fc" id="L113">          resultMap.constructorResultMappings.add(resultMapping);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">          if (resultMapping.getProperty() != null) {</span>
<span class="fc" id="L115">            constructorArgNames.add(resultMapping.getProperty());</span>
          }
        } else {
<span class="fc" id="L118">          resultMap.propertyResultMappings.add(resultMapping);</span>
        }
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (resultMapping.getFlags().contains(ResultFlag.ID)) {</span>
<span class="fc" id="L121">          resultMap.idResultMappings.add(resultMapping);</span>
        }
<span class="fc" id="L123">      }</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">      if (resultMap.idResultMappings.isEmpty()) {</span>
<span class="fc" id="L125">        resultMap.idResultMappings.addAll(resultMap.resultMappings);</span>
      }
<span class="fc bfc" id="L127" title="All 2 branches covered.">      if (!constructorArgNames.isEmpty()) {</span>
<span class="fc" id="L128">        final List&lt;String&gt; actualArgNames = argNamesOfMatchingConstructor(constructorArgNames);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (actualArgNames == null) {</span>
<span class="fc" id="L130">          throw new BuilderException(&quot;Error in result map '&quot; + resultMap.id + &quot;'. Failed to find a constructor in '&quot;</span>
<span class="fc" id="L131">              + resultMap.getType().getName() + &quot;' with arg names &quot; + constructorArgNames</span>
              + &quot;. Note that 'javaType' is required when there is no readable property with the same name ('name' is optional, BTW). There might be more info in debug log.&quot;);
        }
<span class="fc" id="L134">        resultMap.constructorResultMappings.sort((o1, o2) -&gt; {</span>
<span class="fc" id="L135">          int paramIdx1 = actualArgNames.indexOf(o1.getProperty());</span>
<span class="fc" id="L136">          int paramIdx2 = actualArgNames.indexOf(o2.getProperty());</span>
<span class="fc" id="L137">          return paramIdx1 - paramIdx2;</span>
        });
      }
      // lock down collections
<span class="fc" id="L141">      resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);</span>
<span class="fc" id="L142">      resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);</span>
<span class="fc" id="L143">      resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);</span>
<span class="fc" id="L144">      resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);</span>
<span class="fc" id="L145">      resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);</span>
<span class="fc" id="L146">      return resultMap;</span>
    }

    private List&lt;String&gt; argNamesOfMatchingConstructor(List&lt;String&gt; constructorArgNames) {
<span class="fc" id="L150">      Constructor&lt;?&gt;[] constructors = resultMap.type.getDeclaredConstructors();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">      for (Constructor&lt;?&gt; constructor : constructors) {</span>
<span class="fc" id="L152">        Class&lt;?&gt;[] paramTypes = constructor.getParameterTypes();</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (constructorArgNames.size() == paramTypes.length) {</span>
<span class="fc" id="L154">          List&lt;String&gt; paramNames = getArgNames(constructor);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">          if (constructorArgNames.containsAll(paramNames)</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">              &amp;&amp; argTypesMatch(constructorArgNames, paramTypes, paramNames)) {</span>
<span class="fc" id="L157">            return paramNames;</span>
          }
        }
      }
<span class="fc" id="L161">      return null;</span>
    }

    private boolean argTypesMatch(final List&lt;String&gt; constructorArgNames, Class&lt;?&gt;[] paramTypes,
        List&lt;String&gt; paramNames) {
<span class="fc bfc" id="L166" title="All 2 branches covered.">      for (int i = 0; i &lt; constructorArgNames.size(); i++) {</span>
<span class="fc" id="L167">        Class&lt;?&gt; actualType = paramTypes[paramNames.indexOf(constructorArgNames.get(i))];</span>
<span class="fc" id="L168">        Class&lt;?&gt; specifiedType = resultMap.constructorResultMappings.get(i).getJavaType();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (!actualType.equals(specifiedType)) {</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">          if (log.isDebugEnabled()) {</span>
<span class="nc" id="L171">            log.debug(&quot;While building result map '&quot; + resultMap.id + &quot;', found a constructor with arg names &quot;</span>
<span class="nc" id="L172">                + constructorArgNames + &quot;, but the type of '&quot; + constructorArgNames.get(i)</span>
<span class="nc" id="L173">                + &quot;' did not match. Specified: [&quot; + specifiedType.getName() + &quot;] Declared: [&quot; + actualType.getName()</span>
                + &quot;]&quot;);
          }
<span class="fc" id="L176">          return false;</span>
        }
      }
<span class="fc" id="L179">      return true;</span>
    }

    private List&lt;String&gt; getArgNames(Constructor&lt;?&gt; constructor) {
<span class="fc" id="L183">      List&lt;String&gt; paramNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L184">      List&lt;String&gt; actualParamNames = null;</span>
<span class="fc" id="L185">      final Annotation[][] paramAnnotations = constructor.getParameterAnnotations();</span>
<span class="fc" id="L186">      int paramCount = paramAnnotations.length;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">      for (int paramIndex = 0; paramIndex &lt; paramCount; paramIndex++) {</span>
<span class="fc" id="L188">        String name = null;</span>
<span class="pc bfc" id="L189" title="All 2 branches covered.">        for (Annotation annotation : paramAnnotations[paramIndex]) {</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">          if (annotation instanceof Param) {</span>
<span class="fc" id="L191">            name = ((Param) annotation).value();</span>
<span class="fc" id="L192">            break;</span>
          }
        }
<span class="pc bpc" id="L195" title="1 of 4 branches missed.">        if (name == null &amp;&amp; resultMap.configuration.isUseActualParamName()) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">          if (actualParamNames == null) {</span>
<span class="fc" id="L197">            actualParamNames = ParamNameUtil.getParamNames(constructor);</span>
          }
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">          if (actualParamNames.size() &gt; paramIndex) {</span>
<span class="fc" id="L200">            name = actualParamNames.get(paramIndex);</span>
          }
        }
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        paramNames.add(name != null ? name : &quot;arg&quot; + paramIndex);</span>
      }
<span class="fc" id="L205">      return paramNames;</span>
    }
  }

  public String getId() {
<span class="fc" id="L210">    return id;</span>
  }

  public boolean hasNestedResultMaps() {
<span class="fc" id="L214">    return hasNestedResultMaps;</span>
  }

  public boolean hasNestedQueries() {
<span class="nc" id="L218">    return hasNestedQueries;</span>
  }

  public Class&lt;?&gt; getType() {
<span class="fc" id="L222">    return type;</span>
  }

  public List&lt;ResultMapping&gt; getResultMappings() {
<span class="fc" id="L226">    return resultMappings;</span>
  }

  public List&lt;ResultMapping&gt; getConstructorResultMappings() {
<span class="fc" id="L230">    return constructorResultMappings;</span>
  }

  public List&lt;ResultMapping&gt; getPropertyResultMappings() {
<span class="fc" id="L234">    return propertyResultMappings;</span>
  }

  public List&lt;ResultMapping&gt; getIdResultMappings() {
<span class="fc" id="L238">    return idResultMappings;</span>
  }

  public Set&lt;String&gt; getMappedColumns() {
<span class="fc" id="L242">    return mappedColumns;</span>
  }

  public Set&lt;String&gt; getMappedProperties() {
<span class="fc" id="L246">    return mappedProperties;</span>
  }

  public Discriminator getDiscriminator() {
<span class="fc" id="L250">    return discriminator;</span>
  }

  public void forceNestedResultMaps() {
<span class="fc" id="L254">    hasNestedResultMaps = true;</span>
<span class="fc" id="L255">  }</span>

  public Boolean getAutoMapping() {
<span class="fc" id="L258">    return autoMapping;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>